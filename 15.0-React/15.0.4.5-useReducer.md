# React - useReducer : Gestion d'État Complexe

Dès que ton état devient complexe avec plusieurs variables liées, **useReducer** va te sauver la vie. C'est l'état managé façon **Redux**, mais en plus simple.

---

## Pourquoi useReducer ?

### Le Problème avec useState

```jsx
// ❌ useState devient un cauchemar avec plusieurs états liés
function ComplexStateWithUseState() {
  const [count, setCount] = useState(0)
  const [step, setStep] = useState(1)
  const [isIncrementing, setIsIncrementing] = useState(true)
  const [history, setHistory] = useState([])
  const [canUndo, setCanUndo] = useState(false)
  const [maxValue, setMaxValue] = useState(100)

  const increment = () => {
    const newCount = Math.min(count + step, maxValue)
    setCount(newCount)
    setHistory(prev => [...prev, { action: 'increment', value: newCount, step }])
    setCanUndo(true)
    
    if (newCount === maxValue) {
      setIsIncrementing(false)
    }
  }

  const decrement = () => {
    const newCount = Math.max(count - step, 0)
    setCount(newCount)
    setHistory(prev => [...prev, { action: 'decrement', value: newCount, step }])
    setCanUndo(true)
    
    if (newCount === 0) {
      setIsIncrementing(true)
    }
  }

  const undo = () => {
    if (history.length > 0) {
      const lastAction = history[history.length - 1]
      setCount(lastAction.previousValue || 0)
      setHistory(prev => prev.slice(0, -1))
      setCanUndo(history.length > 1)
    }
  }

  const reset = () => {
    setCount(0)
    setStep(1)
    setIsIncrementing(true)
    setHistory([])
    setCanUndo(false)
  }

  // 😵 Logique éparpillée partout !
  // 🐛 Risque de states désynchronisés !
  // 💀 Difficile à maintenir et débugger !
}
```

### La Solution avec useReducer

```jsx
// ✅ useReducer centralise toute la logique !
function counterReducer(state, action) {
  switch (action.type) {
    case 'increment': {
      const newCount = Math.min(state.count + state.step, state.maxValue)
      return {
        ...state,
        count: newCount,
        history: [...state.history, {
          action: 'increment',
          previousValue: state.count,
          value: newCount,
          step: state.step
        }],
        canUndo: true,
        isIncrementing: newCount < state.maxValue
      }
    }

    case 'decrement': {
      const newCount = Math.max(state.count - state.step, 0)
      return {
        ...state,
        count: newCount,
        history: [...state.history, {
          action: 'decrement',
          previousValue: state.count,
          value: newCount,
          step: state.step
        }],
        canUndo: true,
        isIncrementing: newCount > 0
      }
    }

    case 'undo': {
      if (state.history.length === 0) return state
      
      const lastAction = state.history[state.history.length - 1]
      return {
        ...state,
        count: lastAction.previousValue,
        history: state.history.slice(0, -1),
        canUndo: state.history.length > 1
      }
    }

    case 'set_step':
      return { ...state, step: action.payload }

    case 'set_max_value':
      return { 
        ...state, 
        maxValue: action.payload,
        count: Math.min(state.count, action.payload)
      }

    case 'reset':
      return {
        count: 0,
        step: 1,
        isIncrementing: true,
        history: [],
        canUndo: false,
        maxValue: state.maxValue
      }

    default:
      throw new Error(`Action non gérée: ${action.type}`)
  }
}

function ComplexStateWithUseReducer() {
  const [state, dispatch] = useReducer(counterReducer, {
    count: 0,
    step: 1,
    isIncrementing: true,
    history: [],
    canUndo: false,
    maxValue: 100
  })

  return (
    <div>
      <h3>useReducer Counter</h3>
      
      <div>
        <h4>État: {state.count} / {state.maxValue}</h4>
        <p>Step: {state.step}</p>
        <p>Direction: {state.isIncrementing ? '↗️ Montant' : '↘️ Descendant'}</p>
      </div>

      <div>
        <button 
          onClick={() => dispatch({ type: 'increment' })}
          disabled={state.count >= state.maxValue}
        >
          +{state.step}
        </button>
        
        <button 
          onClick={() => dispatch({ type: 'decrement' })}
          disabled={state.count <= 0}
        >
          -{state.step}
        </button>
        
        <button 
          onClick={() => dispatch({ type: 'undo' })}
          disabled={!state.canUndo}
        >
          ⏪ Undo
        </button>
        
        <button onClick={() => dispatch({ type: 'reset' })}>
          🔄 Reset
        </button>
      </div>

      <div>
        <label>
          Step:
          <input
            type="number"
            value={state.step}
            onChange={e => dispatch({ 
              type: 'set_step', 
              payload: Number(e.target.value) 
            })}
            min="1"
            max="10"
          />
        </label>
        
        <label style={{ marginLeft: '20px' }}>
          Max Value:
          <input
            type="number"
            value={state.maxValue}
            onChange={e => dispatch({ 
              type: 'set_max_value', 
              payload: Number(e.target.value) 
            })}
            min="10"
            max="1000"
          />
        </label>
      </div>

      <div>
        <h4>Historique ({state.history.length})</h4>
        <ul style={{ maxHeight: '150px', overflow: 'auto' }}>
          {state.history.slice(-10).map((entry, index) => (
            <li key={index}>
              {entry.action} - {entry.previousValue} → {entry.value}
              {entry.step && ` (step: ${entry.step})`}
            </li>
          ))}
        </ul>
      </div>
    </div>
  )
}
```

---

## Anatomie d'un Reducer

### Structure de Base

```jsx
// 1. ✅ État initial
const initialState = {
  loading: false,
  data: null,
  error: null
}

// 2. ✅ Reducer function
function dataReducer(state, action) {
  switch (action.type) {
    case 'FETCH_START':
      return {
        ...state,
        loading: true,
        error: null
      }
      
    case 'FETCH_SUCCESS':
      return {
        ...state,
        loading: false,
        data: action.payload
      }
      
    case 'FETCH_ERROR':
      return {
        ...state,
        loading: false,
        error: action.payload
      }
      
    default:
      throw new Error(`Unknown action type: ${action.type}`)
  }
}

// 3. ✅ Usage dans le composant
function DataComponent() {
  const [state, dispatch] = useReducer(dataReducer, initialState)

  const fetchData = async () => {
    dispatch({ type: 'FETCH_START' })
    
    try {
      const response = await fetch('/api/data')
      const data = await response.json()
      dispatch({ type: 'FETCH_SUCCESS', payload: data })
    } catch (error) {
      dispatch({ type: 'FETCH_ERROR', payload: error.message })
    }
  }

  return (
    <div>
      {state.loading && <p>Chargement...</p>}
      {state.error && <p>Erreur: {state.error}</p>}
      {state.data && <pre>{JSON.stringify(state.data, null, 2)}</pre>}
      
      <button onClick={fetchData}>Fetch Data</button>
    </div>
  )
}
```

### Actions avec Payload

```jsx
// Types d'actions pour la lisibilité
const ACTIONS = {
  ADD_ITEM: 'ADD_ITEM',
  REMOVE_ITEM: 'REMOVE_ITEM',
  UPDATE_ITEM: 'UPDATE_ITEM',
  TOGGLE_ITEM: 'TOGGLE_ITEM',
  CLEAR_ALL: 'CLEAR_ALL',
  SET_FILTER: 'SET_FILTER'
}

function todoReducer(state, action) {
  switch (action.type) {
    case ACTIONS.ADD_ITEM:
      return {
        ...state,
        items: [...state.items, {
          id: action.payload.id || Date.now(),
          text: action.payload.text,
          completed: false,
          createdAt: new Date().toISOString()
        }]
      }

    case ACTIONS.REMOVE_ITEM:
      return {
        ...state,
        items: state.items.filter(item => item.id !== action.payload.id)
      }

    case ACTIONS.UPDATE_ITEM:
      return {
        ...state,
        items: state.items.map(item =>
          item.id === action.payload.id
            ? { ...item, ...action.payload.updates }
            : item
        )
      }

    case ACTIONS.TOGGLE_ITEM:
      return {
        ...state,
        items: state.items.map(item =>
          item.id === action.payload.id
            ? { ...item, completed: !item.completed }
            : item
        )
      }

    case ACTIONS.CLEAR_ALL:
      return {
        ...state,
        items: []
      }

    case ACTIONS.SET_FILTER:
      return {
        ...state,
        filter: action.payload.filter
      }

    default:
      throw new Error(`Action non gérée: ${action.type}`)
  }
}

function TodoApp() {
  const [state, dispatch] = useReducer(todoReducer, {
    items: [],
    filter: 'all' // all, active, completed
  })

  const addTodo = (text) => {
    dispatch({
      type: ACTIONS.ADD_ITEM,
      payload: { text }
    })
  }

  const toggleTodo = (id) => {
    dispatch({
      type: ACTIONS.TOGGLE_ITEM,
      payload: { id }
    })
  }

  const updateTodo = (id, text) => {
    dispatch({
      type: ACTIONS.UPDATE_ITEM,
      payload: { id, updates: { text } }
    })
  }

  const removeTodo = (id) => {
    dispatch({
      type: ACTIONS.REMOVE_ITEM,
      payload: { id }
    })
  }

  // Computed values (comme des getters)
  const filteredItems = useMemo(() => {
    switch (state.filter) {
      case 'active':
        return state.items.filter(item => !item.completed)
      case 'completed':
        return state.items.filter(item => item.completed)
      default:
        return state.items
    }
  }, [state.items, state.filter])

  const stats = useMemo(() => ({
    total: state.items.length,
    active: state.items.filter(t => !t.completed).length,
    completed: state.items.filter(t => t.completed).length
  }), [state.items])

  return (
    <div>
      <h3>Todo App with useReducer</h3>
      
      <TodoInput onAdd={addTodo} />
      
      <TodoFilters
        currentFilter={state.filter}
        onFilterChange={(filter) => dispatch({
          type: ACTIONS.SET_FILTER,
          payload: { filter }
        })}
        stats={stats}
      />
      
      <TodoList
        items={filteredItems}
        onToggle={toggleTodo}
        onUpdate={updateTodo}
        onRemove={removeTodo}
      />
      
      {stats.total > 0 && (
        <div>
          <button onClick={() => dispatch({ type: ACTIONS.CLEAR_ALL })}>
            🗑️ Tout supprimer
          </button>
        </div>
      )}
    </div>
  )
}
```

---

## Patterns Avancés

### Reducer avec Middleware

```jsx
// Middleware pour logger les actions
function withLogger(reducer) {
  return (state, action) => {
    console.group(`🎬 Action: ${action.type}`)
    console.log('État précédent:', state)
    console.log('Action:', action)
    
    const newState = reducer(state, action)
    
    console.log('Nouvel état:', newState)
    console.groupEnd()
    
    return newState
  }
}

// Middleware pour la validation
function withValidation(reducer, validator) {
  return (state, action) => {
    const newState = reducer(state, action)
    
    if (validator && !validator(newState)) {
      console.error('❌ État invalide:', newState)
      return state // Retourner l'ancien état si invalide
    }
    
    return newState
  }
}

// Validator pour notre todo app
const todoValidator = (state) => {
  return (
    Array.isArray(state.items) &&
    state.items.every(item => 
      typeof item.id !== 'undefined' && 
      typeof item.text === 'string'
    )
  )
}

// Composition des middlewares
const enhancedTodoReducer = withLogger(
  withValidation(todoReducer, todoValidator)
)

function EnhancedTodoApp() {
  const [state, dispatch] = useReducer(enhancedTodoReducer, {
    items: [],
    filter: 'all'
  })

  // Le reste de la logique reste identique
  // Mais maintenant on a du logging et de la validation !
}
```

### useReducer avec Context

```jsx
// Context pour partager l'état et dispatch
const AppContext = createContext()

// Provider qui combine useReducer et Context
function AppProvider({ children }) {
  const [state, dispatch] = useReducer(appReducer, initialState)

  // Actions créateurs pour simplifier l'usage
  const actions = useMemo(() => ({
    addTodo: (text) => dispatch({
      type: 'ADD_TODO',
      payload: { text }
    }),
    
    toggleTodo: (id) => dispatch({
      type: 'TOGGLE_TODO',
      payload: { id }
    }),
    
    setUser: (user) => dispatch({
      type: 'SET_USER',
      payload: { user }
    }),
    
    setTheme: (theme) => dispatch({
      type: 'SET_THEME',
      payload: { theme }
    })
  }), [])

  const value = useMemo(() => ({
    state,
    actions,
    dispatch // Pour les cas avancés
  }), [state, actions])

  return (
    <AppContext.Provider value={value}>
      {children}
    </AppContext.Provider>
  )
}

// Hook custom pour utiliser le context
function useApp() {
  const context = useContext(AppContext)
  if (!context) {
    throw new Error('useApp must be used within AppProvider')
  }
  return context
}

// Reducer global de l'app
function appReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [...state.todos, {
          id: Date.now(),
          text: action.payload.text,
          completed: false
        }]
      }

    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.id
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      }

    case 'SET_USER':
      return {
        ...state,
        user: action.payload.user
      }

    case 'SET_THEME':
      return {
        ...state,
        theme: action.payload.theme
      }

    default:
      return state
  }
}

const initialState = {
  user: null,
  todos: [],
  theme: 'light'
}

// Usage dans les composants
function Header() {
  const { state, actions } = useApp()

  return (
    <header>
      <h1>Hello {state.user?.name || 'Guest'}</h1>
      <button onClick={() => actions.setTheme(
        state.theme === 'light' ? 'dark' : 'light'
      )}>
        {state.theme === 'light' ? '🌙' : '☀️'}
      </button>
    </header>
  )
}

function TodoSection() {
  const { state, actions } = useApp()

  return (
    <div>
      <h2>Todos ({state.todos.length})</h2>
      {state.todos.map(todo => (
        <div key={todo.id}>
          <label>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => actions.toggleTodo(todo.id)}
            />
            {todo.text}
          </label>
        </div>
      ))}
      
      <button onClick={() => actions.addTodo('Nouvelle tâche')}>
        Ajouter Todo
      </button>
    </div>
  )
}

// App principale
function App() {
  return (
    <AppProvider>
      <div>
        <Header />
        <TodoSection />
      </div>
    </AppProvider>
  )
}
```

---

## Cas d'Usage Pratiques

### Formulaire Complexe

```jsx
function formReducer(state, action) {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        values: {
          ...state.values,
          [action.payload.name]: action.payload.value
        },
        errors: {
          ...state.errors,
          [action.payload.name]: null // Clear error on change
        }
      }

    case 'SET_ERRORS':
      return {
        ...state,
        errors: action.payload.errors
      }

    case 'SET_LOADING':
      return {
        ...state,
        loading: action.payload.loading
      }

    case 'RESET_FORM':
      return {
        values: action.payload.initialValues || {},
        errors: {},
        loading: false,
        submitCount: 0
      }

    case 'INCREMENT_SUBMIT':
      return {
        ...state,
        submitCount: state.submitCount + 1
      }

    default:
      return state
  }
}

function UserForm() {
  const [state, dispatch] = useReducer(formReducer, {
    values: {
      name: '',
      email: '',
      age: '',
      bio: ''
    },
    errors: {},
    loading: false,
    submitCount: 0
  })

  const setField = useCallback((name, value) => {
    dispatch({
      type: 'SET_FIELD',
      payload: { name, value }
    })
  }, [])

  const validateForm = () => {
    const errors = {}
    
    if (!state.values.name.trim()) {
      errors.name = 'Le nom est requis'
    }
    
    if (!state.values.email.trim()) {
      errors.email = 'L\'email est requis'
    } else if (!/\S+@\S+\.\S+/.test(state.values.email)) {
      errors.email = 'Email invalide'
    }
    
    if (state.values.age && (state.values.age < 0 || state.values.age > 120)) {
      errors.age = 'Âge invalide'
    }

    return errors
  }

  const handleSubmit = async (e) => {
    e.preventDefault()
    
    dispatch({ type: 'INCREMENT_SUBMIT' })
    
    const errors = validateForm()
    
    if (Object.keys(errors).length > 0) {
      dispatch({ type: 'SET_ERRORS', payload: { errors } })
      return
    }

    dispatch({ type: 'SET_LOADING', payload: { loading: true } })

    try {
      // Simulation d'une API call
      await new Promise(resolve => setTimeout(resolve, 2000))
      
      console.log('Form submitted:', state.values)
      alert('Formulaire envoyé avec succès !')
      
      dispatch({ type: 'RESET_FORM' })
    } catch (error) {
      dispatch({
        type: 'SET_ERRORS',
        payload: { errors: { _general: 'Erreur lors de l\'envoi' } }
      })
    } finally {
      dispatch({ type: 'SET_LOADING', payload: { loading: false } })
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <h3>Formulaire Utilisateur</h3>
      
      {state.errors._general && (
        <div style={{ color: 'red', marginBottom: '10px' }}>
          {state.errors._general}
        </div>
      )}

      <div>
        <label>
          Nom *
          <input
            type="text"
            value={state.values.name}
            onChange={e => setField('name', e.target.value)}
            style={{ borderColor: state.errors.name ? 'red' : 'initial' }}
          />
        </label>
        {state.errors.name && <span style={{ color: 'red' }}>{state.errors.name}</span>}
      </div>

      <div>
        <label>
          Email *
          <input
            type="email"
            value={state.values.email}
            onChange={e => setField('email', e.target.value)}
            style={{ borderColor: state.errors.email ? 'red' : 'initial' }}
          />
        </label>
        {state.errors.email && <span style={{ color: 'red' }}>{state.errors.email}</span>}
      </div>

      <div>
        <label>
          Âge
          <input
            type="number"
            value={state.values.age}
            onChange={e => setField('age', Number(e.target.value))}
            style={{ borderColor: state.errors.age ? 'red' : 'initial' }}
          />
        </label>
        {state.errors.age && <span style={{ color: 'red' }}>{state.errors.age}</span>}
      </div>

      <div>
        <label>
          Bio
          <textarea
            value={state.values.bio}
            onChange={e => setField('bio', e.target.value)}
            rows={4}
          />
        </label>
      </div>

      <button type="submit" disabled={state.loading}>
        {state.loading ? 'Envoi...' : 'Envoyer'}
      </button>

      <p>Tentatives d'envoi: {state.submitCount}</p>
    </form>
  )
}
```

### Shopping Cart

```jsx
function cartReducer(state, action) {
  switch (action.type) {
    case 'ADD_ITEM':
      const existingItem = state.items.find(item => item.id === action.payload.id)
      
      if (existingItem) {
        return {
          ...state,
          items: state.items.map(item =>
            item.id === action.payload.id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          )
        }
      }
      
      return {
        ...state,
        items: [...state.items, { ...action.payload, quantity: 1 }]
      }

    case 'REMOVE_ITEM':
      return {
        ...state,
        items: state.items.filter(item => item.id !== action.payload.id)
      }

    case 'UPDATE_QUANTITY':
      if (action.payload.quantity <= 0) {
        return {
          ...state,
          items: state.items.filter(item => item.id !== action.payload.id)
        }
      }
      
      return {
        ...state,
        items: state.items.map(item =>
          item.id === action.payload.id
            ? { ...item, quantity: action.payload.quantity }
            : item
        )
      }

    case 'CLEAR_CART':
      return { ...state, items: [] }

    case 'APPLY_DISCOUNT':
      return {
        ...state,
        discount: action.payload.discount
      }

    case 'SET_SHIPPING':
      return {
        ...state,
        shipping: action.payload.shipping
      }

    default:
      return state
  }
}

function ShoppingCart() {
  const [state, dispatch] = useReducer(cartReducer, {
    items: [],
    discount: 0,
    shipping: 0
  })

  // Calculs dérivés
  const subtotal = state.items.reduce((sum, item) => sum + (item.price * item.quantity), 0)
  const discountAmount = subtotal * (state.discount / 100)
  const total = subtotal - discountAmount + state.shipping

  const addItem = (product) => {
    dispatch({ type: 'ADD_ITEM', payload: product })
  }

  const updateQuantity = (id, quantity) => {
    dispatch({ type: 'UPDATE_QUANTITY', payload: { id, quantity } })
  }

  const removeItem = (id) => {
    dispatch({ type: 'REMOVE_ITEM', payload: { id } })
  }

  const applyDiscount = (percent) => {
    dispatch({ type: 'APPLY_DISCOUNT', payload: { discount: percent } })
  }

  // Produits disponibles
  const availableProducts = [
    { id: 1, name: 'MacBook Pro', price: 2499 },
    { id: 2, name: 'iPhone', price: 999 },
    { id: 3, name: 'AirPods', price: 199 }
  ]

  return (
    <div>
      <h3>Shopping Cart</h3>
      
      {/* Produits disponibles */}
      <div>
        <h4>Produits</h4>
        {availableProducts.map(product => (
          <div key={product.id} style={{ marginBottom: '10px' }}>
            <span>{product.name} - {product.price}€</span>
            <button onClick={() => addItem(product)} style={{ marginLeft: '10px' }}>
              Ajouter au panier
            </button>
          </div>
        ))}
      </div>

      {/* Panier */}
      <div>
        <h4>Panier ({state.items.length} articles)</h4>
        
        {state.items.length === 0 ? (
          <p>Panier vide</p>
        ) : (
          <>
            {state.items.map(item => (
              <div key={item.id} style={{ 
                display: 'flex', 
                justifyContent: 'space-between', 
                alignItems: 'center',
                marginBottom: '10px',
                padding: '10px',
                border: '1px solid #ddd'
              }}>
                <span>{item.name}</span>
                <div>
                  <button onClick={() => updateQuantity(item.id, item.quantity - 1)}>
                    -
                  </button>
                  <span style={{ margin: '0 10px' }}>{item.quantity}</span>
                  <button onClick={() => updateQuantity(item.id, item.quantity + 1)}>
                    +
                  </button>
                  <span style={{ marginLeft: '10px' }}>
                    {(item.price * item.quantity).toFixed(2)}€
                  </span>
                  <button 
                    onClick={() => removeItem(item.id)}
                    style={{ marginLeft: '10px', color: 'red' }}
                  >
                    ❌
                  </button>
                </div>
              </div>
            ))}

            {/* Résumé */}
            <div style={{ marginTop: '20px', padding: '10px', background: '#f8f9fa' }}>
              <p>Sous-total: {subtotal.toFixed(2)}€</p>
              {state.discount > 0 && (
                <p>Réduction ({state.discount}%): -{discountAmount.toFixed(2)}€</p>
              )}
              <p>Frais de port: {state.shipping.toFixed(2)}€</p>
              <h4>Total: {total.toFixed(2)}€</h4>
            </div>

            {/* Actions */}
            <div style={{ marginTop: '10px' }}>
              <button onClick={() => applyDiscount(10)}>
                Appliquer -10%
              </button>
              <button onClick={() => dispatch({ type: 'SET_SHIPPING', payload: { shipping: 9.99 } })}>
                Ajouter livraison (9.99€)
              </button>
              <button onClick={() => dispatch({ type: 'CLEAR_CART' })}>
                Vider le panier
              </button>
            </div>
          </>
        )}
      </div>
    </div>
  )
}
```

---

## Points Clés à Retenir

1. **useReducer** = useState mais pour des états complexes
2. **Actions** = objets avec `type` et optionnel `payload`
3. **Reducer** = fonction pure `(state, action) => newState`
4. **Immutabilité** = toujours retourner un nouvel objet/array
5. **Centralisation** = toute la logique d'état en un endroit
6. **Prévisibilité** = plus facile à tester et débugger
7. **Composition** = peut s'utiliser avec Context pour un "mini-Redux"

---

## useState vs useReducer

### Quand utiliser useState ?

- ✅ État simple (string, number, boolean)
- ✅ Logique simple
- ✅ Pas de transitions d'état complexes
- ✅ Composant petit/moyen

### Quand utiliser useReducer ?

- ✅ État complexe (objets imbriqués, arrays)
- ✅ Plusieurs sous-valeurs liées
- ✅ Logique de transition complexe
- ✅ Besoin de prévisibilité
- ✅ États avec historique/undo
- ✅ Formulaires complexes

---

## Erreurs Communes

### 1. Muter l'État

```jsx
// ❌ MAUVAIS - Mutation directe
function badReducer(state, action) {
  switch (action.type) {
    case 'ADD_ITEM':
      state.items.push(action.payload) // ❌ Mutation !
      return state
  }
}

// ✅ BON - Immutabilité
function goodReducer(state, action) {
  switch (action.type) {
    case 'ADD_ITEM':
      return {
        ...state,
        items: [...state.items, action.payload] // ✅ Nouveau array
      }
  }
}
```

### 2. Oublier le Default Case

```jsx
// ❌ MAUVAIS - Pas de default
function badReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 }
    // ❌ Pas de default !
  }
}

// ✅ BON - Avec default
function goodReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 }
    default:
      throw new Error(`Action inconnue: ${action.type}`)
  }
}
```

### 3. Actions sans Type

```jsx
// ❌ MAUVAIS - Action malformée
dispatch('INCREMENT') // ❌ Pas un objet !
dispatch({ payload: 42 }) // ❌ Pas de type !

// ✅ BON - Action bien formée
dispatch({ type: 'INCREMENT' })
dispatch({ type: 'SET_VALUE', payload: 42 })
```

---

## Ressources Pour Aller Plus Loin

- 📚 [useReducer Documentation](https://react.dev/reference/react/useReducer)
- 🎯 [Extracting State Logic into a Reducer](https://react.dev/learn/extracting-state-logic-into-a-reducer)
- 💡 [useState vs useReducer](https://kentcdodds.com/blog/should-i-usestate-or-usereducer)
- 🔄 [Reducer Pattern](https://react.dev/learn/managing-state)

---

```jsx
import React, { useReducer } from 'react';

// 1. Le Reducer
function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

function Counter() {
  // 3. L'appel du Hook
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <p>Compte : {state.count}</p>
      {/* 2. On "dispatch" des actions */}
      <button onClick={() => dispatch({ type: 'increment' })}>Incrémenter</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>Décrémenter</button>
    </div>
  );
}
```
