# React - useEffect : Effets de Bord

**useEffect** = Le hook des **effets de bord** ! ğŸ”„

C'est lui qui va te permettre d'exÃ©cuter du code quand ton composant **se monte**, **se met Ã  jour** ou **se dÃ©monte**. API calls, timers, subscriptions... tout se passe ici !

---

## Comprendre useEffect

### Qu'est-ce qu'un "Effet de Bord" ?

Un effet de bord, c'est **toute action** qui sort du cadre du rendu pur :

- ğŸŒ **API calls** : fetch des donnÃ©es
- â° **Timers** : setTimeout, setInterval
- ğŸ”Œ **Subscriptions** : websockets, event listeners
- ğŸ’¾ **localStorage** : sauvegarder des donnÃ©es
- ğŸ“Š **Analytics** : tracking d'Ã©vÃ©nements
- ğŸ¯ **DOM manipulation** : focus, scroll

### Cycle de Vie SimplifiÃ©

```jsx
import { useState, useEffect } from 'react'

function LifecycleWithUseEffect() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')

  // ğŸ¬ Ã‰quivalent componentDidMount + componentDidUpdate
  useEffect(() => {
    console.log('ğŸ”„ Composant montÃ© OU mis Ã  jour')
    document.title = `Count: ${count}`
  }) // â† Pas de tableau = Ã  chaque rendu !

  // ğŸ¬ Ã‰quivalent componentDidMount seulement
  useEffect(() => {
    console.log('ğŸ¬ Composant montÃ© (UNE SEULE FOIS)')
    
    // ğŸ’€ Cleanup = componentWillUnmount
    return () => {
      console.log('ğŸ’€ Cleanup avant dÃ©montage')
    }
  }, []) // â† Tableau vide = une seule fois !

  // ğŸ¯ Effet spÃ©cifique Ã  count
  useEffect(() => {
    console.log('ğŸ“Š Count a changÃ©:', count)
    
    if (count > 10) {
      alert('Count dÃ©passe 10 !')
    }
  }, [count]) // â† Se dÃ©clenche quand count change !

  // ğŸ‘¤ Effet spÃ©cifique Ã  name
  useEffect(() => {
    console.log('ğŸ‘¤ Name a changÃ©:', name)
    
    if (name.length > 0) {
      localStorage.setItem('userName', name)
    }
  }, [name]) // â† Se dÃ©clenche quand name change !

  return (
    <div>
      <h3>Count: {count}</h3>
      <button onClick={() => setCount(count + 1)}>+1</button>

      <input
        value={name}
        onChange={e => setName(e.target.value)}
        placeholder="Votre nom..."
      />
    </div>
  )
}
```

---

## Patterns Courants avec useEffect

### 1. Fetch de DonnÃ©es

```jsx
function DataFetching({ userId }) {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  useEffect(() => {
    // Fonction async Ã  l'intÃ©rieur de useEffect
    const fetchData = async () => {
      try {
        setLoading(true)
        setError(null)
        
        const response = await fetch(`/api/users/${userId}`)
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`)
        }
        
        const result = await response.json()
        setData(result)
      } catch (err) {
        setError(err.message)
        setData(null)
      } finally {
        setLoading(false)
      }
    }

    // Appel de la fonction
    fetchData()
  }, [userId]) // â† Re-fetch si userId change !

  // Gestion des Ã©tats
  if (loading) return <div>Chargement...</div>
  if (error) return <div>Erreur: {error}</div>
  if (!data) return <div>Aucune donnÃ©e</div>

  return (
    <div>
      <h3>Utilisateur: {data.name}</h3>
      <p>Email: {data.email}</p>
      <p>ID: {data.id}</p>
    </div>
  )
}

// Utilisation
function App() {
  const [selectedUserId, setSelectedUserId] = useState(1)

  return (
    <div>
      <div>
        <button onClick={() => setSelectedUserId(1)}>User 1</button>
        <button onClick={() => setSelectedUserId(2)}>User 2</button>
        <button onClick={() => setSelectedUserId(3)}>User 3</button>
      </div>
      
      <DataFetching userId={selectedUserId} />
    </div>
  )
}
```

### 2. Timers et Intervalles

```jsx
function TimersExample() {
  const [seconds, setSeconds] = useState(0)
  const [isRunning, setIsRunning] = useState(false)
  const [countdown, setCountdown] = useState(10)

  // ChronomÃ¨tre
  useEffect(() => {
    let interval = null
    
    if (isRunning) {
      interval = setInterval(() => {
        setSeconds(prevSeconds => prevSeconds + 1)
      }, 1000)
    }

    // âš ï¸ Cleanup CRUCIAL pour Ã©viter les fuites mÃ©moire
    return () => {
      if (interval) {
        clearInterval(interval)
        console.log('ğŸ§¹ Timer nettoyÃ©')
      }
    }
  }, [isRunning])

  // Countdown avec auto-stop
  useEffect(() => {
    if (countdown > 0) {
      const timer = setTimeout(() => {
        setCountdown(prev => prev - 1)
      }, 1000)

      // Cleanup du timeout
      return () => clearTimeout(timer)
    } else if (countdown === 0) {
      alert('ğŸš¨ Temps Ã©coulÃ© !')
    }
  }, [countdown])

  // Notification pÃ©riodique
  useEffect(() => {
    const notificationInterval = setInterval(() => {
      console.log(`ğŸ’¡ App en cours depuis ${seconds} secondes`)
    }, 30000) // Toutes les 30 secondes

    return () => clearInterval(notificationInterval)
  }, [seconds])

  const formatTime = (totalSeconds) => {
    const mins = Math.floor(totalSeconds / 60)
    const secs = totalSeconds % 60
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
  }

  return (
    <div>
      <h3>ChronomÃ¨tre: {formatTime(seconds)}</h3>
      <div>
        <button onClick={() => setIsRunning(!isRunning)}>
          {isRunning ? 'â¸ï¸ Pause' : 'â–¶ï¸ Start'}
        </button>
        <button onClick={() => {
          setSeconds(0)
          setIsRunning(false)
        }}>
          ğŸ”„ Reset
        </button>
      </div>

      <h3>Countdown: {countdown}s</h3>
      <button onClick={() => setCountdown(10)}>
        Reset Countdown
      </button>
    </div>
  )
}
```

### 3. Event Listeners

```jsx
function EventListenersExample() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  })
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })
  const [keyPressed, setKeyPressed] = useState('')
  const [isOnline, setIsOnline] = useState(navigator.onLine)

  // Resize listener
  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      })
    }

    window.addEventListener('resize', handleResize)
    
    // âš ï¸ Cleanup obligatoire !
    return () => {
      window.removeEventListener('resize', handleResize)
    }
  }, [])

  // Mouse listener
  useEffect(() => {
    const handleMouseMove = (event) => {
      setMousePosition({
        x: event.clientX,
        y: event.clientY
      })
    }

    document.addEventListener('mousemove', handleMouseMove)
    
    return () => {
      document.removeEventListener('mousemove', handleMouseMove)
    }
  }, [])

  // Keyboard listener
  useEffect(() => {
    const handleKeyPress = (event) => {
      setKeyPressed(event.key)
      // Clear aprÃ¨s 2 secondes
      setTimeout(() => setKeyPressed(''), 2000)
    }

    window.addEventListener('keydown', handleKeyPress)
    
    return () => {
      window.removeEventListener('keydown', handleKeyPress)
    }
  }, [])

  // Online/Offline listener
  useEffect(() => {
    const handleOnline = () => setIsOnline(true)
    const handleOffline = () => setIsOnline(false)

    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)
    
    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])

  return (
    <div>
      <h3>Event Listeners Demo</h3>
      
      <div>
        <p>ğŸ“ Taille fenÃªtre: {windowSize.width}x{windowSize.height}</p>
        <p>ğŸ–±ï¸ Position souris: ({mousePosition.x}, {mousePosition.y})</p>
        <p>âŒ¨ï¸ DerniÃ¨re touche: {keyPressed || 'Aucune'}</p>
        <p>ğŸŒ Connexion: {isOnline ? 'âœ… En ligne' : 'âŒ Hors ligne'}</p>
      </div>
    </div>
  )
}
```

### 4. WebSocket et Subscriptions

```jsx
function WebSocketExample({ roomId }) {
  const [messages, setMessages] = useState([])
  const [isConnected, setIsConnected] = useState(false)
  const [newMessage, setNewMessage] = useState('')

  useEffect(() => {
    // CrÃ©er la connexion WebSocket
    const ws = new WebSocket(`ws://localhost:8080/room/${roomId}`)
    
    ws.onopen = () => {
      console.log('ğŸ”Œ WebSocket connectÃ©')
      setIsConnected(true)
    }
    
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data)
      console.log('ğŸ“§ Message reÃ§u:', message)
      
      setMessages(prevMessages => [
        ...prevMessages,
        {
          id: Date.now(),
          ...message,
          timestamp: new Date().toLocaleTimeString()
        }
      ])
    }
    
    ws.onerror = (error) => {
      console.error('âŒ Erreur WebSocket:', error)
    }
    
    ws.onclose = () => {
      console.log('ğŸ”Œ WebSocket fermÃ©')
      setIsConnected(false)
    }

    // âš ï¸ Cleanup ESSENTIEL !
    return () => {
      console.log('ğŸ§¹ Fermeture WebSocket')
      ws.close()
    }
  }, [roomId]) // â† Reconnect si roomId change !

  const sendMessage = () => {
    if (newMessage.trim() && isConnected) {
      const ws = new WebSocket(`ws://localhost:8080/room/${roomId}`)
      ws.send(JSON.stringify({
        type: 'message',
        content: newMessage,
        user: 'User123'
      }))
      setNewMessage('')
    }
  }

  return (
    <div>
      <h3>Chat Room: {roomId}</h3>
      <p>Ã‰tat: {isConnected ? 'ğŸŸ¢ ConnectÃ©' : 'ğŸ”´ DÃ©connectÃ©'}</p>
      
      <div style={{ 
        height: '200px', 
        overflow: 'auto', 
        border: '1px solid #ccc', 
        padding: '10px' 
      }}>
        {messages.map(message => (
          <div key={message.id}>
            <strong>[{message.timestamp}] {message.user}:</strong> {message.content}
          </div>
        ))}
      </div>

      <div>
        <input
          value={newMessage}
          onChange={e => setNewMessage(e.target.value)}
          onKeyDown={e => e.key === 'Enter' && sendMessage()}
          placeholder="Tapez votre message..."
          disabled={!isConnected}
        />
        <button onClick={sendMessage} disabled={!isConnected}>
          Envoyer
        </button>
      </div>
    </div>
  )
}
```

---

## DÃ©pendances et Optimisations

### Le Tableau des DÃ©pendances

```jsx
function DependenciesExample({ userId, filter }) {
  const [userData, setUserData] = useState(null)
  const [posts, setPosts] = useState([])

  // âŒ MAUVAIS - DÃ©pendances manquantes
  useEffect(() => {
    fetchUser(userId).then(setUserData) // userId utilisÃ© mais pas dans les deps !
  }, []) // â† ESLint va crier ! ğŸš¨

  // âœ… BON - Toutes les dÃ©pendances
  useEffect(() => {
    fetchUser(userId).then(setUserData)
  }, [userId]) // â† userId dans les dÃ©pendances âœ…

  // âŒ PROBLÃˆME - Objet recrÃ©Ã© Ã  chaque rendu
  useEffect(() => {
    const options = { filter, sort: 'date' } // â† Nouvel objet Ã  chaque fois !
    fetchPosts(userId, options).then(setPosts)
  }, [userId, options]) // â† `options` change toujours ! ğŸ’¥

  // âœ… SOLUTION 1 - DÃ©pendances primitives
  useEffect(() => {
    const options = { filter, sort: 'date' }
    fetchPosts(userId, options).then(setPosts)
  }, [userId, filter]) // â† Seulement les valeurs primitives âœ…

  // âœ… SOLUTION 2 - CrÃ©er l'objet dans l'effet
  useEffect(() => {
    const fetchData = async () => {
      const options = { filter, sort: 'date' }
      const data = await fetchPosts(userId, options)
      setPosts(data)
    }

    fetchData()
  }, [userId, filter]) // â† Clean et optimisÃ© âœ…

  return (
    <div>
      {userData && <h2>{userData.name}</h2>}
      <ul>
        {posts.map(post => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  )
}
```

### Ã‰viter les Re-renders Inutiles

```jsx
function OptimizedEffects() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')
  const [theme, setTheme] = useState('light')

  // âŒ MAUVAIS - Effect qui run trop souvent
  useEffect(() => {
    console.log('ğŸ˜± Cet effet run Ã  CHAQUE rendu !')
    // Pas de tableau de dÃ©pendances
  })

  // âŒ MAUVAIS - DÃ©pendances inutiles
  useEffect(() => {
    console.log('ğŸ“Š Count mis Ã  jour:', count)
  }, [count, name, theme]) // â† name et theme pas nÃ©cessaires !

  // âœ… BON - Seulement les dÃ©pendances nÃ©cessaires
  useEffect(() => {
    console.log('ğŸ“Š Count mis Ã  jour:', count)
  }, [count]) // â† Seulement count âœ…

  // âœ… BON - Effects sÃ©parÃ©s pour des responsabilitÃ©s diffÃ©rentes
  useEffect(() => {
    document.title = `Count: ${count}`
  }, [count])

  useEffect(() => {
    localStorage.setItem('userName', name)
  }, [name])

  useEffect(() => {
    document.body.className = theme
  }, [theme])

  return (
    <div>
      <input
        value={name}
        onChange={e => setName(e.target.value)}
        placeholder="Nom"
      />
      <button onClick={() => setCount(c => c + 1)}>
        Count: {count}
      </button>
      <button onClick={() => setTheme(t => t === 'light' ? 'dark' : 'light')}>
        ThÃ¨me: {theme}
      </button>
    </div>
  )
}
```

### Cancel Previous Requests (Race Conditions)

```jsx
function SearchWithCancel() {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState([])
  const [isLoading, setIsLoading] = useState(false)

  useEffect(() => {
    if (!query.trim()) {
      setResults([])
      return
    }

    // AbortController pour annuler la requÃªte prÃ©cÃ©dente
    const abortController = new AbortController()
    
    const searchData = async () => {
      setIsLoading(true)
      
      try {
        const response = await fetch(`/api/search?q=${encodeURIComponent(query)}`, {
          signal: abortController.signal // â† Signal d'abort
        })
        
        if (!response.ok) throw new Error('Search failed')
        
        const data = await response.json()
        
        // âœ… VÃ©rifier si la requÃªte n'a pas Ã©tÃ© annulÃ©e
        if (!abortController.signal.aborted) {
          setResults(data.results)
        }
      } catch (error) {
        // âœ… Ignorer les erreurs d'abort
        if (error.name !== 'AbortError') {
          console.error('Search error:', error)
          setResults([])
        }
      } finally {
        // âœ… VÃ©rifier avant de mettre Ã  jour l'Ã©tat
        if (!abortController.signal.aborted) {
          setIsLoading(false)
        }
      }
    }

    // DÃ©bounce de 300ms
    const debounceTimer = setTimeout(searchData, 300)

    // âš ï¸ Cleanup : annuler requÃªte ET timer
    return () => {
      clearTimeout(debounceTimer)
      abortController.abort()
    }
  }, [query])

  return (
    <div>
      <h3>Recherche avec Cancel</h3>
      
      <input
        value={query}
        onChange={e => setQuery(e.target.value)}
        placeholder="Rechercher..."
      />
      
      {isLoading && <p>ğŸ” Recherche en cours...</p>}
      
      <ul>
        {results.map((result, index) => (
          <li key={index}>{result.title}</li>
        ))}
      </ul>
    </div>
  )
}
```

---

## Custom Hooks avec useEffect

### useApi Hook

```jsx
function useApi(url, options = {}) {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  const fetchData = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)

      const response = await fetch(url, {
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        },
        ...options
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const result = await response.json()
      setData(result)
    } catch (err) {
      setError(err.message)
    } finally {
      setLoading(false)
    }
  }, [url, options])

  useEffect(() => {
    fetchData()
  }, [fetchData])

  const refetch = useCallback(() => {
    fetchData()
  }, [fetchData])

  return { data, loading, error, refetch }
}

// Utilisation
function UserProfile({ userId }) {
  const { data: user, loading, error, refetch } = useApi(`/api/users/${userId}`)

  if (loading) return <div>Chargement...</div>
  if (error) return <div>Erreur: {error} <button onClick={refetch}>Retry</button></div>

  return (
    <div>
      <h3>{user?.name}</h3>
      <p>{user?.email}</p>
      <button onClick={refetch}>ğŸ”„ RafraÃ®chir</button>
    </div>
  )
}
```

### useInterval Hook

```jsx
function useInterval(callback, delay) {
  const savedCallback = useRef()

  // Se souvenir du callback le plus rÃ©cent
  useEffect(() => {
    savedCallback.current = callback
  }, [callback])

  // Configurer l'interval
  useEffect(() => {
    if (delay !== null) {
      const interval = setInterval(() => savedCallback.current(), delay)
      return () => clearInterval(interval)
    }
  }, [delay])
}

// Utilisation
function IntervalExample() {
  const [count, setCount] = useState(0)
  const [isRunning, setIsRunning] = useState(true)

  useInterval(
    () => setCount(count => count + 1),
    isRunning ? 1000 : null // â† null = pause l'interval
  )

  return (
    <div>
      <h3>Count: {count}</h3>
      <button onClick={() => setIsRunning(!isRunning)}>
        {isRunning ? 'Pause' : 'Start'}
      </button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  )
}
```

### useLocalStorage Hook

```jsx
function useLocalStorage(key, initialValue) {
  // State pour stocker notre valeur
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error)
      return initialValue
    }
  })

  // Fonction pour sauvegarder en localStorage ET mettre Ã  jour l'Ã©tat
  const setValue = (value) => {
    try {
      setStoredValue(value)
      window.localStorage.setItem(key, JSON.stringify(value))
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error)
    }
  }

  // Ã‰couter les changements de localStorage depuis d'autres onglets
  useEffect(() => {
    const handleStorageChange = (e) => {
      if (e.key === key && e.newValue !== null) {
        try {
          setStoredValue(JSON.parse(e.newValue))
        } catch (error) {
          console.error(`Error parsing localStorage key "${key}":`, error)
        }
      }
    }

    window.addEventListener('storage', handleStorageChange)
    return () => window.removeEventListener('storage', handleStorageChange)
  }, [key])

  return [storedValue, setValue]
}

// Utilisation
function SettingsPanel() {
  const [theme, setTheme] = useLocalStorage('theme', 'light')
  const [name, setName] = useLocalStorage('userName', '')

  return (
    <div>
      <h3>ParamÃ¨tres Persistants</h3>
      
      <div>
        <label>
          Nom:
          <input
            value={name}
            onChange={e => setName(e.target.value)}
          />
        </label>
      </div>

      <div>
        <label>
          <input
            type="checkbox"
            checked={theme === 'dark'}
            onChange={e => setTheme(e.target.checked ? 'dark' : 'light')}
          />
          Mode sombre
        </label>
      </div>

      <p>ThÃ¨me actuel: {theme}</p>
      <p>Nom sauvegardÃ©: {name}</p>
    </div>
  )
}
```

---

## Erreurs Communes Ã  Ã‰viter

### 1. Async dans useEffect

```jsx
// âŒ MAUVAIS - useEffect async directement
useEffect(async () => {
  const data = await fetch('/api/data')
  setData(data)
}, [])

// âœ… BON - Fonction async Ã  l'intÃ©rieur
useEffect(() => {
  const fetchData = async () => {
    const data = await fetch('/api/data')
    setData(data)
  }
  
  fetchData()
}, [])
```

### 2. Oublier le Cleanup

```jsx
// âŒ MAUVAIS - Pas de cleanup
useEffect(() => {
  const timer = setInterval(() => {
    console.log('Timer tick')
  }, 1000)
  // âŒ Fuite mÃ©moire garantie !
}, [])

// âœ… BON - Avec cleanup
useEffect(() => {
  const timer = setInterval(() => {
    console.log('Timer tick')
  }, 1000)
  
  return () => clearInterval(timer) // âœ… Cleanup
}, [])
```

### 3. Infinite Loop

```jsx
// âŒ MAUVAIS - Boucle infinie
const [user, setUser] = useState({})

useEffect(() => {
  setUser({ ...user, lastUpdated: Date.now() })
}, [user]) // âŒ user change Ã  chaque fois !

// âœ… BON - Condition ou dÃ©pendances correctes
useEffect(() => {
  if (!user.lastUpdated) {
    setUser(prev => ({ ...prev, lastUpdated: Date.now() }))
  }
}, [user.lastUpdated])
```

---

## Points ClÃ©s Ã  Retenir

1. **useEffect** = hook pour les effets de bord
2. **Tableau vide []** = une seule fois (componentDidMount)
3. **Pas de tableau** = Ã  chaque rendu (dangereux !)
4. **DÃ©pendances** = variables utilisÃ©es dans l'effet
5. **Cleanup function** = return dans useEffect (essentiel !)
6. **Async/await** = fonction interne, pas directement dans useEffect
7. **Race conditions** = utiliser AbortController
8. **Custom hooks** = rÃ©utiliser la logique d'effets

---

## Ressources Pour Aller Plus Loin

- ğŸ“š [useEffect Documentation](https://react.dev/reference/react/useEffect)
- ğŸ¯ [useEffect Complete Guide](https://overreacted.io/a-complete-guide-to-useeffect/)
- ğŸ’¡ [Common useEffect Mistakes](https://react.dev/learn/synchronizing-with-effects)
- ğŸ”„ [Effect Dependencies](https://react.dev/learn/removing-effect-dependencies)

