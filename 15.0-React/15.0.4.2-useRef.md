# React - useRef : R√©f√©rences et Valeurs Mutables

Il te permet d'acc√©der directement au **DOM** ou de **stocker des valeurs mutables** qui ne d√©clenchent pas de re-render. C'est ton couteau suisse pour sortir du paradigme React quand n√©cessaire !

---

## Qu'est-ce que useRef ?

### Les Deux Usages Principaux

1. **üéØ R√©f√©rences DOM** : Acc√©der directement aux √©l√©ments HTML
2. **üíæ Valeurs mutables** : Stocker des donn√©es qui ne causent pas de re-render

### Diff√©rence avec useState

```jsx
import { useState, useRef, useEffect } from 'react'

function StateVsRef() {
  const [stateCount, setStateCount] = useState(0)
  const refCount = useRef(0)
  const renderCount = useRef(0)

  // Compter les renders
  renderCount.current++

  const incrementState = () => {
    setStateCount(prev => prev + 1) // ‚úÖ D√©clenche un re-render
  }

  const incrementRef = () => {
    refCount.current++ // ‚úÖ PAS de re-render !
    console.log('Ref count:', refCount.current)
  }

  return (
    <div>
      <h3>State vs Ref</h3>
      <p>Nombre de renders: {renderCount.current}</p>
      <p>State count: {stateCount} (d√©clenche re-render)</p>
      <p>Ref count: {refCount.current} (PAS de re-render)</p>
      
      <button onClick={incrementState}>
        Increment State (re-render)
      </button>
      <button onClick={incrementRef}>
        Increment Ref (pas de re-render)
      </button>
    </div>
  )
}
```

---

## useRef pour le DOM

### Acc√®s aux √âl√©ments HTML

```jsx
function DomReferences() {
  const inputRef = useRef(null)
  const textAreaRef = useRef(null)
  const fileInputRef = useRef(null)
  const videoRef = useRef(null)

  const focusInput = () => {
    inputRef.current.focus()
  }

  const clearTextArea = () => {
    textAreaRef.current.value = ''
    textAreaRef.current.focus()
  }

  const triggerFileSelect = () => {
    fileInputRef.current.click()
  }

  const playVideo = () => {
    videoRef.current.play()
  }

  const pauseVideo = () => {
    videoRef.current.pause()
  }

  const handleFileChange = (e) => {
    const file = e.target.files[0]
    if (file) {
      console.log('Fichier s√©lectionn√©:', file.name)
    }
  }

  return (
    <div>
      <h3>R√©f√©rences DOM</h3>
      
      <div>
        <h4>Input avec focus</h4>
        <input 
          ref={inputRef} 
          placeholder="Clique le bouton pour me focus" 
        />
        <button onClick={focusInput}>Focus Input</button>
      </div>

      <div>
        <h4>TextArea avec clear</h4>
        <textarea 
          ref={textAreaRef}
          placeholder="√âcris quelque chose..."
          rows={3}
        />
        <br />
        <button onClick={clearTextArea}>Clear & Focus</button>
      </div>

      <div>
        <h4>File Input cach√©</h4>
        <input 
          ref={fileInputRef}
          type="file"
          style={{ display: 'none' }}
          onChange={handleFileChange}
        />
        <button onClick={triggerFileSelect}>üìÅ S√©lectionner fichier</button>
      </div>

      <div>
        <h4>Contr√¥le vid√©o</h4>
        <video 
          ref={videoRef}
          width="300"
          controls
        >
          <source src="https://www.w3schools.com/html/mov_bbb.mp4" type="video/mp4" />
        </video>
        <br />
        <button onClick={playVideo}>‚ñ∂Ô∏è Play</button>
        <button onClick={pauseVideo}>‚è∏Ô∏è Pause</button>
      </div>
    </div>
  )
}
```

### Mesurer des √âl√©ments

```jsx
function ElementMeasurement() {
  const boxRef = useRef(null)
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 })
  const [position, setPosition] = useState({ x: 0, y: 0 })

  const measureBox = () => {
    if (boxRef.current) {
      const rect = boxRef.current.getBoundingClientRect()
      
      setDimensions({
        width: rect.width,
        height: rect.height
      })
      
      setPosition({
        x: rect.left,
        y: rect.top
      })

      console.log('Mesures compl√®tes:', {
        dimensions: { width: rect.width, height: rect.height },
        position: { x: rect.left, y: rect.top },
        scroll: { 
          scrollWidth: boxRef.current.scrollWidth,
          scrollHeight: boxRef.current.scrollHeight
        }
      })
    }
  }

  const scrollToBottom = () => {
    if (boxRef.current) {
      boxRef.current.scrollTop = boxRef.current.scrollHeight
    }
  }

  const scrollToTop = () => {
    if (boxRef.current) {
      boxRef.current.scrollTop = 0
    }
  }

  // Mesurer automatiquement au resize
  useEffect(() => {
    const handleResize = () => measureBox()
    window.addEventListener('resize', handleResize)
    return () => window.removeEventListener('resize', handleResize)
  }, [])

  return (
    <div>
      <h3>Mesure d'√âl√©ments</h3>
      
      <div 
        ref={boxRef}
        style={{
          width: '300px',
          height: '200px',
          border: '2px solid #007bff',
          padding: '20px',
          overflow: 'auto',
          resize: 'both',
          background: 'linear-gradient(45deg, #f0f0f0, #e0e0e0)'
        }}
      >
        <p>Cette bo√Æte est redimensionnable !</p>
        <p>Tire le coin en bas √† droite pour la redimensionner.</p>
        <p>Contenu qui d√©passe...</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>
        <p>Plus de contenu pour tester le scroll...</p>
        <p>Encore plus de contenu...</p>
        <p>Et encore...</p>
        <p>Fin du contenu !</p>
      </div>

      <div style={{ marginTop: '10px' }}>
        <button onClick={measureBox}>üìê Mesurer</button>
        <button onClick={scrollToTop}>‚¨ÜÔ∏è Scroll Top</button>
        <button onClick={scrollToBottom}>‚¨áÔ∏è Scroll Bottom</button>
      </div>

      <div style={{ marginTop: '10px' }}>
        <p>Largeur: {dimensions.width}px</p>
        <p>Hauteur: {dimensions.height}px</p>
        <p>Position X: {position.x}px</p>
        <p>Position Y: {position.y}px</p>
      </div>
    </div>
  )
}
```

### Canvas et Dessins

```jsx
function CanvasDrawing() {
  const canvasRef = useRef(null)
  const [isDrawing, setIsDrawing] = useState(false)
  const [color, setColor] = useState('#000000')
  const [brushSize, setBrushSize] = useState(5)

  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext('2d')
    
    // Configuration initiale
    ctx.lineCap = 'round'
    ctx.lineJoin = 'round'
    ctx.fillStyle = '#ffffff'
    ctx.fillRect(0, 0, canvas.width, canvas.height)
  }, [])

  const startDrawing = (e) => {
    setIsDrawing(true)
    const canvas = canvasRef.current
    const rect = canvas.getBoundingClientRect()
    const ctx = canvas.getContext('2d')
    
    ctx.beginPath()
    ctx.moveTo(
      e.clientX - rect.left,
      e.clientY - rect.top
    )
  }

  const draw = (e) => {
    if (!isDrawing) return

    const canvas = canvasRef.current
    const rect = canvas.getBoundingClientRect()
    const ctx = canvas.getContext('2d')

    ctx.lineWidth = brushSize
    ctx.strokeStyle = color
    ctx.lineTo(
      e.clientX - rect.left,
      e.clientY - rect.top
    )
    ctx.stroke()
  }

  const stopDrawing = () => {
    setIsDrawing(false)
  }

  const clearCanvas = () => {
    const canvas = canvasRef.current
    const ctx = canvas.getContext('2d')
    ctx.fillStyle = '#ffffff'
    ctx.fillRect(0, 0, canvas.width, canvas.height)
  }

  const saveCanvas = () => {
    const canvas = canvasRef.current
    const link = document.createElement('a')
    link.download = 'mon-dessin.png'
    link.href = canvas.toDataURL()
    link.click()
  }

  const drawPreset = (preset) => {
    const canvas = canvasRef.current
    const ctx = canvas.getContext('2d')

    switch (preset) {
      case 'circle':
        ctx.beginPath()
        ctx.arc(150, 100, 50, 0, 2 * Math.PI)
        ctx.strokeStyle = color
        ctx.lineWidth = brushSize
        ctx.stroke()
        break
      
      case 'square':
        ctx.strokeStyle = color
        ctx.lineWidth = brushSize
        ctx.strokeRect(100, 50, 100, 100)
        break
      
      case 'line':
        ctx.beginPath()
        ctx.moveTo(50, 50)
        ctx.lineTo(250, 150)
        ctx.strokeStyle = color
        ctx.lineWidth = brushSize
        ctx.stroke()
        break
    }
  }

  return (
    <div>
      <h3>Canvas Dessin</h3>
      
      <div style={{ marginBottom: '10px' }}>
        <label>
          Couleur:
          <input
            type="color"
            value={color}
            onChange={e => setColor(e.target.value)}
          />
        </label>
        
        <label style={{ marginLeft: '20px' }}>
          Taille:
          <input
            type="range"
            min="1"
            max="20"
            value={brushSize}
            onChange={e => setBrushSize(Number(e.target.value))}
          />
          {brushSize}px
        </label>
      </div>

      <canvas
        ref={canvasRef}
        width={400}
        height={300}
        style={{
          border: '2px solid #ccc',
          cursor: 'crosshair'
        }}
        onMouseDown={startDrawing}
        onMouseMove={draw}
        onMouseUp={stopDrawing}
        onMouseLeave={stopDrawing}
      />

      <div style={{ marginTop: '10px' }}>
        <button onClick={clearCanvas}>üóëÔ∏è Effacer</button>
        <button onClick={saveCanvas}>üíæ Sauvegarder</button>
        <button onClick={() => drawPreset('circle')}>‚≠ï Cercle</button>
        <button onClick={() => drawPreset('square')}>‚¨ú Carr√©</button>
        <button onClick={() => drawPreset('line')}>üìè Ligne</button>
      </div>
    </div>
  )
}
```

---

## useRef pour Valeurs Mutables

### Stocker des Valeurs sans Re-render

```jsx
function MutableValues() {
  const [count, setCount] = useState(0)
  const [message, setMessage] = useState('')
  
  // R√©f√©rences pour stocker des valeurs mutables
  const renderCountRef = useRef(0)
  const previousCountRef = useRef(0)
  const timerRef = useRef(null)
  const inputValueRef = useRef('')

  // Incr√©menter le compteur de renders
  renderCountRef.current++

  const startTimer = () => {
    if (!timerRef.current) {
      timerRef.current = setInterval(() => {
        setCount(prevCount => {
          previousCountRef.current = prevCount
          return prevCount + 1
        })
      }, 1000)
    }
  }

  const stopTimer = () => {
    if (timerRef.current) {
      clearInterval(timerRef.current)
      timerRef.current = null
    }
  }

  const resetCounter = () => {
    previousCountRef.current = count
    setCount(0)
  }

  // Cleanup du timer
  useEffect(() => {
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current)
      }
    }
  }, [])

  const handleInputChange = (e) => {
    // Stocker la valeur sans d√©clencher de re-render
    inputValueRef.current = e.target.value
    console.log('Valeur stock√©e (sans re-render):', inputValueRef.current)
  }

  const showStoredValue = () => {
    setMessage(`Valeur stock√©e: "${inputValueRef.current}"`)
  }

  return (
    <div>
      <h3>Valeurs Mutables avec useRef</h3>
      
      <div>
        <p>Renders: {renderCountRef.current}</p>
        <p>Count actuel: {count}</p>
        <p>Count pr√©c√©dent: {previousCountRef.current}</p>
        <p>Timer status: {timerRef.current ? 'üü¢ Actif' : 'üî¥ Arr√™t√©'}</p>
      </div>

      <div>
        <button onClick={startTimer}>‚ñ∂Ô∏è Start Timer</button>
        <button onClick={stopTimer}>‚èπÔ∏è Stop Timer</button>
        <button onClick={resetCounter}>üîÑ Reset Count</button>
      </div>

      <div style={{ marginTop: '20px' }}>
        <h4>Input sans Re-render</h4>
        <input
          onChange={handleInputChange}
          placeholder="Tape ici (pas de re-render)"
        />
        <button onClick={showStoredValue}>Afficher valeur stock√©e</button>
        {message && <p>{message}</p>}
      </div>
    </div>
  )
}
```

### Cache et M√©morisation

```jsx
function CacheExample() {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState([])
  const [isLoading, setIsLoading] = useState(false)
  
  // Cache des r√©sultats de recherche
  const cacheRef = useRef(new Map())
  const abortControllerRef = useRef(null)

  const searchData = async (searchQuery) => {
    // V√©rifier le cache d'abord
    if (cacheRef.current.has(searchQuery)) {
      console.log('üéØ R√©sultat du cache pour:', searchQuery)
      setResults(cacheRef.current.get(searchQuery))
      return
    }

    // Annuler la requ√™te pr√©c√©dente
    if (abortControllerRef.current) {
      abortControllerRef.current.abort()
    }

    // Nouvelle requ√™te
    abortControllerRef.current = new AbortController()
    setIsLoading(true)

    try {
      console.log('üåê Requ√™te API pour:', searchQuery)
      
      // Simulation d'une API call
      await new Promise(resolve => setTimeout(resolve, 1000))
      
      const mockResults = [
        `R√©sultat 1 pour "${searchQuery}"`,
        `R√©sultat 2 pour "${searchQuery}"`,
        `R√©sultat 3 pour "${searchQuery}"`
      ]

      // Stocker dans le cache
      cacheRef.current.set(searchQuery, mockResults)
      setResults(mockResults)
      
      console.log('üì¶ Cache size:', cacheRef.current.size)
    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error('Erreur de recherche:', error)
      }
    } finally {
      setIsLoading(false)
    }
  }

  const handleSearch = () => {
    if (query.trim()) {
      searchData(query.trim())
    }
  }

  const clearCache = () => {
    cacheRef.current.clear()
    console.log('üóëÔ∏è Cache vid√©')
  }

  const showCacheInfo = () => {
    console.log('üìä Contenu du cache:', Object.fromEntries(cacheRef.current))
    alert(`Cache contient ${cacheRef.current.size} entr√©es`)
  }

  return (
    <div>
      <h3>Cache avec useRef</h3>
      
      <div>
        <input
          value={query}
          onChange={e => setQuery(e.target.value)}
          placeholder="Terme de recherche..."
          onKeyDown={e => e.key === 'Enter' && handleSearch()}
        />
        <button onClick={handleSearch} disabled={isLoading}>
          {isLoading ? 'üîç Recherche...' : 'üîç Rechercher'}
        </button>
      </div>

      <div style={{ marginTop: '10px' }}>
        <button onClick={clearCache}>üóëÔ∏è Vider Cache</button>
        <button onClick={showCacheInfo}>üìä Info Cache</button>
        <span style={{ marginLeft: '10px' }}>
          Cache: {cacheRef.current.size} entr√©es
        </span>
      </div>

      <div style={{ marginTop: '20px' }}>
        {results.length > 0 && (
          <div>
            <h4>R√©sultats:</h4>
            <ul>
              {results.map((result, index) => (
                <li key={index}>{result}</li>
              ))}
            </ul>
          </div>
        )}
      </div>
    </div>
  )
}
```

---

## Cas d'Usage Avanc√©s

### Intersection Observer

```jsx
function IntersectionObserverExample() {
  const [visibleSections, setVisibleSections] = useState(new Set())
  const observerRef = useRef(null)
  const sectionsRef = useRef([])

  useEffect(() => {
    // Cr√©er l'observer
    observerRef.current = new IntersectionObserver(
      (entries) => {
        setVisibleSections(prev => {
          const newVisible = new Set(prev)
          
          entries.forEach(entry => {
            const sectionId = entry.target.dataset.section
            if (entry.isIntersecting) {
              newVisible.add(sectionId)
            } else {
              newVisible.delete(sectionId)
            }
          })
          
          return newVisible
        })
      },
      {
        threshold: 0.5,
        rootMargin: '-50px'
      }
    )

    // Observer toutes les sections
    sectionsRef.current.forEach(section => {
      if (section) {
        observerRef.current.observe(section)
      }
    })

    // Cleanup
    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect()
      }
    }
  }, [])

  const scrollToSection = (sectionId) => {
    const section = sectionsRef.current.find(
      s => s && s.dataset.section === sectionId
    )
    if (section) {
      section.scrollIntoView({ behavior: 'smooth' })
    }
  }

  const sections = ['intro', 'features', 'pricing', 'contact']

  return (
    <div>
      <h3>Intersection Observer</h3>
      
      {/* Navigation */}
      <nav style={{
        position: 'sticky',
        top: 0,
        background: '#f8f9fa',
        padding: '10px',
        borderBottom: '1px solid #dee2e6'
      }}>
        {sections.map(sectionId => (
          <button
            key={sectionId}
            onClick={() => scrollToSection(sectionId)}
            style={{
              marginRight: '10px',
              padding: '5px 15px',
              backgroundColor: visibleSections.has(sectionId) ? '#007bff' : '#6c757d',
              color: 'white',
              border: 'none',
              borderRadius: '3px'
            }}
          >
            {sectionId.charAt(0).toUpperCase() + sectionId.slice(1)}
          </button>
        ))}
      </nav>

      {/* Sections */}
      {sections.map((sectionId, index) => (
        <section
          key={sectionId}
          ref={el => sectionsRef.current[index] = el}
          data-section={sectionId}
          style={{
            height: '80vh',
            padding: '50px',
            backgroundColor: index % 2 === 0 ? '#f8f9fa' : '#ffffff',
            border: visibleSections.has(sectionId) ? '3px solid #007bff' : '3px solid transparent'
          }}
        >
          <h2>{sectionId.charAt(0).toUpperCase() + sectionId.slice(1)}</h2>
          <p>
            Contenu de la section {sectionId}. 
            {visibleSections.has(sectionId) ? ' ‚úÖ Visible' : ' ‚ùå Non visible'}
          </p>
          <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit...</p>
        </section>
      ))}
    </div>
  )
}
```

### Focus Management

```jsx
function FocusManagement() {
  const [isModalOpen, setIsModalOpen] = useState(false)
  const [formData, setFormData] = useState({ name: '', email: '' })
  
  const openButtonRef = useRef(null)
  const modalRef = useRef(null)
  const firstInputRef = useRef(null)
  const lastButtonRef = useRef(null)

  const openModal = () => {
    setIsModalOpen(true)
  }

  const closeModal = () => {
    setIsModalOpen(false)
    // Remettre le focus sur le bouton d'ouverture
    openButtonRef.current?.focus()
  }

  const handleKeyDown = (e) => {
    if (e.key === 'Escape') {
      closeModal()
    }

    // Trap focus dans la modal
    if (e.key === 'Tab') {
      if (e.shiftKey) {
        // Shift + Tab
        if (document.activeElement === firstInputRef.current) {
          e.preventDefault()
          lastButtonRef.current?.focus()
        }
      } else {
        // Tab
        if (document.activeElement === lastButtonRef.current) {
          e.preventDefault()
          firstInputRef.current?.focus()
        }
      }
    }
  }

  useEffect(() => {
    if (isModalOpen) {
      // Focus sur le premier √©l√©ment de la modal
      setTimeout(() => {
        firstInputRef.current?.focus()
      }, 100)

      // Ajouter les event listeners
      document.addEventListener('keydown', handleKeyDown)
      
      return () => {
        document.removeEventListener('keydown', handleKeyDown)
      }
    }
  }, [isModalOpen])

  const handleSubmit = (e) => {
    e.preventDefault()
    console.log('Form submitted:', formData)
    closeModal()
    setFormData({ name: '', email: '' })
  }

  return (
    <div>
      <h3>Focus Management</h3>
      
      <button
        ref={openButtonRef}
        onClick={openModal}
      >
        Ouvrir Modal
      </button>

      {isModalOpen && (
        <div
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: 'rgba(0,0,0,0.5)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000
          }}
          onClick={(e) => e.target === e.currentTarget && closeModal()}
        >
          <div
            ref={modalRef}
            style={{
              backgroundColor: 'white',
              padding: '30px',
              borderRadius: '8px',
              minWidth: '300px'
            }}
          >
            <h4>Formulaire Modal</h4>
            
            <form onSubmit={handleSubmit}>
              <div style={{ marginBottom: '15px' }}>
                <label>
                  Nom:
                  <input
                    ref={firstInputRef}
                    type="text"
                    value={formData.name}
                    onChange={e => setFormData(prev => ({ ...prev, name: e.target.value }))}
                    style={{ display: 'block', width: '100%', padding: '5px' }}
                  />
                </label>
              </div>

              <div style={{ marginBottom: '20px' }}>
                <label>
                  Email:
                  <input
                    type="email"
                    value={formData.email}
                    onChange={e => setFormData(prev => ({ ...prev, email: e.target.value }))}
                    style={{ display: 'block', width: '100%', padding: '5px' }}
                  />
                </label>
              </div>

              <div>
                <button type="submit" style={{ marginRight: '10px' }}>
                  Valider
                </button>
                <button
                  ref={lastButtonRef}
                  type="button"
                  onClick={closeModal}
                >
                  Annuler
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  )
}
```

---

## Forwarding Refs

### Forward Ref Basique

```jsx
// Composant enfant qui forward sa ref
const CustomInput = forwardRef((props, ref) => {
  return (
    <input
      ref={ref}
      {...props}
      style={{
        padding: '10px',
        border: '2px solid #007bff',
        borderRadius: '4px',
        ...props.style
      }}
    />
  )
})

// Nom d'affichage pour les dev tools
CustomInput.displayName = 'CustomInput'

function ForwardRefExample() {
  const customInputRef = useRef(null)
  const [value, setValue] = useState('')

  const focusCustomInput = () => {
    customInputRef.current.focus()
  }

  const selectAllText = () => {
    customInputRef.current.select()
  }

  return (
    <div>
      <h3>Forward Ref</h3>
      
      <CustomInput
        ref={customInputRef}
        value={value}
        onChange={e => setValue(e.target.value)}
        placeholder="Custom Input avec ref"
      />

      <div style={{ marginTop: '10px' }}>
        <button onClick={focusCustomInput}>Focus</button>
        <button onClick={selectAllText}>S√©lectionner tout</button>
      </div>
    </div>
  )
})

// Composant avec useImperativeHandle
const AdvancedInput = forwardRef((props, ref) => {
  const inputRef = useRef(null)
  const [internalValue, setInternalValue] = useState('')

  // Exposer des m√©thodes personnalis√©es
  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus(),
    clear: () => {
      setInternalValue('')
      inputRef.current.focus()
    },
    getValue: () => internalValue,
    setValue: (value) => setInternalValue(value),
    getSelection: () => ({
      start: inputRef.current.selectionStart,
      end: inputRef.current.selectionEnd
    })
  }))

  return (
    <input
      ref={inputRef}
      value={internalValue}
      onChange={e => setInternalValue(e.target.value)}
      {...props}
      style={{
        padding: '10px',
        border: '2px solid #28a745',
        borderRadius: '4px',
        ...props.style
      }}
    />
  )
})

AdvancedInput.displayName = 'AdvancedInput'

function ImperativeHandleExample() {
  const advancedInputRef = useRef(null)

  const handleClear = () => {
    advancedInputRef.current.clear()
  }

  const handleGetValue = () => {
    const value = advancedInputRef.current.getValue()
    alert(`Valeur: "${value}"`)
  }

  const handleSetValue = () => {
    advancedInputRef.current.setValue('Valeur d√©finie par le parent')
  }

  const handleGetSelection = () => {
    const selection = advancedInputRef.current.getSelection()
    alert(`S√©lection: ${selection.start}-${selection.end}`)
  }

  return (
    <div>
      <h3>useImperativeHandle</h3>
      
      <AdvancedInput
        ref={advancedInputRef}
        placeholder="Input avec m√©thodes personnalis√©es"
      />

      <div style={{ marginTop: '10px' }}>
        <button onClick={handleClear}>Clear</button>
        <button onClick={handleGetValue}>Get Value</button>
        <button onClick={handleSetValue}>Set Value</button>
        <button onClick={handleGetSelection}>Get Selection</button>
      </div>
    </div>
  )
}
```

---

## Points Cl√©s √† Retenir

1. **useRef** = r√©f√©rences DOM + valeurs mutables
2. **Pas de re-render** = changer `.current` ne d√©clenche pas de re-render
3. **DOM access** = acc√©der directement aux √©l√©ments HTML
4. **Valeurs persistantes** = survivent aux re-renders
5. **Cleanup** = penser √† nettoyer les timers/listeners stock√©s en ref
6. **forwardRef** = passer des refs aux composants enfants
7. **useImperativeHandle** = exposer des m√©thodes personnalis√©es

---

## Erreurs Communes

### 1. Acc√®s √† ref.current avant le mount

```jsx
// ‚ùå MAUVAIS - ref peut √™tre null
function BadRefUsage() {
  const inputRef = useRef(null)
  
  // ‚ùå Peut crash si appel√© avant le mount
  const focusInput = () => {
    inputRef.current.focus() // ‚ùå Peut √™tre null !
  }
  
  return <input ref={inputRef} />
}

// ‚úÖ BON - V√©rifier null
function GoodRefUsage() {
  const inputRef = useRef(null)
  
  // ‚úÖ V√©rification de s√©curit√©
  const focusInput = () => {
    if (inputRef.current) {
      inputRef.current.focus()
    }
  }
  
  return <input ref={inputRef} />
}
```

### 2. Utiliser ref au lieu de state

```jsx
// ‚ùå MAUVAIS - Utiliser ref pour l'√©tat UI
function BadStateUsage() {
  const countRef = useRef(0)
  
  const increment = () => {
    countRef.current++ // ‚ùå Pas de re-render !
  }
  
  return (
    <div>
      <p>Count: {countRef.current}</p> {/* ‚ùå Ne se met pas √† jour */}
      <button onClick={increment}>+1</button>
    </div>
  )
}

// ‚úÖ BON - Utiliser state pour l'√©tat UI
function GoodStateUsage() {
  const [count, setCount] = useState(0)
  
  const increment = () => {
    setCount(prev => prev + 1) // ‚úÖ Re-render !
  }
  
  return (
    <div>
      <p>Count: {count}</p> {/* ‚úÖ Se met √† jour */}
      <button onClick={increment}>+1</button>
    </div>
  )
}
```

---

## Ressources Pour Aller Plus Loin

- üìö [useRef Documentation](https://react.dev/reference/react/useRef)
- üéØ [Manipulating the DOM with Refs](https://react.dev/learn/manipulating-the-dom-with-refs)
- üí° [forwardRef Documentation](https://react.dev/reference/react/forwardRef)
- üîß [useImperativeHandle](https://react.dev/reference/react/useImperativeHandle)
