# React - Composants Fonctionnels Avanc√©s

## Introduction

Les **composants fonctionnels** sont le c≈ìur de React moderne. Comme dit la doc officielle : *"Functional components are some of the more common components that will come across while working in React. These are simply JavaScript functions."*

Cette section compl√®te le chapitre **15.0.2-Basics.md** avec des concepts avanc√©s et exemples pratiques !

---

## R√©volution des Composants Fonctionnels

### Avant vs Maintenant

```jsx
// AVANT - Class Component (2015-2019) ‚ùå
class CompteurOldSchool extends React.Component {
  constructor(props) {
    super(props)
    this.state = { count: 0 }
    this.handleClick = this.handleClick.bind(this)
  }

  handleClick() {
    this.setState({ count: this.state.count + 1 })
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleClick}>+1</button>
      </div>
    )
  }
}

// MAINTENANT - Functional Component (2019+) ‚úÖ
function CompteurModerne() {
  const [count, setCount] = useState(0)

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  )
}
```

**Pourquoi cette r√©volution ?**

- **Moins de code** (5 lignes vs 20 lignes)
- **Plus lisible** et compr√©hensible
- **Hooks** permettent tout ce que faisaient les classes
- **Performance optimis√©e** par React
- **Recommandation officielle** depuis 2019

---

## √âtat = M√©moire du Composant

### Concept fondamental

L'**√©tat** (state), c'est la **m√©moire** de ton composant. Il lui permet de :

1. **Se souvenir** d'informations entre les rendus
2. **D√©clencher un re-rendu** quand les donn√©es changent

```jsx
import { useState } from 'react'

function ExempleMemoire() {
  // ‚ùå Variable normale = Reset √† chaque rendu
  let variableNormale = 0

  // ‚úÖ √âtat = Persiste entre les rendus
  const [etat, setEtat] = useState(0)

  const incrementer = () => {
    variableNormale++        // Ne marche pas !
    console.log('Variable normale:', variableNormale) // Toujours 1

    setEtat(etat + 1)        // Marche !
  }

  return (
    <div>
      <p>Variable normale: {variableNormale}</p>
      <p>√âtat: {etat}</p>
      <button onClick={incrementer}>Incrementer</button>
    </div>
  )
}
```

### useState en d√©tail

```jsx
import { useState } from 'react'

function ExempleUseState() {
  // useState retourne un tableau avec 2 √©l√©ments :
  const [valeur, setValeur] = useState('valeur initiale')
  //     ^^^^^^  ^^^^^^^^^
  //     |       |
  //     |       +-- Fonction pour modifier l'√©tat
  //     +-- Valeur actuelle de l'√©tat

  // Diff√©rentes fa√ßons de modifier l'√©tat
  const exemples = () => {
    // 1. Valeur directe
    setValeur('nouvelle valeur')

    // 2. Fonction de mise √† jour (recommand√©e pour les calculs)
    setValeur(prevValeur => prevValeur + ' modifi√©e')

    // 3. Avec √©tat complexe
    setValeur(prev => {
      console.log('Ancienne valeur:', prev)
      return 'nouvelle valeur calcul√©e'
    })
  }

  return (
    <div>
      <p>Valeur: {valeur}</p>
      <button onClick={() => setValeur('clic simple')}>Simple</button>
      <button onClick={() => setValeur(prev => prev + '!')}>Avec fonction</button>
    </div>
  )
}
```

### R√®gles cruciales pour useState

‚ö†Ô∏è **TR√àS IMPORTANT** - Ces r√®gles sont **NON-N√âGOCIABLES** :

1. **Appel√© uniquement au top level** du composant
2. **Pas dans des boucles, conditions ou fonctions imbriqu√©es**
3. **M√™me ordre √† chaque rendu**

```jsx
// ‚úÖ CORRECT
function BonExemple() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')
  const [visible, setVisible] = useState(true)

  if (count > 5) {
    // ‚ùå INCORRECT - useState dans une condition
    // const [error, setError] = useState('')
  }

  for (let i = 0; i < 3; i++) {
    // ‚ùå INCORRECT - useState dans une boucle
    // const [items, setItems] = useState([])
  }

  const handleClick = () => {
    // ‚ùå INCORRECT - useState dans une fonction
    // const [temp, setTemp] = useState(0)
  }

  return <div>...</div>
}
```

### √âtat local vs partag√©

```jsx
// Chaque instance a son propre √©tat
function Compteur({ id }) {
  const [count, setCount] = useState(0)

  return (
    <div>
      <h3>Compteur {id}</h3>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  )
}

function App() {
  return (
    <div>
      <Compteur id="A" />  {/* √âtat ind√©pendant */}
      <Compteur id="B" />  {/* √âtat ind√©pendant */}
      <Compteur id="C" />  {/* √âtat ind√©pendant */}
    </div>
  )
}
```

---

## Exemples Pratiques Avanc√©s

### 1. Formulaire de Contact Intelligent

```jsx
function FormulaireContact() {
  const [formData, setFormData] = useState({
    nom: '',
    email: '',
    message: ''
  })
  const [erreurs, setErreurs] = useState({})
  const [envoye, setEnvoye] = useState(false)
  const [enCoursEnvoi, setEnCoursEnvoi] = useState(false)

  const validerChamp = (field, value) => {
    const nouvellesErreurs = { ...erreurs }

    switch (field) {
      case 'nom':
        if (!value.trim()) {
          nouvellesErreurs.nom = 'Le nom est requis'
        } else if (value.length < 2) {
          nouvellesErreurs.nom = 'Le nom doit faire au moins 2 caract√®res'
        } else {
          delete nouvellesErreurs.nom
        }
        break

      case 'email':
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
        if (!value.trim()) {
          nouvellesErreurs.email = 'L\'email est requis'
        } else if (!emailRegex.test(value)) {
          nouvellesErreurs.email = 'Format d\'email invalide'
        } else {
          delete nouvellesErreurs.email
        }
        break

      case 'message':
        if (!value.trim()) {
          nouvellesErreurs.message = 'Le message est requis'
        } else if (value.length < 10) {
          nouvellesErreurs.message = 'Le message doit faire au moins 10 caract√®res'
        } else {
          delete nouvellesErreurs.message
        }
        break
    }

    setErreurs(nouvellesErreurs)
    return Object.keys(nouvellesErreurs).length === 0
  }

  const handleChange = (field, value) => {
    setFormData({ ...formData, [field]: value })

    // Validation en temps r√©el
    if (formData[field] !== '') {
      validerChamp(field, value)
    }
  }

  const handleSubmit = async (e) => {
    e.preventDefault()

    // Validation compl√®te
    const champsValides = Object.keys(formData).every(field =>
      validerChamp(field, formData[field])
    )

    if (champsValides && Object.keys(erreurs).length === 0) {
      setEnCoursEnvoi(true)

      try {
        // Simulation d'envoi API
        await new Promise(resolve => setTimeout(resolve, 2000))

        console.log('üìß Email envoy√©:', formData)
        setEnvoye(true)

        // Reset automatique apr√®s succ√®s
        setTimeout(() => {
          setEnvoye(false)
          setFormData({ nom: '', email: '', message: '' })
          setErreurs({})
        }, 4000)

      } catch (error) {
        setErreurs({ general: 'Erreur lors de l\'envoi. Veuillez r√©essayer.' })
      } finally {
        setEnCoursEnvoi(false)
      }
    }
  }

  // Rendu de succ√®s
  if (envoye) {
    return (
      <div className="success-container">
        <div className="success-message">
          <h2>‚úÖ Message envoy√© avec succ√®s!</h2>
          <p>Merci <strong>{formData.nom}</strong>, nous vous r√©pondrons sous 24h √† l'adresse :</p>
          <p><strong>{formData.email}</strong></p>
          <div className="success-animation">üéâ</div>
        </div>
      </div>
    )
  }

  const peutEnvoyer = Object.keys(erreurs).length === 0 &&
    formData.nom && formData.email && formData.message

  return (
    <div className="contact-form-container">
      <form onSubmit={handleSubmit} className="contact-form">
        <h2>üì¨ Contactez-nous</h2>

        {erreurs.general && (
          <div className="error-banner">
            ‚ùå {erreurs.general}
          </div>
        )}

        <div className="field-group">
          <label htmlFor="nom">
            Nom complet *
            {formData.nom && !erreurs.nom && <span className="valid">‚úì</span>}
          </label>
          <input
            id="nom"
            type="text"
            value={formData.nom}
            onChange={(e) => handleChange('nom', e.target.value)}
            className={erreurs.nom ? 'error' : formData.nom ? 'valid' : ''}
            disabled={enCoursEnvoi}
            placeholder="Votre nom et pr√©nom"
          />
          {erreurs.nom && <span className="error-text">{erreurs.nom}</span>}
        </div>

        <div className="field-group">
          <label htmlFor="email">
            Adresse email *
            {formData.email && !erreurs.email && <span className="valid">‚úì</span>}
          </label>
          <input
            id="email"
            type="email"
            value={formData.email}
            onChange={(e) => handleChange('email', e.target.value)}
            className={erreurs.email ? 'error' : formData.email ? 'valid' : ''}
            disabled={enCoursEnvoi}
            placeholder="votre@email.com"
          />
          {erreurs.email && <span className="error-text">{erreurs.email}</span>}
        </div>

        <div className="field-group">
          <label htmlFor="message">
            Votre message *
            <span className="counter">
              ({formData.message.length}/10 min)
            </span>
            {formData.message.length >= 10 && !erreurs.message && <span className="valid">‚úì</span>}
          </label>
          <textarea
            id="message"
            value={formData.message}
            onChange={(e) => handleChange('message', e.target.value)}
            className={erreurs.message ? 'error' : formData.message.length >= 10 ? 'valid' : ''}
            disabled={enCoursEnvoi}
            rows={6}
            placeholder="D√©crivez votre demande en d√©tail..."
          />
          {erreurs.message && <span className="error-text">{erreurs.message}</span>}
        </div>

        <button
          type="submit"
          disabled={!peutEnvoyer || enCoursEnvoi}
          className={`submit-btn ${peutEnvoyer ? 'ready' : 'disabled'}`}
        >
          {enCoursEnvoi ? (
            <>‚è≥ Envoi en cours...</>
          ) : peutEnvoyer ? (
            <>üì§ Envoyer le message</>
          ) : (
            <>üìù Remplissez tous les champs</>
          )}
        </button>

        <p className="form-info">
          <small>* Champs obligatoires. Vos donn√©es sont prot√©g√©es.</small>
        </p>
      </form>
    </div>
  )
}
```

### 2. Timer/Chronom√®tre Avanc√©

```jsx
function TimerAvance() {
  const [temps, setTemps] = useState(0)
  const [actif, setActif] = useState(false)
  const [mode, setMode] = useState('chrono') // 'chrono' ou 'minuteur'
  const [objectif, setObjectif] = useState(300) // 5 minutes par d√©faut
  const [laps, setLaps] = useState([])

  // Gestion du timer
  useEffect(() => {
    let intervalId = null

    if (actif) {
      intervalId = setInterval(() => {
        setTemps(prevTemps => {
          if (mode === 'minuteur') {
            const nouveau = prevTemps - 1
            if (nouveau <= 0) {
              setActif(false)
              alert('‚è∞ Temps √©coul√©!')
              return 0
            }
            return nouveau
          } else {
            return prevTemps + 1
          }
        })
      }, 1000)
    }

    return () => {
      if (intervalId) clearInterval(intervalId)
    }
  }, [actif, mode])

  const demarrer = () => {
    if (mode === 'minuteur' && temps === 0) {
      setTemps(objectif)
    }
    setActif(true)
  }

  const arreter = () => setActif(false)

  const reset = () => {
    setTemps(mode === 'minuteur' ? objectif : 0)
    setActif(false)
    setLaps([])
  }

  const ajouterLap = () => {
    if (mode === 'chrono' && actif) {
      setLaps([...laps, temps])
    }
  }

  const changerMode = (nouveauMode) => {
    setMode(nouveauMode)
    setActif(false)
    setLaps([])
    setTemps(nouveauMode === 'minuteur' ? objectif : 0)
  }

  const formatTemps = (secondes) => {
    const heures = Math.floor(Math.abs(secondes) / 3600)
    const minutes = Math.floor((Math.abs(secondes) % 3600) / 60)
    const sec = Math.abs(secondes) % 60

    if (heures > 0) {
      return `${heures.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`
    }
    return `${minutes.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`
  }

  const pourcentageProgress = mode === 'minuteur' ?
    ((objectif - temps) / objectif) * 100 : 0

  return (
    <div className="timer-avance">
      <div className="timer-header">
        <div className="mode-selector">
          <button
            className={mode === 'chrono' ? 'active' : ''}
            onClick={() => changerMode('chrono')}
            disabled={actif}
          >
            ‚è±Ô∏è Chronom√®tre
          </button>
          <button
            className={mode === 'minuteur' ? 'active' : ''}
            onClick={() => changerMode('minuteur')}
            disabled={actif}
          >
            ‚è≤Ô∏è Minuteur
          </button>
        </div>
      </div>

      {mode === 'minuteur' && (
        <div className="objectif-setter">
          <label>Dur√©e (minutes):</label>
          <input
            type="number"
            min="1"
            max="60"
            value={Math.floor(objectif / 60)}
            onChange={(e) => setObjectif(Number(e.target.value) * 60)}
            disabled={actif}
          />
          <div className="progress-bar">
            <div
              className="progress"
              style={{ width: `${pourcentageProgress}%` }}
            />
          </div>
        </div>
      )}

      <div className={`display ${mode === 'minuteur' && temps <= 10 ? 'urgent' : ''}`}>
        <h1 className="time-display">{formatTemps(temps)}</h1>
        <p className="status">
          {actif ? (
            mode === 'chrono' ? '‚è∞ En cours' : '‚è≥ D√©compte'
          ) : (
            '‚è∏Ô∏è Arr√™t√©'
          )}
        </p>
      </div>

      <div className="controls">
        <button
          onClick={demarrer}
          disabled={actif}
          className="start-btn"
        >
          ‚ñ∂Ô∏è {mode === 'chrono' ? 'Start' : 'D√©marrer'}
        </button>

        <button
          onClick={arreter}
          disabled={!actif}
          className="pause-btn"
        >
          ‚è∏Ô∏è Pause
        </button>

        {mode === 'chrono' && (
          <button
            onClick={ajouterLap}
            disabled={!actif}
            className="lap-btn"
          >
            üèÅ Lap
          </button>
        )}

        <button
          onClick={reset}
          className="reset-btn"
        >
          üîÑ Reset
        </button>
      </div>

      {mode === 'chrono' && laps.length > 0 && (
        <div className="laps-section">
          <h3>Tours enregistr√©s:</h3>
          <ul className="laps-list">
            {laps.map((lap, index) => (
              <li key={index}>
                <span>Tour {index + 1}:</span>
                <span>{formatTemps(lap)}</span>
                {index > 0 && (
                  <span className="diff">
                    (+{formatTemps(lap - laps[index - 1])})
                  </span>
                )}
              </li>
            )).reverse()}
          </ul>
        </div>
      )}

      <div className="stats">
        {mode === 'chrono' ? (
          <>
            <p>Sessions: {Math.floor(temps / 60)} min</p>
            {temps > 300 && <p>üéâ Plus de 5 minutes !</p>}
            {temps > 1800 && <p>üèÜ Plus de 30 minutes - Champion!</p>}
          </>
        ) : (
          <>
            <p>Temps restant: {formatTemps(temps)}</p>
            {temps <= 30 && temps > 0 && <p>‚ö†Ô∏è Bient√¥t fini!</p>}
          </>
        )}
      </div>
    </div>
  )
}
```

### 3. Dashboard avec Authentification et R√¥les

```jsx
function Dashboard({ user, notifications = [] }) {
  const [ongletActif, setOngletActif] = useState('profil')
  const [sidebarOuverte, setSidebarOuverte] = useState(false)
  const [modeNuit, setModeNuit] = useState(false)

  // Guard clause - pattern tr√®s important
  if (!user) {
    return <EcranConnexion />
  }

  // Logique des permissions
  const permissions = {
    canViewAnalytics: user.role === 'admin' || user.role === 'manager',
    canManageUsers: user.role === 'admin',
    canEditSettings: user.role !== 'guest'
  }

  // Gestion des notifications
  const notificationsNonLues = notifications.filter(n => !n.lue).length
  const notificationsUrgentes = notifications.filter(n => n.priorite === 'urgent').length

  // Rendu conditionnel intelligent
  const renderContenu = () => {
    switch (ongletActif) {
      case 'profil':
        return <ProfilUtilisateur user={user} />

      case 'notifications':
        return (
          <SectionNotifications
            notifications={notifications}
            onMarkAsRead={(id) => markNotificationAsRead(id)}
          />
        )

      case 'parametres':
        if (!permissions.canEditSettings) {
          return <AccesDenie message="Vous n'avez pas les permissions pour modifier les param√®tres" />
        }
        return <Parametres user={user} />

      case 'analytics':
        if (!permissions.canViewAnalytics) {
          return <AccesDenie message="Acc√®s limit√© aux administrateurs et managers" />
        }
        return <Analytics userRole={user.role} />

      case 'users':
        if (!permissions.canManageUsers) {
          return <AccesDenie message="Fonction r√©serv√©e aux administrateurs" />
        }
        return <GestionUtilisateurs />

      default:
        return <Page404 />
    }
  }

  // Calcul dynamique des onglets disponibles
  const onglets = [
    { id: 'profil', nom: 'üë§ Profil', icone: 'üë§' },
    {
      id: 'notifications',
      nom: 'üîî Notifications',
      badge: notificationsNonLues,
      urgent: notificationsUrgentes > 0
    },
    ...(permissions.canEditSettings ? [{ id: 'parametres', nom: '‚öôÔ∏è Param√®tres' }] : []),
    ...(permissions.canViewAnalytics ? [{ id: 'analytics', nom: 'üìä Analytics' }] : []),
    ...(permissions.canManageUsers ? [{ id: 'users', nom: 'üë• Utilisateurs' }] : [])
  ]

  return (
    <div className={`dashboard ${sidebarOuverte ? 'sidebar-open' : ''} ${modeNuit ? 'dark-mode' : ''}`}>

      <header className="dashboard-header">
        <div className="header-left">
          <button
            className="menu-toggle"
            onClick={() => setSidebarOuverte(!sidebarOuverte)}
            aria-label="Toggle sidebar"
          >
            ‚ò∞
          </button>
          <h1>Dashboard</h1>
        </div>

        <div className="header-right">
          <button
            className="theme-toggle"
            onClick={() => setModeNuit(!modeNuit)}
            aria-label="Toggle dark mode"
          >
            {modeNuit ? '‚òÄÔ∏è' : 'üåô'}
          </button>

          <div className="user-info">
            <img
              src={user.avatar || '/default-avatar.png'}
              alt={`Avatar de ${user.nom}`}
              className="user-avatar"
            />
            <div>
              <span className="user-name">üëã {user.nom}</span>
              <span className="user-role">{user.role}</span>
            </div>
          </div>
        </div>
      </header>

      <aside className={`sidebar ${sidebarOuverte ? 'open' : ''}`}>
        <nav>
          <ul className="nav-list">
            {onglets.map(onglet => (
              <li key={onglet.id}>
                <button
                  className={`nav-button ${ongletActif === onglet.id ? 'active' : ''}`}
                  onClick={() => {
                    setOngletActif(onglet.id)
                    setSidebarOuverte(false) // Ferme sur mobile
                  }}
                >
                  <span className="nav-label">{onglet.nom}</span>

                  {onglet.badge > 0 && (
                    <span className={`badge ${onglet.urgent ? 'urgent' : ''}`}>
                      {onglet.badge}
                    </span>
                  )}
                </button>
              </li>
            ))}
          </ul>
        </nav>

        <div className="sidebar-footer">
          <button className="logout-btn">
            üö™ D√©connexion
          </button>
        </div>
      </aside>

      <main className="dashboard-content">
        <div className="content-header">
          <h2>{onglets.find(o => o.id === ongletActif)?.nom || 'Page'}</h2>
          {notificationsUrgentes > 0 && (
            <div className="alert-banner">
              ‚ö†Ô∏è {notificationsUrgentes} notification(s) urgente(s)
            </div>
          )}
        </div>

        <div className="content-body">
          {renderContenu()}
        </div>
      </main>

      {/* Overlay pour mobile */}
      {sidebarOuverte && (
        <div
          className="sidebar-overlay"
          onClick={() => setSidebarOuverte(false)}
        />
      )}
    </div>
  )
}

// Composants helpers
function EcranConnexion() {
  return (
    <div className="login-screen">
      <div className="login-card">
        <h2>üîê Acc√®s restreint</h2>
        <p>Veuillez vous connecter pour acc√©der au dashboard</p>
        <button className="login-btn">Se connecter</button>
      </div>
    </div>
  )
}

function AccesDenie({ message }) {
  return (
    <div className="access-denied">
      <h3>‚õî Acc√®s refus√©</h3>
      <p>{message}</p>
      <button onClick={() => window.history.back()}>
        ‚Üê Retour
      </button>
    </div>
  )
}

function Page404() {
  return (
    <div className="not-found">
      <h2>404 - Page non trouv√©e</h2>
      <p>Cette section n'existe pas ou plus.</p>
    </div>
  )
}
```

---

## Rendu Conditionnel - Techniques Avanc√©es

### 1. Early Return Pattern

```jsx
function UserProfile({ user, loading, error }) {
  // Early returns pour g√©rer les cas d'erreur rapidement
  if (loading) {
    return <LoadingSpinner message="Chargement du profil..." />
  }

  if (error) {
    return <ErrorMessage error={error} retry={() => window.location.reload()} />
  }

  if (!user) {
    return <EmptyState message="Aucun utilisateur trouv√©" />
  }

  // Code principal seulement si tout va bien
  return (
    <div className="user-profile">
      <h1>Profil de {user.name}</h1>
      {/* ... reste du composant */}
    </div>
  )
}
```

### 2. Switch/Case avec JSX

```jsx
function StatusBadge({ status, user }) {
  const renderStatusBadge = () => {
    switch (status) {
      case 'online':
        return <span className="status online">üü¢ En ligne</span>
      case 'offline':
        return <span className="status offline">üî¥ Hors ligne</span>
      case 'away':
        return <span className="status away">üü° Absent</span>
      case 'busy':
        return <span className="status busy">üî¥ Occup√©</span>
      default:
        return <span className="status unknown">‚ùì Inconnu</span>
    }
  }

  return (
    <div className="user-status">
      <img src={user.avatar} alt={user.name} />
      <span>{user.name}</span>
      {renderStatusBadge()}
    </div>
  )
}
```

### 3. Rendu conditionnel avec logique complexe

```jsx
function ArticleCard({ article, user, permissions }) {
  const canEdit = permissions.canEdit && (user.id === article.authorId || user.role === 'admin')
  const canDelete = permissions.canDelete && user.role === 'admin'
  const isOwner = user.id === article.authorId
  const isPublished = article.status === 'published'

  return (
    <article className="article-card">
      <h2>{article.title}</h2>

      {/* Badge de statut */}
      {isPublished ? (
        <span className="badge published">‚úÖ Publi√©</span>
      ) : (
        <span className="badge draft">üìù Brouillon</span>
      )}

      <p>{article.excerpt}</p>

      {/* Actions conditionnelles */}
      <div className="article-actions">
        <button>üëÅÔ∏è Lire</button>

        {canEdit && (
          <button className="edit-btn">‚úèÔ∏è Modifier</button>
        )}

        {isOwner && !isPublished && (
          <button className="publish-btn">üöÄ Publier</button>
        )}

        {canDelete && (
          <button className="delete-btn">üóëÔ∏è Supprimer</button>
        )}
      </div>

      {/* Infos d'auteur */}
      <footer className="article-footer">
        <span>Par {article.author}</span>
        {isOwner && <span className="owner-badge">üëë Votre article</span>}
        <time>{new Date(article.createdAt).toLocaleDateString()}</time>
      </footer>
    </article>
  )
}
```

---

## Performance et Bonnes Pratiques

### 1. √âviter les re-renders inutiles

```jsx
// ‚ùå Mauvais - objet cr√©√© √† chaque render
function BadExample() {
  const [user, setUser] = useState({ name: '', email: '' })

  return (
    <UserForm
      user={user}
      style={{ margin: '20px' }}  // ‚ùå Nouvel objet √† chaque render
      onSubmit={() => {           // ‚ùå Nouvelle fonction √† chaque render
        console.log('Submit')
      }}
    />
  )
}

// ‚úÖ Bon - objets stables
function GoodExample() {
  const [user, setUser] = useState({ name: '', email: '' })

  // Style stable
  const formStyle = { margin: '20px' }

  // Fonction stable
  const handleSubmit = useCallback(() => {
    console.log('Submit')
  }, [])

  return (
    <UserForm
      user={user}
      style={formStyle}
      onSubmit={handleSubmit}
    />
  )
}
```

### 2. Gestion d'√©tat complexe

```jsx
function useFormState(initialData) {
  const [data, setData] = useState(initialData)
  const [errors, setErrors] = useState({})
  const [touched, setTouched] = useState({})

  const updateField = useCallback((field, value) => {
    setData(prev => ({ ...prev, [field]: value }))

    // Marquer comme touch√©
    setTouched(prev => ({ ...prev, [field]: true }))

    // Valider le champ
    if (touched[field]) {
      validateField(field, value)
    }
  }, [touched])

  const validateField = useCallback((field, value) => {
    // Logique de validation...
    setErrors(prev => ({ ...prev, [field]: error }))
  }, [])

  return {
    data,
    errors,
    touched,
    updateField,
    isValid: Object.keys(errors).length === 0
  }
}
```

---

## Points Cl√©s √† Retenir

1. **Composants Fonctionnels** = standard moderne React (depuis 2019)
2. **useState** = m√©moire du composant, suit des r√®gles strictes
3. **Props** = communication unidirectionnelle parent ‚Üí enfant
4. **Hooks uniquement au top level** = r√®gle NON-N√âGOCIABLE
5. **Early returns** = pattern pour g√©rer les cas d'erreur
6. **State isolation** = chaque instance a son √©tat priv√©
7. **Rendu conditionnel** = if/else, ternaire, &&, switch/case
8. **Performance** = √©viter les re-renders inutiles

---

## Ressources Compl√©mentaires

- üéØ [Composants React officiels](https://react.dev/reference/react/Component)
- üìö [Votre premier composant](https://react.dev/learn/your-first-component)
- üîß [Passer des props](https://react.dev/learn/passing-props-to-a-component)
- üíæ [State = m√©moire du composant](https://react.dev/learn/state-a-components-memory)
- üîÄ [Rendu conditionnel](https://react.dev/learn/conditional-rendering)
- üìñ [Thinking in React](https://react.dev/learn/thinking-in-react)

**Prochaine √©tape :** Les hooks avanc√©s (useEffect, useContext, useMemo...) dans `15.0.4-Hooks.md` !
