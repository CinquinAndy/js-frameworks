# React - useEffect : Effets de Bord

**useEffect** = Le hook des **effets de bord** ! 🔄

C'est lui qui va te permettre d'exécuter du code quand ton composant **se monte**, **se met à jour** ou **se démonte**. API calls, timers, subscriptions... tout se passe ici !

---

## Comprendre useEffect

### Qu'est-ce qu'un "Effet de Bord" ?

Un effet de bord, c'est **toute action** qui sort du cadre du rendu pur :

- 🌐 **API calls** : fetch des données
- ⏰ **Timers** : setTimeout, setInterval
- 🔌 **Subscriptions** : websockets, event listeners
- 💾 **localStorage** : sauvegarder des données
- 📊 **Analytics** : tracking d'événements
- 🎯 **DOM manipulation** : focus, scroll

### Cycle de Vie Simplifié

```jsx
import { useState, useEffect } from 'react'

function LifecycleWithUseEffect() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')

  // 🎬 Équivalent componentDidMount + componentDidUpdate
  useEffect(() => {
    console.log('🔄 Composant monté OU mis à jour')
    document.title = `Count: ${count}`
  }) // ← Pas de tableau = à chaque rendu !

  // 🎬 Équivalent componentDidMount seulement
  useEffect(() => {
    console.log('🎬 Composant monté (UNE SEULE FOIS)')
    
    // 💀 Cleanup = componentWillUnmount
    return () => {
      console.log('💀 Cleanup avant démontage')
    }
  }, []) // ← Tableau vide = une seule fois !

  // 🎯 Effet spécifique à count
  useEffect(() => {
    console.log('📊 Count a changé:', count)
    
    if (count > 10) {
      alert('Count dépasse 10 !')
    }
  }, [count]) // ← Se déclenche quand count change !

  // 👤 Effet spécifique à name
  useEffect(() => {
    console.log('👤 Name a changé:', name)
    
    if (name.length > 0) {
      localStorage.setItem('userName', name)
    }
  }, [name]) // ← Se déclenche quand name change !

  return (
    <div>
      <h3>Count: {count}</h3>
      <button onClick={() => setCount(count + 1)}>+1</button>

      <input
        value={name}
        onChange={e => setName(e.target.value)}
        placeholder="Votre nom..."
      />
    </div>
  )
}
```

---

## Patterns Courants avec useEffect

### 1. Fetch de Données

```jsx
function DataFetching({ userId }) {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  useEffect(() => {
    // Fonction async à l'intérieur de useEffect
    const fetchData = async () => {
      try {
        setLoading(true)
        setError(null)
        
        const response = await fetch(`/api/users/${userId}`)
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`)
        }
        
        const result = await response.json()
        setData(result)
      } catch (err) {
        setError(err.message)
        setData(null)
      } finally {
        setLoading(false)
      }
    }

    // Appel de la fonction
    fetchData()
  }, [userId]) // ← Re-fetch si userId change !

  // Gestion des états
  if (loading) return <div>Chargement...</div>
  if (error) return <div>Erreur: {error}</div>
  if (!data) return <div>Aucune donnée</div>

  return (
    <div>
      <h3>Utilisateur: {data.name}</h3>
      <p>Email: {data.email}</p>
      <p>ID: {data.id}</p>
    </div>
  )
}

// Utilisation
function App() {
  const [selectedUserId, setSelectedUserId] = useState(1)

  return (
    <div>
      <div>
        <button onClick={() => setSelectedUserId(1)}>User 1</button>
        <button onClick={() => setSelectedUserId(2)}>User 2</button>
        <button onClick={() => setSelectedUserId(3)}>User 3</button>
      </div>
      
      <DataFetching userId={selectedUserId} />
    </div>
  )
}
```

### 2. Timers et Intervalles

```jsx
function TimersExample() {
  const [seconds, setSeconds] = useState(0)
  const [isRunning, setIsRunning] = useState(false)
  const [countdown, setCountdown] = useState(10)

  // Chronomètre
  useEffect(() => {
    let interval = null
    
    if (isRunning) {
      interval = setInterval(() => {
        setSeconds(prevSeconds => prevSeconds + 1)
      }, 1000)
    }

    // ⚠️ Cleanup CRUCIAL pour éviter les fuites mémoire
    return () => {
      if (interval) {
        clearInterval(interval)
        console.log('🧹 Timer nettoyé')
      }
    }
  }, [isRunning])

  // Countdown avec auto-stop
  useEffect(() => {
    if (countdown > 0) {
      const timer = setTimeout(() => {
        setCountdown(prev => prev - 1)
      }, 1000)

      // Cleanup du timeout
      return () => clearTimeout(timer)
    } else if (countdown === 0) {
      alert('🚨 Temps écoulé !')
    }
  }, [countdown])

  // Notification périodique
  useEffect(() => {
    const notificationInterval = setInterval(() => {
      console.log(`💡 App en cours depuis ${seconds} secondes`)
    }, 30000) // Toutes les 30 secondes

    return () => clearInterval(notificationInterval)
  }, [seconds])

  const formatTime = (totalSeconds) => {
    const mins = Math.floor(totalSeconds / 60)
    const secs = totalSeconds % 60
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
  }

  return (
    <div>
      <h3>Chronomètre: {formatTime(seconds)}</h3>
      <div>
        <button onClick={() => setIsRunning(!isRunning)}>
          {isRunning ? '⏸️ Pause' : '▶️ Start'}
        </button>
        <button onClick={() => {
          setSeconds(0)
          setIsRunning(false)
        }}>
          🔄 Reset
        </button>
      </div>

      <h3>Countdown: {countdown}s</h3>
      <button onClick={() => setCountdown(10)}>
        Reset Countdown
      </button>
    </div>
  )
}
```

### 3. Event Listeners

```jsx
function EventListenersExample() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  })
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })
  const [keyPressed, setKeyPressed] = useState('')
  const [isOnline, setIsOnline] = useState(navigator.onLine)

  // Resize listener
  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      })
    }

    window.addEventListener('resize', handleResize)
    
    // ⚠️ Cleanup obligatoire !
    return () => {
      window.removeEventListener('resize', handleResize)
    }
  }, [])

  // Mouse listener
  useEffect(() => {
    const handleMouseMove = (event) => {
      setMousePosition({
        x: event.clientX,
        y: event.clientY
      })
    }

    document.addEventListener('mousemove', handleMouseMove)
    
    return () => {
      document.removeEventListener('mousemove', handleMouseMove)
    }
  }, [])

  // Keyboard listener
  useEffect(() => {
    const handleKeyPress = (event) => {
      setKeyPressed(event.key)
      // Clear après 2 secondes
      setTimeout(() => setKeyPressed(''), 2000)
    }

    window.addEventListener('keydown', handleKeyPress)
    
    return () => {
      window.removeEventListener('keydown', handleKeyPress)
    }
  }, [])

  // Online/Offline listener
  useEffect(() => {
    const handleOnline = () => setIsOnline(true)
    const handleOffline = () => setIsOnline(false)

    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)
    
    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])

  return (
    <div>
      <h3>Event Listeners Demo</h3>
      
      <div>
        <p>📐 Taille fenêtre: {windowSize.width}x{windowSize.height}</p>
        <p>🖱️ Position souris: ({mousePosition.x}, {mousePosition.y})</p>
        <p>⌨️ Dernière touche: {keyPressed || 'Aucune'}</p>
        <p>🌐 Connexion: {isOnline ? '✅ En ligne' : '❌ Hors ligne'}</p>
      </div>
    </div>
  )
}
```

### 4. WebSocket et Subscriptions

```jsx
function WebSocketExample({ roomId }) {
  const [messages, setMessages] = useState([])
  const [isConnected, setIsConnected] = useState(false)
  const [newMessage, setNewMessage] = useState('')

  useEffect(() => {
    // Créer la connexion WebSocket
    const ws = new WebSocket(`ws://localhost:8080/room/${roomId}`)
    
    ws.onopen = () => {
      console.log('🔌 WebSocket connecté')
      setIsConnected(true)
    }
    
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data)
      console.log('📧 Message reçu:', message)
      
      setMessages(prevMessages => [
        ...prevMessages,
        {
          id: Date.now(),
          ...message,
          timestamp: new Date().toLocaleTimeString()
        }
      ])
    }
    
    ws.onerror = (error) => {
      console.error('❌ Erreur WebSocket:', error)
    }
    
    ws.onclose = () => {
      console.log('🔌 WebSocket fermé')
      setIsConnected(false)
    }

    // ⚠️ Cleanup ESSENTIEL !
    return () => {
      console.log('🧹 Fermeture WebSocket')
      ws.close()
    }
  }, [roomId]) // ← Reconnect si roomId change !

  const sendMessage = () => {
    if (newMessage.trim() && isConnected) {
      const ws = new WebSocket(`ws://localhost:8080/room/${roomId}`)
      ws.send(JSON.stringify({
        type: 'message',
        content: newMessage,
        user: 'User123'
      }))
      setNewMessage('')
    }
  }

  return (
    <div>
      <h3>Chat Room: {roomId}</h3>
      <p>État: {isConnected ? '🟢 Connecté' : '🔴 Déconnecté'}</p>
      
      <div style={{ 
        height: '200px', 
        overflow: 'auto', 
        border: '1px solid #ccc', 
        padding: '10px' 
      }}>
        {messages.map(message => (
          <div key={message.id}>
            <strong>[{message.timestamp}] {message.user}:</strong> {message.content}
          </div>
        ))}
      </div>

      <div>
        <input
          value={newMessage}
          onChange={e => setNewMessage(e.target.value)}
          onKeyDown={e => e.key === 'Enter' && sendMessage()}
          placeholder="Tapez votre message..."
          disabled={!isConnected}
        />
        <button onClick={sendMessage} disabled={!isConnected}>
          Envoyer
        </button>
      </div>
    </div>
  )
}
```

---

## Dépendances et Optimisations

### Le Tableau des Dépendances

```jsx
function DependenciesExample({ userId, filter }) {
  const [userData, setUserData] = useState(null)
  const [posts, setPosts] = useState([])

  // ❌ MAUVAIS - Dépendances manquantes
  useEffect(() => {
    fetchUser(userId).then(setUserData) // userId utilisé mais pas dans les deps !
  }, []) // ← ESLint va crier ! 🚨

  // ✅ BON - Toutes les dépendances
  useEffect(() => {
    fetchUser(userId).then(setUserData)
  }, [userId]) // ← userId dans les dépendances ✅

  // ❌ PROBLÈME - Objet recréé à chaque rendu
  useEffect(() => {
    const options = { filter, sort: 'date' } // ← Nouvel objet à chaque fois !
    fetchPosts(userId, options).then(setPosts)
  }, [userId, options]) // ← `options` change toujours ! 💥

  // ✅ SOLUTION 1 - Dépendances primitives
  useEffect(() => {
    const options = { filter, sort: 'date' }
    fetchPosts(userId, options).then(setPosts)
  }, [userId, filter]) // ← Seulement les valeurs primitives ✅

  // ✅ SOLUTION 2 - Créer l'objet dans l'effet
  useEffect(() => {
    const fetchData = async () => {
      const options = { filter, sort: 'date' }
      const data = await fetchPosts(userId, options)
      setPosts(data)
    }

    fetchData()
  }, [userId, filter]) // ← Clean et optimisé ✅

  return (
    <div>
      {userData && <h2>{userData.name}</h2>}
      <ul>
        {posts.map(post => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  )
}
```

### Éviter les Re-renders Inutiles

```jsx
function OptimizedEffects() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')
  const [theme, setTheme] = useState('light')

  // ❌ MAUVAIS - Effect qui run trop souvent
  useEffect(() => {
    console.log('😱 Cet effet run à CHAQUE rendu !')
    // Pas de tableau de dépendances
  })

  // ❌ MAUVAIS - Dépendances inutiles
  useEffect(() => {
    console.log('📊 Count mis à jour:', count)
  }, [count, name, theme]) // ← name et theme pas nécessaires !

  // ✅ BON - Seulement les dépendances nécessaires
  useEffect(() => {
    console.log('📊 Count mis à jour:', count)
  }, [count]) // ← Seulement count ✅

  // ✅ BON - Effects séparés pour des responsabilités différentes
  useEffect(() => {
    document.title = `Count: ${count}`
  }, [count])

  useEffect(() => {
    localStorage.setItem('userName', name)
  }, [name])

  useEffect(() => {
    document.body.className = theme
  }, [theme])

  return (
    <div>
      <input
        value={name}
        onChange={e => setName(e.target.value)}
        placeholder="Nom"
      />
      <button onClick={() => setCount(c => c + 1)}>
        Count: {count}
      </button>
      <button onClick={() => setTheme(t => t === 'light' ? 'dark' : 'light')}>
        Thème: {theme}
      </button>
    </div>
  )
}
```

### Cancel Previous Requests (Race Conditions)

```jsx
function SearchWithCancel() {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState([])
  const [isLoading, setIsLoading] = useState(false)

  useEffect(() => {
    if (!query.trim()) {
      setResults([])
      return
    }

    // AbortController pour annuler la requête précédente
    const abortController = new AbortController()
    
    const searchData = async () => {
      setIsLoading(true)
      
      try {
        const response = await fetch(`/api/search?q=${encodeURIComponent(query)}`, {
          signal: abortController.signal // ← Signal d'abort
        })
        
        if (!response.ok) throw new Error('Search failed')
        
        const data = await response.json()
        
        // ✅ Vérifier si la requête n'a pas été annulée
        if (!abortController.signal.aborted) {
          setResults(data.results)
        }
      } catch (error) {
        // ✅ Ignorer les erreurs d'abort
        if (error.name !== 'AbortError') {
          console.error('Search error:', error)
          setResults([])
        }
      } finally {
        // ✅ Vérifier avant de mettre à jour l'état
        if (!abortController.signal.aborted) {
          setIsLoading(false)
        }
      }
    }

    // Débounce de 300ms
    const debounceTimer = setTimeout(searchData, 300)

    // ⚠️ Cleanup : annuler requête ET timer
    return () => {
      clearTimeout(debounceTimer)
      abortController.abort()
    }
  }, [query])

  return (
    <div>
      <h3>Recherche avec Cancel</h3>
      
      <input
        value={query}
        onChange={e => setQuery(e.target.value)}
        placeholder="Rechercher..."
      />
      
      {isLoading && <p>🔍 Recherche en cours...</p>}
      
      <ul>
        {results.map((result, index) => (
          <li key={index}>{result.title}</li>
        ))}
      </ul>
    </div>
  )
}
```

---

## Custom Hooks avec useEffect

### useApi Hook

```jsx
function useApi(url, options = {}) {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  const fetchData = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)

      const response = await fetch(url, {
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        },
        ...options
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const result = await response.json()
      setData(result)
    } catch (err) {
      setError(err.message)
    } finally {
      setLoading(false)
    }
  }, [url, options])

  useEffect(() => {
    fetchData()
  }, [fetchData])

  const refetch = useCallback(() => {
    fetchData()
  }, [fetchData])

  return { data, loading, error, refetch }
}

// Utilisation
function UserProfile({ userId }) {
  const { data: user, loading, error, refetch } = useApi(`/api/users/${userId}`)

  if (loading) return <div>Chargement...</div>
  if (error) return <div>Erreur: {error} <button onClick={refetch}>Retry</button></div>

  return (
    <div>
      <h3>{user?.name}</h3>
      <p>{user?.email}</p>
      <button onClick={refetch}>🔄 Rafraîchir</button>
    </div>
  )
}
```

### useInterval Hook

```jsx
function useInterval(callback, delay) {
  const savedCallback = useRef()

  // Se souvenir du callback le plus récent
  useEffect(() => {
    savedCallback.current = callback
  }, [callback])

  // Configurer l'interval
  useEffect(() => {
    if (delay !== null) {
      const interval = setInterval(() => savedCallback.current(), delay)
      return () => clearInterval(interval)
    }
  }, [delay])
}

// Utilisation
function IntervalExample() {
  const [count, setCount] = useState(0)
  const [isRunning, setIsRunning] = useState(true)

  useInterval(
    () => setCount(count => count + 1),
    isRunning ? 1000 : null // ← null = pause l'interval
  )

  return (
    <div>
      <h3>Count: {count}</h3>
      <button onClick={() => setIsRunning(!isRunning)}>
        {isRunning ? 'Pause' : 'Start'}
      </button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  )
}
```

### useLocalStorage Hook

```jsx
function useLocalStorage(key, initialValue) {
  // State pour stocker notre valeur
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error)
      return initialValue
    }
  })

  // Fonction pour sauvegarder en localStorage ET mettre à jour l'état
  const setValue = (value) => {
    try {
      setStoredValue(value)
      window.localStorage.setItem(key, JSON.stringify(value))
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error)
    }
  }

  // Écouter les changements de localStorage depuis d'autres onglets
  useEffect(() => {
    const handleStorageChange = (e) => {
      if (e.key === key && e.newValue !== null) {
        try {
          setStoredValue(JSON.parse(e.newValue))
        } catch (error) {
          console.error(`Error parsing localStorage key "${key}":`, error)
        }
      }
    }

    window.addEventListener('storage', handleStorageChange)
    return () => window.removeEventListener('storage', handleStorageChange)
  }, [key])

  return [storedValue, setValue]
}

// Utilisation
function SettingsPanel() {
  const [theme, setTheme] = useLocalStorage('theme', 'light')
  const [name, setName] = useLocalStorage('userName', '')

  return (
    <div>
      <h3>Paramètres Persistants</h3>
      
      <div>
        <label>
          Nom:
          <input
            value={name}
            onChange={e => setName(e.target.value)}
          />
        </label>
      </div>

      <div>
        <label>
          <input
            type="checkbox"
            checked={theme === 'dark'}
            onChange={e => setTheme(e.target.checked ? 'dark' : 'light')}
          />
          Mode sombre
        </label>
      </div>

      <p>Thème actuel: {theme}</p>
      <p>Nom sauvegardé: {name}</p>
    </div>
  )
}
```

---

## Erreurs Communes à Éviter

### 1. Async dans useEffect

```jsx
// ❌ MAUVAIS - useEffect async directement
useEffect(async () => {
  const data = await fetch('/api/data')
  setData(data)
}, [])

// ✅ BON - Fonction async à l'intérieur
useEffect(() => {
  const fetchData = async () => {
    const data = await fetch('/api/data')
    setData(data)
  }
  
  fetchData()
}, [])
```

### 2. Oublier le Cleanup

```jsx
// ❌ MAUVAIS - Pas de cleanup
useEffect(() => {
  const timer = setInterval(() => {
    console.log('Timer tick')
  }, 1000)
  // ❌ Fuite mémoire garantie !
}, [])

// ✅ BON - Avec cleanup
useEffect(() => {
  const timer = setInterval(() => {
    console.log('Timer tick')
  }, 1000)
  
  return () => clearInterval(timer) // ✅ Cleanup
}, [])
```

### 3. Infinite Loop

```jsx
// ❌ MAUVAIS - Boucle infinie
const [user, setUser] = useState({})

useEffect(() => {
  setUser({ ...user, lastUpdated: Date.now() })
}, [user]) // ❌ user change à chaque fois !

// ✅ BON - Condition ou dépendances correctes
useEffect(() => {
  if (!user.lastUpdated) {
    setUser(prev => ({ ...prev, lastUpdated: Date.now() }))
  }
}, [user.lastUpdated])
```

---

## Points Clés à Retenir

1. **useEffect** = hook pour les effets de bord
2. **Tableau vide []** = une seule fois (componentDidMount)
3. **Pas de tableau** = à chaque rendu (dangereux !)
4. **Dépendances** = variables utilisées dans l'effet
5. **Cleanup function** = return dans useEffect (essentiel !)
6. **Async/await** = fonction interne, pas directement dans useEffect
7. **Race conditions** = utiliser AbortController
8. **Custom hooks** = réutiliser la logique d'effets

---

## Ressources Pour Aller Plus Loin

- 📚 [useEffect Documentation](https://react.dev/reference/react/useEffect)
- 🎯 [useEffect Complete Guide](https://overreacted.io/a-complete-guide-to-useeffect/)
- 💡 [Common useEffect Mistakes](https://react.dev/learn/synchronizing-with-effects)
- 🔄 [Effect Dependencies](https://react.dev/learn/removing-effect-dependencies)

