# React State Management - G√©rer l'√©tat comme un pro

Salut ! Maintenant qu'on ma√Ætrise les composants, hooks et routing, on va s'attaquer √† un sujet **crucial** : la **gestion d'√©tat** !

Quand ton app grandit, g√©rer l'√©tat avec juste `useState` devient vite le chaos. On va voir comment **structurer** et **partager** l'√©tat efficacement.

---

## Le probl√®me de la gestion d'√©tat

### Qu'est-ce que l'√©tat (state) ?

L'**√©tat**, c'est toutes les **donn√©es** qui peuvent changer dans ton application :

- Donn√©es utilisateur (profil, pr√©f√©rences)
- √âtat de l'interface (modales ouvertes, loading)
- Donn√©es m√©tier (produits, commandes)
- Cache d'API

### Les probl√®mes qui arrivent

Avec `useState` seul, tu vas vite avoir ces probl√®mes :

```jsx
// ‚ùå Probl√®me : Prop Drilling
function App() {
  const [user, setUser] = useState(null)
  const [cart, setCart] = useState([])
  const [theme, setTheme] = useState('light')

  return (
    <Header user={user} theme={theme} setTheme={setTheme} />
    <ProductList cart={cart} setCart={setCart} user={user} />
    <Footer theme={theme} />
  )
}

function Header({ user, theme, setTheme }) {
  return (
    <header>
      <UserProfile user={user} />
      <ThemeToggle theme={theme} setTheme={setTheme} />
    </header>
  )
}

// Tu passes les props sur 5 niveaux... üò±
```

### Les solutions qu'on va voir

1. **Context API** ‚Üí pour partager l'√©tat sans prop drilling
2. **Zustand** ‚Üí state manager simple et moderne
3. **Redux Toolkit** ‚Üí pour les grosses apps complexes
4. **Jotai** ‚Üí approche atomique
5. **TanStack Query** ‚Üí pour les donn√©es serveur

---

## Context API - La solution native React

### Concept de base

Le **Context API** permet de partager des donn√©es dans toute l'app sans les passer en props.

```jsx
// 1. Cr√©er un Context
const UserContext = createContext()

// 2. Fournir les donn√©es (Provider)
function App() {
  const [user, setUser] = useState(null)

  return (
    <UserContext.Provider value={{ user, setUser }}>
      <Header />
      <MainContent />
    </UserContext.Provider>
  )
}

// 3. Consommer les donn√©es
function Header() {
  const { user } = useContext(UserContext)

  return <h1>Salut {user?.name}!</h1>
}
```

### Exemple complet : Theme Provider

```jsx
import { createContext, useContext, useState } from 'react'

// 1. Cr√©er le Context
const ThemeContext = createContext()

// 2. Hook personnalis√© pour utiliser le context
export function useTheme() {
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error('useTheme doit √™tre utilis√© dans ThemeProvider')
  }
  return context
}

// 3. Provider Component
export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light')

  const toggleTheme = () => {
    setTheme(theme === 'light' ? 'dark' : 'light')
  }

  const value = {
    theme,
    setTheme,
    toggleTheme,
    isDark: theme === 'dark'
  }

  return (
    <ThemeContext.Provider value={value}>
      <div className={`app theme-${theme}`}>
        {children}
      </div>
    </ThemeContext.Provider>
  )
}

// 4. Utilisation dans les composants
function ThemeToggle() {
  const { theme, toggleTheme } = useTheme()

  return (
    <button onClick={toggleTheme}>
      {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
      Passer en mode {theme === 'light' ? 'sombre' : 'clair'}
    </button>
  )
}

function Header() {
  const { isDark } = useTheme()

  return (
    <header className={isDark ? 'header-dark' : 'header-light'}>
      <h1>Mon App</h1>
      <ThemeToggle />
    </header>
  )
}

// 5. Setup dans App.jsx
function App() {
  return (
    <ThemeProvider>
      <Header />
      <MainContent />
    </ThemeProvider>
  )
}
```

### Context multiple avec composition

```jsx
// Auth Context
const AuthContext = createContext()

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null)
  const [isLoading, setIsLoading] = useState(false)

  const login = async (email, password) => {
    setIsLoading(true)
    try {
      // Appel API
      const userData = await api.login(email, password)
      setUser(userData)
    } catch (error) {
      throw error
    } finally {
      setIsLoading(false)
    }
  }

  const logout = () => {
    setUser(null)
    localStorage.removeItem('token')
  }

  return (
    <AuthContext.Provider value={{
      user,
      login,
      logout,
      isLoading,
      isAuthenticated: !!user
    }}>
      {children}
    </AuthContext.Provider>
  )
}

// Cart Context
const CartContext = createContext()

export function CartProvider({ children }) {
  const [items, setItems] = useState([])

  const addItem = (product) => {
    setItems(prev => {
      const existing = prev.find(item => item.id === product.id)
      if (existing) {
        return prev.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        )
      }
      return [...prev, { ...product, quantity: 1 }]
    })
  }

  const removeItem = (productId) => {
    setItems(prev => prev.filter(item => item.id !== productId))
  }

  const updateQuantity = (productId, quantity) => {
    if (quantity <= 0) {
      removeItem(productId)
      return
    }

    setItems(prev =>
      prev.map(item =>
        item.id === productId
          ? { ...item, quantity }
          : item
      )
    )
  }

  const total = items.reduce((sum, item) => sum + (item.price * item.quantity), 0)

  return (
    <CartContext.Provider value={{
      items,
      addItem,
      removeItem,
      updateQuantity,
      total,
      itemCount: items.reduce((sum, item) => sum + item.quantity, 0)
    }}>
      {children}
    </CartContext.Provider>
  )
}

// Composition des providers
function App() {
  return (
    <AuthProvider>
      <ThemeProvider>
        <CartProvider>
          <Router>
            <Layout />
          </Router>
        </CartProvider>
      </ThemeProvider>
    </AuthProvider>
  )
}
```

### Hooks personnalis√©s pour les contexts

```jsx
// hooks/useAuth.js
export function useAuth() {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth doit √™tre utilis√© dans AuthProvider')
  }
  return context
}

// hooks/useCart.js
export function useCart() {
  const context = useContext(CartContext)
  if (!context) {
    throw new Error('useCart doit √™tre utilis√© dans CartProvider')
  }
  return context
}

// Utilisation simplifi√©e
function ProductCard({ product }) {
  const { addItem } = useCart()
  const { isAuthenticated } = useAuth()

  const handleAddToCart = () => {
    if (!isAuthenticated) {
      alert('Connectez-vous pour ajouter au panier')
      return
    }
    addItem(product)
  }

  return (
    <div className="product-card">
      <h3>{product.name}</h3>
      <p>{product.price}‚Ç¨</p>
      <button onClick={handleAddToCart}>
        Ajouter au panier
      </button>
    </div>
  )
}
```

---

## Zustand - State manager moderne et simple

### Pourquoi Zustand ?

**Zustand** (= "√©tat" en allemand) est un state manager **ultra simple** et **performant** :

- üì¶ **Tiny** : 2.5kb gzipp√©
- üöÄ **Rapide** : pas de providers n√©cessaires
- üîß **Simple** : API minimaliste
- üéØ **TypeScript** natif

### Installation

```bash
npm install zustand
```

### Store basique

```jsx
import { create } from 'zustand'

// Cr√©er un store
const useCounterStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 })
}))

// Utiliser le store (n'importe o√π dans l'app)
function Counter() {
  const { count, increment, decrement, reset } = useCounterStore()

  return (
    <div>
      <h2>Compteur: {count}</h2>
      <button onClick={increment}>+1</button>
      <button onClick={decrement}>-1</button>
      <button onClick={reset}>Reset</button>
    </div>
  )
}

// Dans un autre composant (pas besoin de provider!)
function CounterDisplay() {
  const count = useCounterStore((state) => state.count)

  return <p>Valeur actuelle: {count}</p>
}
```

### Store complexe : E-commerce

```jsx
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'

// Interface pour TypeScript (optionnel)
interface Product {
  id: string
  name: string
  price: number
  image: string
}

interface CartItem extends Product {
  quantity: number
}

interface CartStore {
  items: CartItem[]
  isOpen: boolean
  addItem: (product: Product) => void
  removeItem: (productId: string) => void
  updateQuantity: (productId: string, quantity: number) => void
  clearCart: () => void
  toggleCart: () => void
  total: number
  itemCount: number
}

// Store avec middleware
const useCartStore = create<CartStore>()(
  devtools(
    persist(
      (set, get) => ({
        items: [],
        isOpen: false,

        addItem: (product) => set((state) => {
          const existingItem = state.items.find(item => item.id === product.id)

          if (existingItem) {
            return {
              items: state.items.map(item =>
                item.id === product.id
                  ? { ...item, quantity: item.quantity + 1 }
                  : item
              )
            }
          } else {
            return {
              items: [...state.items, { ...product, quantity: 1 }]
            }
          }
        }),

        removeItem: (productId) => set((state) => ({
          items: state.items.filter(item => item.id !== productId)
        })),

        updateQuantity: (productId, quantity) => set((state) => {
          if (quantity <= 0) {
            return {
              items: state.items.filter(item => item.id !== productId)
            }
          }

          return {
            items: state.items.map(item =>
              item.id === productId
                ? { ...item, quantity }
                : item
            )
          }
        }),

        clearCart: () => set({ items: [] }),

        toggleCart: () => set((state) => ({ isOpen: !state.isOpen })),

        // Computed values
        get total() {
          return get().items.reduce((sum, item) => sum + (item.price * item.quantity), 0)
        },

        get itemCount() {
          return get().items.reduce((sum, item) => sum + item.quantity, 0)
        }
      }),
      {
        name: 'cart-storage', // Cl√© localStorage
        partialize: (state) => ({ items: state.items }) // Ne persister que les items
      }
    ),
    { name: 'cart-store' } // Nom pour Redux DevTools
  )
)

// Utilisation dans les composants
function ProductCard({ product }) {
  const addItem = useCartStore((state) => state.addItem)

  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p>{product.price}‚Ç¨</p>
      <button onClick={() => addItem(product)}>
        Ajouter au panier
      </button>
    </div>
  )
}

function CartSummary() {
  const { itemCount, total, toggleCart } = useCartStore()

  return (
    <button onClick={toggleCart} className="cart-button">
      üõí {itemCount} articles - {total.toFixed(2)}‚Ç¨
    </button>
  )
}

function CartModal() {
  const { items, isOpen, removeItem, updateQuantity, clearCart, toggleCart } = useCartStore()

  if (!isOpen) return null

  return (
    <div className="cart-modal">
      <div className="cart-content">
        <div className="cart-header">
          <h2>Votre panier</h2>
          <button onClick={toggleCart}>‚ùå</button>
        </div>

        {items.length === 0 ? (
          <p>Votre panier est vide</p>
        ) : (
          <>
            {items.map(item => (
              <div key={item.id} className="cart-item">
                <img src={item.image} alt={item.name} />
                <div>
                  <h4>{item.name}</h4>
                  <p>{item.price}‚Ç¨</p>
                </div>
                <div className="quantity-controls">
                  <button onClick={() => updateQuantity(item.id, item.quantity - 1)}>
                    -
                  </button>
                  <span>{item.quantity}</span>
                  <button onClick={() => updateQuantity(item.id, item.quantity + 1)}>
                    +
                  </button>
                </div>
                <button onClick={() => removeItem(item.id)}>
                  üóëÔ∏è
                </button>
              </div>
            ))}
            <div className="cart-actions">
              <button onClick={clearCart} className="btn-secondary">
                Vider le panier
              </button>
              <button className="btn-primary">
                Commander ({total.toFixed(2)}‚Ç¨)
              </button>
            </div>
          </>
        )}
      </div>
    </div>
  )
}
```

### Store avec actions async

```jsx
const useProductStore = create((set, get) => ({
  products: [],
  isLoading: false,
  error: null,

  // Action synchrone
  setProducts: (products) => set({ products }),

  // Action asynchrone
  fetchProducts: async () => {
    set({ isLoading: true, error: null })

    try {
      const response = await fetch('/api/products')
      if (!response.ok) throw new Error('Erreur lors du chargement')

      const products = await response.json()
      set({ products, isLoading: false })
    } catch (error) {
      set({ error: error.message, isLoading: false })
    }
  },

  // Filtrer les produits
  searchProducts: (query) => {
    const { products } = get()
    return products.filter(product =>
      product.name.toLowerCase().includes(query.toLowerCase())
    )
  },

  // Trouver un produit
  getProductById: (id) => {
    const { products } = get()
    return products.find(product => product.id === id)
  }
}))

// Hook personnalis√© pour les produits filtr√©s
function useProductSearch(query = '') {
  return useProductStore((state) =>
    query ? state.searchProducts(query) : state.products
  )
}

// Utilisation
function ProductList() {
  const [searchQuery, setSearchQuery] = useState('')
  const { isLoading, error, fetchProducts } = useProductStore()
  const products = useProductSearch(searchQuery)

  useEffect(() => {
    fetchProducts()
  }, [])

  if (isLoading) return <div>Chargement...</div>
  if (error) return <div>Erreur: {error}</div>

  return (
    <div>
      <input
        type="text"
        placeholder="Rechercher un produit..."
        value={searchQuery}
        onChange={(e) => setSearchQuery(e.target.value)}
      />

      <div className="products-grid">
        {products.map(product => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>
    </div>
  )
}
```

### Slices (d√©couper le store)

```jsx
// Pour de gros stores, on peut d√©couper en slices

// authSlice.js
const createAuthSlice = (set, get) => ({
  user: null,
  token: null,
  isAuthenticated: false,

  login: async (email, password) => {
    try {
      const response = await api.login(email, password)
      set({
        user: response.user,
        token: response.token,
        isAuthenticated: true
      })
    } catch (error) {
      throw error
    }
  },

  logout: () => set({
    user: null,
    token: null,
    isAuthenticated: false
  })
})

// cartSlice.js
const createCartSlice = (set, get) => ({
  items: [],
  total: 0,

  addToCart: (product) => {
    // Logic...
  }
})

// Store principal
const useAppStore = create((set, get) => ({
  ...createAuthSlice(set, get),
  ...createCartSlice(set, get)
}))
```

---

## Redux Toolkit - Pour les grosses applications

### Quand utiliser Redux ?

Redux est utile pour :

- **Grosses √©quipes** (10+ d√©veloppeurs)
- **Apps tr√®s complexes** (100+ composants)
- **Logique m√©tier complexe** (machines √† √©tat)
- **Debug avanc√©** (time travel, replay)

### Installation

```bash
npm install @reduxjs/toolkit react-redux
```

### Store basique avec RTK

```jsx
// store/counterSlice.js
import { createSlice } from '@reduxjs/toolkit'

const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    value: 0
  },
  reducers: {
    increment: (state) => {
      state.value += 1  // Immer permet la mutation directe
    },
    decrement: (state) => {
      state.value -= 1
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload
    },
    reset: (state) => {
      state.value = 0
    }
  }
})

export const { increment, decrement, incrementByAmount, reset } = counterSlice.actions
export default counterSlice.reducer

// store/index.js
import { configureStore } from '@reduxjs/toolkit'
import counterReducer from './counterSlice'

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
})

// main.jsx
import { Provider } from 'react-redux'
import { store } from './store'

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
)

// Utilisation dans un composant
import { useSelector, useDispatch } from 'react-redux'
import { increment, decrement, reset } from './store/counterSlice'

function Counter() {
  const count = useSelector((state) => state.counter.value)
  const dispatch = useDispatch()

  return (
    <div>
      <h2>Compteur: {count}</h2>
      <button onClick={() => dispatch(increment())}>+1</button>
      <button onClick={() => dispatch(decrement())}>-1</button>
      <button onClick={() => dispatch(reset())}>Reset</button>
    </div>
  )
}
```

### RTK Query pour les appels API

```jsx
// api/productsApi.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

export const productsApi = createApi({
  reducerPath: 'productsApi',
  baseQuery: fetchBaseQuery({
    baseUrl: '/api/',
    prepareHeaders: (headers, { getState }) => {
      const token = getState().auth.token
      if (token) {
        headers.set('authorization', `Bearer ${token}`)
      }
      return headers
    }
  }),
  tagTypes: ['Product'],
  endpoints: (builder) => ({
    getProducts: builder.query({
      query: () => 'products',
      providesTags: ['Product']
    }),
    getProductById: builder.query({
      query: (id) => `products/${id}`,
      providesTags: (result, error, id) => [{ type: 'Product', id }]
    }),
    createProduct: builder.mutation({
      query: (newProduct) => ({
        url: 'products',
        method: 'POST',
        body: newProduct
      }),
      invalidatesTags: ['Product']
    }),
    updateProduct: builder.mutation({
      query: ({ id, ...patch }) => ({
        url: `products/${id}`,
        method: 'PATCH',
        body: patch
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'Product', id }]
    }),
    deleteProduct: builder.mutation({
      query: (id) => ({
        url: `products/${id}`,
        method: 'DELETE'
      }),
      invalidatesTags: ['Product']
    })
  })
})

export const {
  useGetProductsQuery,
  useGetProductByIdQuery,
  useCreateProductMutation,
  useUpdateProductMutation,
  useDeleteProductMutation
} = productsApi

// store/index.js
import { configureStore } from '@reduxjs/toolkit'
import { productsApi } from '../api/productsApi'

export const store = configureStore({
  reducer: {
    [productsApi.reducerPath]: productsApi.reducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(productsApi.middleware)
})

// Composant
function ProductList() {
  const { data: products, error, isLoading } = useGetProductsQuery()
  const [deleteProduct] = useDeleteProductMutation()

  if (isLoading) return <div>Chargement...</div>
  if (error) return <div>Erreur: {error.message}</div>

  return (
    <div className="products-grid">
      {products?.map(product => (
        <div key={product.id} className="product-card">
          <h3>{product.name}</h3>
          <p>{product.price}‚Ç¨</p>
          <button onClick={() => deleteProduct(product.id)}>
            Supprimer
          </button>
        </div>
      ))}
    </div>
  )
}
```

---

## Jotai - Approche atomique

### Concept des atomes

**Jotai** utilise des **atomes** : des petites unit√©s d'√©tat ind√©pendantes.

```bash
npm install jotai
```

```jsx
import { atom, useAtom } from 'jotai'

// Cr√©er des atomes
const countAtom = atom(0)
const nameAtom = atom('Andy')

function Counter() {
  const [count, setCount] = useAtom(countAtom)

  return (
    <div>
      <p>Compteur: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>+1</button>
    </div>
  )
}

function Greeting() {
  const [name, setName] = useAtom(nameAtom)

  return (
    <div>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Votre nom"
      />
      <p>Salut {name}!</p>
    </div>
  )
}
```

### Atomes d√©riv√©s

```jsx
import { atom, useAtom, useAtomValue } from 'jotai'

// Atomes de base
const firstNameAtom = atom('Andy')
const lastNameAtom = atom('Cin')

// Atome d√©riv√© (calcul√©)
const fullNameAtom = atom((get) => {
  const firstName = get(firstNameAtom)
  const lastName = get(lastNameAtom)
  return `${firstName} ${lastName}`
})

// Atome d√©riv√© avec setter
const upperCaseNameAtom = atom(
  (get) => get(fullNameAtom).toUpperCase(),
  (get, set, newValue) => {
    const [first, last] = newValue.split(' ')
    set(firstNameAtom, first)
    set(lastNameAtom, last)
  }
)

function NameForm() {
  const [firstName, setFirstName] = useAtom(firstNameAtom)
  const [lastName, setLastName] = useAtom(lastNameAtom)
  const fullName = useAtomValue(fullNameAtom)
  const [upperName, setUpperName] = useAtom(upperCaseNameAtom)

  return (
    <div>
      <input
        value={firstName}
        onChange={(e) => setFirstName(e.target.value)}
        placeholder="Pr√©nom"
      />
      <input
        value={lastName}
        onChange={(e) => setLastName(e.target.value)}
        placeholder="Nom"
      />
      <p>Nom complet: {fullName}</p>
      <p>En majuscules: {upperName}</p>
      <button onClick={() => setUpperName('JOHN DOE')}>
        Changer pour John Doe
      </button>
    </div>
  )
}
```

### Atomes avec storage

```jsx
import { atom } from 'jotai'
import { atomWithStorage } from 'jotai/utils'

// Persister dans localStorage
const themeAtom = atomWithStorage('theme', 'light')

// Atome pour les pr√©f√©rences utilisateur
const userPrefsAtom = atomWithStorage('userPrefs', {
  theme: 'light',
  language: 'fr',
  notifications: true
})

function ThemeToggle() {
  const [theme, setTheme] = useAtom(themeAtom)

  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      Mode {theme === 'light' ? 'sombre' : 'clair'}
    </button>
  )
}
```

---

## TanStack Query - Pour les donn√©es serveur

### Concept cl√©

**TanStack Query** (ex React Query) est parfait pour g√©rer :

- **Cache** des donn√©es API
- **Synchronisation** serveur/client
- **Loading states** automatiques
- **Optimistic updates**

```bash
npm install @tanstack/react-query
```

### Setup de base

```jsx
// main.jsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
    },
  },
})

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Router>
        <Layout />
      </Router>
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  )
}
```

### Queries (lecture de donn√©es)

```jsx
import { useQuery, useQueryClient } from '@tanstack/react-query'

// Hook personnalis√© pour les produits
function useProducts() {
  return useQuery({
    queryKey: ['products'],
    queryFn: async () => {
      const response = await fetch('/api/products')
      if (!response.ok) throw new Error('Erreur lors du chargement')
      return response.json()
    }
  })
}

// Hook pour un produit sp√©cifique
function useProduct(productId) {
  return useQuery({
    queryKey: ['products', productId],
    queryFn: async () => {
      const response = await fetch(`/api/products/${productId}`)
      if (!response.ok) throw new Error('Produit non trouv√©')
      return response.json()
    },
    enabled: !!productId // Ne pas ex√©cuter si pas d'ID
  })
}

// Utilisation dans les composants
function ProductList() {
  const { data: products, isLoading, error } = useProducts()

  if (isLoading) return <div>Chargement des produits...</div>
  if (error) return <div>Erreur: {error.message}</div>

  return (
    <div className="products-grid">
      {products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  )
}

function ProductDetail({ productId }) {
  const { data: product, isLoading, error } = useProduct(productId)

  if (isLoading) return <div>Chargement du produit...</div>
  if (error) return <div>Erreur: {error.message}</div>

  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
      <p>{product.price}‚Ç¨</p>
    </div>
  )
}
```

### Mutations (modification de donn√©es)

```jsx
import { useMutation, useQueryClient } from '@tanstack/react-query'

function useCreateProduct() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (newProduct) => {
      const response = await fetch('/api/products', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newProduct)
      })
      if (!response.ok) throw new Error('Erreur lors de la cr√©ation')
      return response.json()
    },
    onSuccess: () => {
      // Invalider le cache des produits
      queryClient.invalidateQueries({ queryKey: ['products'] })
      alert('Produit cr√©√© avec succ√®s!')
    },
    onError: (error) => {
      alert(`Erreur: ${error.message}`)
    }
  })
}

function useUpdateProduct() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, ...updates }) => {
      const response = await fetch(`/api/products/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      })
      if (!response.ok) throw new Error('Erreur lors de la mise √† jour')
      return response.json()
    },
    onSuccess: (updatedProduct) => {
      // Mettre √† jour le cache directement
      queryClient.setQueryData(['products', updatedProduct.id], updatedProduct)
      queryClient.invalidateQueries({ queryKey: ['products'] })
    }
  })
}

// Utilisation
function CreateProductForm() {
  const createProduct = useCreateProduct()
  const [formData, setFormData] = useState({ name: '', price: 0 })

  const handleSubmit = (e) => {
    e.preventDefault()
    createProduct.mutate(formData)
  }

  return (
    <form onSubmit={handleSubmit}>
      <input
        placeholder="Nom du produit"
        value={formData.name}
        onChange={(e) => setFormData({ ...formData, name: e.target.value })}
      />
      <input
        type="number"
        placeholder="Prix"
        value={formData.price}
        onChange={(e) => setFormData({ ...formData, price: Number(e.target.value) })}
      />
      <button
        type="submit"
        disabled={createProduct.isPending}
      >
        {createProduct.isPending ? 'Cr√©ation...' : 'Cr√©er le produit'}
      </button>
    </form>
  )
}
```

### Optimistic Updates

```jsx
function useToggleFavorite() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ productId, isFavorite }) => {
      const response = await fetch(`/api/products/${productId}/favorite`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ isFavorite })
      })
      if (!response.ok) throw new Error('Erreur')
      return response.json()
    },

    // Optimistic update
    onMutate: async ({ productId, isFavorite }) => {
      // Annuler les queries en cours
      await queryClient.cancelQueries({ queryKey: ['products', productId] })

      // Snapshot de la valeur pr√©c√©dente
      const previousProduct = queryClient.getQueryData(['products', productId])

      // Mettre √† jour optimistiquement
      queryClient.setQueryData(['products', productId], old => ({
        ...old,
        isFavorite
      }))

      // Retourner le contexte pour rollback si erreur
      return { previousProduct, productId }
    },

    // Rollback en cas d'erreur
    onError: (err, variables, context) => {
      queryClient.setQueryData(
        ['products', context.productId],
        context.previousProduct
      )
    },

    // Toujours refetch apr√®s
    onSettled: (data, error, variables) => {
      queryClient.invalidateQueries({ queryKey: ['products', variables.productId] })
    }
  })
}

function FavoriteButton({ product }) {
  const toggleFavorite = useToggleFavorite()

  const handleToggle = () => {
    toggleFavorite.mutate({
      productId: product.id,
      isFavorite: !product.isFavorite
    })
  }

  return (
    <button onClick={handleToggle}>
      {product.isFavorite ? '‚ù§Ô∏è' : 'ü§ç'} Favori
    </button>
  )
}
```

---

## Comparaison des solutions

### Tableau de comparaison

| Solution | Simplicit√© | Performance | Fonctionnalit√©s | √âcosyst√®me |
|----------|------------|-------------|-----------------|------------|
| **useState** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Context API** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Zustand** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Redux Toolkit** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Jotai** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **TanStack Query** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |

### Quand utiliser quoi ?

#### üè† **Petites apps (< 10 composants)**

```jsx
// useState suffit largement
function App() {
  const [user, setUser] = useState(null)
  const [theme, setTheme] = useState('light')

  return (
    <div>
      <Header user={user} theme={theme} setTheme={setTheme} />
      <MainContent user={user} />
    </div>
  )
}
```

#### üè¢ **Apps moyennes (10-50 composants)**

```jsx
// Context API + useState
const AppContext = createContext()

function App() {
  const [state, setState] = useState({
    user: null,
    theme: 'light',
    notifications: []
  })

  return (
    <AppContext.Provider value={{ state, setState }}>
      <Router>
        <Layout />
      </Router>
    </AppContext.Provider>
  )
}
```

#### üè≠ **Apps moyennes/grandes (50+ composants)**

```jsx
// Zustand pour l'√©tat client + TanStack Query pour les donn√©es serveur
const useAppStore = create((set) => ({
  theme: 'light',
  sidebarOpen: false,
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen }))
}))

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Router>
        <Layout />
      </Router>
    </QueryClientProvider>
  )
}
```

#### üèóÔ∏è **Grosses apps enterprise (100+ composants)**

```jsx
// Redux Toolkit pour la logique complexe
const store = configureStore({
  reducer: {
    auth: authSlice,
    ui: uiSlice,
    products: productsSlice,
    cart: cartSlice,
    [api.reducerPath]: api.reducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(api.middleware)
})

function App() {
  return (
    <Provider store={store}>
      <Router>
        <Layout />
      </Router>
    </Provider>
  )
}
```

---

## Exemple complet : E-commerce avec plusieurs stores

### Architecture recommand√©e

```
src/
‚îú‚îÄ‚îÄ stores/
‚îÇ   ‚îú‚îÄ‚îÄ useAuthStore.js      # Auth avec Zustand
‚îÇ   ‚îú‚îÄ‚îÄ useCartStore.js      # Panier avec Zustand
‚îÇ   ‚îî‚îÄ‚îÄ useUIStore.js        # UI state avec Zustand
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ products.js          # TanStack Query pour produits
‚îÇ   ‚îú‚îÄ‚îÄ orders.js            # TanStack Query pour commandes
‚îÇ   ‚îî‚îÄ‚îÄ auth.js              # TanStack Query pour auth
‚îú‚îÄ‚îÄ components/
‚îî‚îÄ‚îÄ pages/
```

### Store Auth

```jsx
// stores/useAuthStore.js
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export const useAuthStore = create(
  persist(
    (set, get) => ({
      user: null,
      token: null,
      isAuthenticated: false,

      setAuth: (user, token) => set({
        user,
        token,
        isAuthenticated: true
      }),

      logout: () => set({
        user: null,
        token: null,
        isAuthenticated: false
      }),

      updateUser: (userData) => set((state) => ({
        user: { ...state.user, ...userData }
      }))
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({
        user: state.user,
        token: state.token,
        isAuthenticated: state.isAuthenticated
      })
    }
  )
)
```

### Store UI

```jsx
// stores/useUIStore.js
import { create } from 'zustand'

export const useUIStore = create((set) => ({
  // Theme
  theme: 'light',
  toggleTheme: () => set((state) => ({
    theme: state.theme === 'light' ? 'dark' : 'light'
  })),

  // Sidebar
  sidebarOpen: false,
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
  closeSidebar: () => set({ sidebarOpen: false }),

  // Modales
  modals: {},
  openModal: (modalId) => set((state) => ({
    modals: { ...state.modals, [modalId]: true }
  })),
  closeModal: (modalId) => set((state) => ({
    modals: { ...state.modals, [modalId]: false }
  })),

  // Notifications
  notifications: [],
  addNotification: (notification) => set((state) => ({
    notifications: [...state.notifications, {
      id: Date.now(),
      ...notification
    }]
  })),
  removeNotification: (id) => set((state) => ({
    notifications: state.notifications.filter(n => n.id !== id)
  }))
}))
```

### API Hooks avec TanStack Query

```jsx
// api/products.js
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'

const API_BASE = '/api'

// R√©cup√©rer tous les produits
export function useProducts(filters = {}) {
  return useQuery({
    queryKey: ['products', filters],
    queryFn: async () => {
      const searchParams = new URLSearchParams(filters)
      const response = await fetch(`${API_BASE}/products?${searchParams}`)
      if (!response.ok) throw new Error('Erreur lors du chargement')
      return response.json()
    }
  })
}

// R√©cup√©rer un produit
export function useProduct(productId) {
  return useQuery({
    queryKey: ['products', productId],
    queryFn: async () => {
      const response = await fetch(`${API_BASE}/products/${productId}`)
      if (!response.ok) throw new Error('Produit non trouv√©')
      return response.json()
    },
    enabled: !!productId
  })
}

// Cr√©er une commande
export function useCreateOrder() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (orderData) => {
      const response = await fetch(`${API_BASE}/orders`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${useAuthStore.getState().token}`
        },
        body: JSON.stringify(orderData)
      })
      if (!response.ok) throw new Error('Erreur lors de la commande')
      return response.json()
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['orders'] })
      // Vider le panier apr√®s commande r√©ussie
      useCartStore.getState().clearCart()
    }
  })
}
```

### Composant principal avec tous les stores

```jsx
// components/App.jsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { BrowserRouter as Router } from 'react-router-dom'
import { useAuthStore } from './stores/useAuthStore'
import { useUIStore } from './stores/useUIStore'
import Layout from './components/Layout'

const queryClient = new QueryClient()

function App() {
  const { theme } = useUIStore()
  const { isAuthenticated } = useAuthStore()

  return (
    <QueryClientProvider client={queryClient}>
      <div className={`app theme-${theme}`}>
        <Router>
          <Layout />
        </Router>
      </div>
    </QueryClientProvider>
  )
}

export default App
```

### Composant avec multiple stores

```jsx
// components/ProductCard.jsx
import { useCartStore } from '../stores/useCartStore'
import { useAuthStore } from '../stores/useAuthStore'
import { useUIStore } from '../stores/useUIStore'

function ProductCard({ product }) {
  const { addItem } = useCartStore()
  const { isAuthenticated } = useAuthStore()
  const { addNotification } = useUIStore()

  const handleAddToCart = () => {
    if (!isAuthenticated) {
      addNotification({
        type: 'warning',
        message: 'Connectez-vous pour ajouter au panier'
      })
      return
    }

    addItem(product)
    addNotification({
      type: 'success',
      message: `${product.name} ajout√© au panier`
    })
  }

  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p className="price">{product.price}‚Ç¨</p>
      <button onClick={handleAddToCart} className="btn-primary">
        Ajouter au panier
      </button>
    </div>
  )
}

export default ProductCard
```

---

## Bonnes pratiques et patterns

### 1. S√©parer √©tat local vs global

```jsx
// ‚ùå Tout dans le store global
const useAppStore = create((set) => ({
  modalOpen: false,
  searchQuery: '',
  selectedTab: 'products',
  user: null,
  products: []
}))

// ‚úÖ √âtat local pour l'UI, global pour les donn√©es partag√©es
function SearchModal() {
  const [searchQuery, setSearchQuery] = useState('') // Local
  const [modalOpen, setModalOpen] = useState(false)  // Local
  const user = useAuthStore(state => state.user)     // Global

  return (
    // Component JSX
  )
}
```

### 2. Optimiser les s√©lecteurs

```jsx
// ‚ùå Re-render √† chaque changement du store
function Header() {
  const store = useCartStore() // Tout le store
  return <span>Articles: {store.itemCount}</span>
}

// ‚úÖ S√©lecteur sp√©cifique
function Header() {
  const itemCount = useCartStore(state => state.itemCount) // Juste ce qu'on veut
  return <span>Articles: {itemCount}</span>
}

// ‚úÖ S√©lecteur avec √©galit√© custom
import { shallow } from 'zustand/shallow'

function CartSummary() {
  const { items, total } = useCartStore(
    state => ({ items: state.items, total: state.total }),
    shallow
  )

  return <div>Total: {total}‚Ç¨ ({items.length} articles)</div>
}
```

### 3. Actions async proprement

```jsx
// ‚úÖ Gestion d'erreur et loading states
const useProductStore = create((set, get) => ({
  products: [],
  isLoading: false,
  error: null,

  fetchProducts: async () => {
    set({ isLoading: true, error: null })

    try {
      const response = await api.getProducts()
      set({ products: response.data, isLoading: false })
    } catch (error) {
      set({
        error: error.message,
        isLoading: false,
        products: [] // Reset en cas d'erreur
      })
    }
  },

  retryFetch: () => {
    const { fetchProducts } = get()
    fetchProducts()
  }
}))
```

### 4. Typage TypeScript

```jsx
// stores/types.ts
interface User {
  id: string
  name: string
  email: string
  role: 'user' | 'admin'
}

interface CartItem {
  id: string
  name: string
  price: number
  quantity: number
  image: string
}

interface AuthStore {
  user: User | null
  token: string | null
  isAuthenticated: boolean
  login: (email: string, password: string) => Promise<void>
  logout: () => void
}

interface CartStore {
  items: CartItem[]
  addItem: (product: Omit<CartItem, 'quantity'>) => void
  removeItem: (productId: string) => void
  updateQuantity: (productId: string, quantity: number) => void
  clearCart: () => void
  total: number
  itemCount: number
}

// stores/useAuthStore.ts
export const useAuthStore = create<AuthStore>((set, get) => ({
  user: null,
  token: null,
  isAuthenticated: false,

  login: async (email: string, password: string) => {
    try {
      const response = await api.login(email, password)
      set({
        user: response.user,
        token: response.token,
        isAuthenticated: true
      })
    } catch (error) {
      throw error
    }
  },

  logout: () => set({
    user: null,
    token: null,
    isAuthenticated: false
  })
}))
```

---

## Performance et debugging

### DevTools pour chaque solution

#### Zustand DevTools

```jsx
import { devtools } from 'zustand/middleware'

const useStore = create(
  devtools(
    (set) => ({
      count: 0,
      increment: () => set((state) => ({ count: state.count + 1 }))
    }),
    {
      name: 'counter-store' // Nom dans Redux DevTools
    }
  )
)
```

#### TanStack Query DevTools

```jsx
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Router>
        <Layout />
      </Router>
      {/* DevTools uniquement en d√©veloppement */}
      {process.env.NODE_ENV === 'development' && (
        <ReactQueryDevtools initialIsOpen={false} />
      )}
    </QueryClientProvider>
  )
}
```

### Mesurer les performances

```jsx
// Hook pour mesurer les re-renders
function useRenderCount(componentName) {
  const renderCount = useRef(0)

  useEffect(() => {
    renderCount.current += 1
    console.log(`${componentName} rendered ${renderCount.current} times`)
  })

  return renderCount.current
}

function ProductCard({ product }) {
  const renderCount = useRenderCount('ProductCard')

  return (
    <div>
      <span style={{ fontSize: '10px', color: 'red' }}>
        Renders: {renderCount}
      </span>
      {/* Rest of component */}
    </div>
  )
}
```

### Optimisations avanc√©es

```jsx
import { memo } from 'react'
import { shallow } from 'zustand/shallow'

// M√©moisation du composant
const ProductCard = memo(({ product }) => {
  const addItem = useCartStore(state => state.addItem)

  return (
    <div className="product-card">
      <h3>{product.name}</h3>
      <p>{product.price}‚Ç¨</p>
      <button onClick={() => addItem(product)}>
        Ajouter au panier
      </button>
    </div>
  )
})

// S√©lecteur optimis√©
function CartSummary() {
  const cartData = useCartStore(
    state => ({
      itemCount: state.items.length,
      total: state.items.reduce((sum, item) => sum + item.price * item.quantity, 0)
    }),
    shallow
  )

  return (
    <div>
      {cartData.itemCount} articles - {cartData.total}‚Ç¨
    </div>
  )
}
```

---

## Migration et √©volution

### Migrer de Context vers Zustand

```jsx
// Avant (Context API)
const CartContext = createContext()

export function CartProvider({ children }) {
  const [items, setItems] = useState([])

  const addItem = (product) => {
    setItems(prev => [...prev, product])
  }

  return (
    <CartContext.Provider value={{ items, addItem }}>
      {children}
    </CartContext.Provider>
  )
}

// Apr√®s (Zustand)
export const useCartStore = create((set) => ({
  items: [],
  addItem: (product) => set((state) => ({
    items: [...state.items, product]
  }))
}))

// Plus besoin de Provider dans App.jsx !
function App() {
  return (
    <Router>
      <Layout />
    </Router>
  )
}
```

### Strat√©gie de migration progressive

```jsx
// √âtape 1: Garder l'ancien Context, ajouter Zustand pour nouvelles features
function App() {
  return (
    <OldContextProvider>  {/* Garde l'ancien */}
      <Router>
        <Layout />
      </Router>
    </OldContextProvider>
  )
}

// √âtape 2: Migrer petit √† petit
function Header() {
  // Ancien code (√† supprimer plus tard)
  // const { user } = useContext(OldContext)

  // Nouveau code
  const user = useAuthStore(state => state.user)

  return <header>...</header>
}

// √âtape 3: Supprimer l'ancien Context quand tout est migr√©
```

---

## Points cl√©s √† retenir

### Les essentiels

1. **useState** ‚Üí pour l'√©tat local d'un composant
2. **Context API** ‚Üí pour partager l'√©tat sans prop drilling
3. **Zustand** ‚Üí store simple et performant
4. **TanStack Query** ‚Üí pour les donn√©es serveur
5. **Redux Toolkit** ‚Üí pour les apps complexes

### Architecture recommand√©e

```jsx
// üéØ Stack moderne optimal
function App() {
  return (
    <QueryClientProvider client={queryClient}>  {/* Donn√©es serveur */}
      <Router>
        <Layout />  {/* Zustand pour l'√©tat client */}
      </Router>
    </QueryClientProvider>
  )
}
```

### R√®gles d'or

1. **Commencez simple** : useState ‚Üí Context ‚Üí Zustand
2. **S√©parez les pr√©occupations** : local vs global, client vs serveur
3. **Optimisez les s√©lecteurs** : ne prenez que ce dont vous avez besoin
4. **Typez votre √©tat** : TypeScript pour √©viter les bugs
5. **Testez vos stores** : logique m√©tier s√©par√©e des composants

---

## Exercices pratiques

### Exercice 1 : Todo App avec Zustand

Cr√©ez une todo app avec :

- Store Zustand pour les todos
- Filtres (tous, actifs, termin√©s)
- Persistance en localStorage
- Actions : ajouter, supprimer, toggle, clear completed

### Exercice 2 : E-commerce avec TanStack Query

Cr√©ez une boutique avec :

- TanStack Query pour les produits (API)
- Zustand pour le panier (client)
- Cache optimis√© et optimistic updates
- Gestion d'erreurs robuste

### Exercice 3 : Dashboard avec Redux Toolkit

Cr√©ez un dashboard avec :

- RTK pour l'√©tat complexe
- RTK Query pour les APIs
- Middleware personnalis√©
- DevTools configur√©s

---

## Ressources pour aller plus loin

### Documentation officielle

- üìö [Zustand](https://docs.pmnd.rs/zustand/getting-started/introduction)
- üöÄ [TanStack Query](https://tanstack.com/query/latest)
- üîß [Redux Toolkit](https://redux-toolkit.js.org/)
- ‚öõÔ∏è [Jotai](https://jotai.org/)

### Comparaisons et guides

- üìä [State Management Comparison](https://react-state-management.com/)
- üéØ [When to use what](https://kentcdodds.com/blog/application-state-management-with-react)
- üîç [Performance comparisons](https://github.com/dai-shi/will-this-react-global-state-work-in-concurrent-mode)

---

**Prochaine √©tape :** Maintenant que tu ma√Ætrises la gestion d'√©tat, on va voir comment optimiser les performances et g√©rer les rendus complexes dans le prochain chapitre ! üöÄ
