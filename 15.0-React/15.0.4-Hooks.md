# React - Les Hooks : Index Complet

Ils permettent d'utiliser l'Ã©tat et les fonctionnalitÃ©s de React dans des **composants fonctionnels**, rendant le code plus simple et rÃ©utilisable.

---

## Organisation des Hooks

Cette section est organisÃ©e en plusieurs chapitres spÃ©cialisÃ©s pour une meilleure comprÃ©hension :

### ğŸ“š Hooks de Base

#### [15.0.4.0 - useState](./15.0.4.0-useState.md)

- **Ã‰tat local** dans les composants fonctionnels
- Gestion des **mises Ã  jour d'Ã©tat**
- Optimisation et **bonnes pratiques**
- Exemples pratiques avec objets et tableaux

#### [15.0.4.1 - useEffect](./15.0.4.1-useEffect.md)

- **Effets de bord** et cycle de vie
- Patterns courants : **fetch**, timers, Ã©vÃ©nements
- **Dependencies** et optimisations
- Cleanup et gestion des fuites mÃ©moire

#### [15.0.4.2 - useRef](./15.0.4.2-useRef.md)

- **RÃ©fÃ©rences DOM** directes
- Valeurs **mutables** sans re-render
- Cas d'usage avancÃ©s : timers, intersection observer
- DiffÃ©rence avec useState

### âš¡ Hooks de Performance

#### [15.0.4.3 - useMemo](./15.0.4.3-useMemo.md)

- **MÃ©morisation** des calculs coÃ»teux
- Optimisation des **objets et tableaux**
- Quand et comment utiliser useMemo
- Impact sur les performances

#### [15.0.4.4 - useCallback](./15.0.4.4-useCallback.md)

- **MÃ©morisation des fonctions**
- Ã‰viter les **re-renders** inutiles
- Optimisation des composants enfants
- Patterns avec les Ã©vÃ©nements

### ğŸ—ï¸ Hooks de Gestion d'Ã‰tat

#### [15.0.4.5 - useReducer](./15.0.4.5-useReducer.md)

- Gestion d'**Ã©tat complexe**
- Pattern **Redux-like** intÃ©grÃ©
- Actions et reducers
- Cas d'usage vs useState

#### [15.0.4.6 - useContext](./15.0.4.6-useContext.md)

- **Partage de donnÃ©es** entre composants
- RÃ©soudre le **prop drilling**
- Context API et providers
- Patterns avec plusieurs contextes

### ğŸš€ Hooks AvancÃ©s

#### [15.0.4.7 - Hooks AvancÃ©s](./15.0.4.7-hooks-avances.md)

- **useLayoutEffect** : synchronisation DOM
- **useId** : identifiants uniques
- **useTransition** : transitions non-bloquantes
- **useDeferredValue** : valeurs diffÃ©rÃ©es

### ğŸ¨ Hooks PersonnalisÃ©s

#### [15.0.4.8 - Custom Hooks](./15.0.4.8-custom-hooks.md)

- **CrÃ©er ses propres hooks**
- RÃ©utilisabilitÃ© et **logique partagÃ©e**
- Patterns courants : API, UI, utilitaires
- Composition et **bonnes pratiques**

---

## Vue d'Ensemble Rapide

### Hooks Natifs React

```jsx
import { 
  useState,         // Ã‰tat local
  useEffect,        // Effets de bord
  useRef,           // RÃ©fÃ©rences DOM/valeurs mutables
  useMemo,          // MÃ©morisation calculs
  useCallback,      // MÃ©morisation fonctions
  useReducer,       // Ã‰tat complexe
  useContext,       // Context global
  useLayoutEffect,  // Effets synchrones
  useId,            // Identifiants uniques
  useTransition,    // Transitions UI
  useDeferredValue  // Valeurs diffÃ©rÃ©es
} from 'react'
```

### Exemple de Hook PersonnalisÃ©

```jsx
// Hook personnalisÃ© simple
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue)

  const increment = useCallback(() => setCount(c => c + 1), [])
  const decrement = useCallback(() => setCount(c => c - 1), [])
  const reset = useCallback(() => setCount(initialValue), [initialValue])

  return { count, increment, decrement, reset }
}

// Utilisation
function App() {
  const { count, increment, decrement, reset } = useCounter(10)

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+1</button>
      <button onClick={decrement}>-1</button>
      <button onClick={reset}>Reset</button>
    </div>
  )
}
```

---

## RÃ¨gles des Hooks

### âš ï¸ RÃ¨gles Importantes

1. **Toujours au niveau racine** : jamais dans des boucles, conditions ou fonctions imbriquÃ©es
2. **Uniquement dans les composants React** ou autres hooks personnalisÃ©s
3. **Ordre constant** : l'ordre d'appel doit Ãªtre identique Ã  chaque render
4. **Nommage** : les hooks personnalisÃ©s commencent par "use"

```jsx
// âœ… BON
function GoodComponent() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')
  
  useEffect(() => {
    document.title = `${name} - ${count}`
  }, [name, count])
  
  return <div>...</div>
}

// âŒ MAUVAIS
function BadComponent({ condition }) {
  const [count, setCount] = useState(0)
  
  if (condition) {
    const [name, setName] = useState('') // âŒ Hook conditionnel !
    useEffect(() => {}) // âŒ Hook conditionnel !
  }
  
  return <div>...</div>
}
```

---

## Patterns Courants

### Fetch de DonnÃ©es

```jsx
function useApiData(url) {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false))
  }, [url])

  return { data, loading, error }
}
```

### State Management Local

```jsx
function useFormState(initialState) {
  const [values, setValues] = useState(initialState)
  const [errors, setErrors] = useState({})

  const setValue = useCallback((name, value) => {
    setValues(prev => ({ ...prev, [name]: value }))
    setErrors(prev => ({ ...prev, [name]: null }))
  }, [])

  const setError = useCallback((name, error) => {
    setErrors(prev => ({ ...prev, [name]: error }))
  }, [])

  return { values, errors, setValue, setError }
}
```

### UI State

```jsx
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue)
  const toggle = useCallback(() => setValue(v => !v), [])
  return [value, toggle]
}

function useModal() {
  const [isOpen, setIsOpen] = useState(false)
  const open = useCallback(() => setIsOpen(true), [])
  const close = useCallback(() => setIsOpen(false), [])
  return { isOpen, open, close }
}
```

---

## Migration Class â†’ Hooks

### Avant (Class Component)

```jsx
class Counter extends Component {
  constructor(props) {
    super(props)
    this.state = { count: 0 }
  }

  componentDidMount() {
    document.title = `Count: ${this.state.count}`
  }

  componentDidUpdate() {
    document.title = `Count: ${this.state.count}`
  }

  increment = () => {
    this.setState(prev => ({ count: prev.count + 1 }))
  }

  render() {
    return (
      <div>
        <p>{this.state.count}</p>
        <button onClick={this.increment}>+1</button>
      </div>
    )
  }
}
```

### AprÃ¨s (Hooks)

```jsx
function Counter() {
  const [count, setCount] = useState(0)

  useEffect(() => {
    document.title = `Count: ${count}`
  }, [count])

  const increment = useCallback(() => {
    setCount(prev => prev + 1)
  }, [])

  return (
    <div>
      <p>{count}</p>
      <button onClick={increment}>+1</button>
    </div>
  )
}
```

---

## Ressources ComplÃ©mentaires

- ğŸ“š [Hooks API Reference](https://react.dev/reference/react)
- ğŸ¯ [Rules of Hooks](https://react.dev/warnings/invalid-hook-call-warning)
- ğŸ’¡ [Building Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)
- ğŸ”„ [useHooks.com](https://usehooks.com/) - Collection de hooks utiles
- ğŸ› ï¸ [React Hook Form](https://react-hook-form.com/) - Gestion de formulaires
- âš¡ [TanStack Query](https://tanstack.com/query) - Hooks pour l'API
