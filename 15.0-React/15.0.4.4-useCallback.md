# React - useCallback : MÃ©morisation de Fonctions

Quand tu passes des fonctions en props Ã  des composants memo(), useCallback va **mÃ©moriser** la fonction et Ã©viter les re-renders inutiles.

---

## Le ProblÃ¨me des Fonctions RecrÃ©Ã©es

### Nouvelles Fonctions Ã  Chaque Rendu

```jsx
function ProblematicParent() {
  const [count, setCount] = useState(0)
  const [items, setItems] = useState([])
  const [name, setName] = useState('')

  // âŒ PROBLÃˆME - Nouvelle fonction Ã  chaque rendu !
  const addItem = (text) => {
    setItems(prev => [...prev, { id: Date.now(), text }])
  }

  // âŒ PROBLÃˆME - Nouvelle fonction Ã  chaque rendu !
  const handleClick = (id) => {
    console.log('Item clicked:', id)
  }

  // âŒ PROBLÃˆME - Nouvelle fonction Ã  chaque rendu !
  const handleSubmit = (e) => {
    e.preventDefault()
    console.log('Form submitted')
  }

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
      
      {/* Ces composants re-render mÃªme si leurs props logiques n'ont pas changÃ© ! */}
      <ExpensiveForm onSubmit={handleSubmit} />
      <ExpensiveList items={items} onItemClick={handleClick} />
      <ExpensiveAddButton onAdd={addItem} />
    </div>
  )
}

// Ces composants optimisÃ©s ne servent Ã  rien car les fonctions changent toujours !
const ExpensiveForm = memo(function ExpensiveForm({ onSubmit }) {
  console.log('ğŸ“ ExpensiveForm re-rendu') // â† Toujours appelÃ© !
  return <form onSubmit={onSubmit}><button>Submit</button></form>
})

const ExpensiveList = memo(function ExpensiveList({ items, onItemClick }) {
  console.log('ğŸ“ ExpensiveList re-rendu') // â† Toujours appelÃ© !
  return (
    <ul>
      {items.map(item => (
        <li key={item.id} onClick={() => onItemClick(item.id)}>
          {item.text}
        </li>
      ))}
    </ul>
  )
})

const ExpensiveAddButton = memo(function ExpensiveAddButton({ onAdd }) {
  console.log('ğŸ”˜ ExpensiveAddButton re-rendu') // â† Toujours appelÃ© !
  return <button onClick={() => onAdd('New item')}>Add Item</button>
})
```

---

## useCallback

### Syntaxe et Usage Basique

```jsx
import { useCallback } from 'react'

function OptimizedParent() {
  const [count, setCount] = useState(0)
  const [items, setItems] = useState([])
  const [name, setName] = useState('')

  // âœ… SOLUTION - Fonction mÃ©morisÃ©e stable
  const addItem = useCallback((text) => {
    setItems(prev => [...prev, { id: Date.now(), text, completed: false }])
  }, []) // â† Pas de dÃ©pendances = fonction stable

  // âœ… SOLUTION - Fonction mÃ©morisÃ©e stable
  const handleClick = useCallback((id) => {
    console.log('Item clicked:', id)
    // Logique qui n'a pas de dÃ©pendances externes
  }, [])

  // âœ… SOLUTION - Fonction avec dÃ©pendances
  const addItemWithPrefix = useCallback((text) => {
    const prefix = name ? `[${name}] ` : ''
    setItems(prev => [...prev, { 
      id: Date.now(), 
      text: prefix + text,
      completed: false 
    }])
  }, [name]) // â† Se recrÃ©e seulement si name change

  // âœ… SOLUTION - Event handler optimisÃ©
  const handleCountChange = useCallback((increment) => {
    setCount(prev => prev + increment)
  }, [])

  // âœ… SOLUTION - Fonction de suppression
  const removeItem = useCallback((id) => {
    setItems(prev => prev.filter(item => item.id !== id))
  }, [])

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1 (non-optimisÃ©)</button>
      
      <input 
        value={name} 
        onChange={e => setName(e.target.value)} 
        placeholder="PrÃ©fixe..."
      />
      
      {/* Maintenant ces composants ne re-render que si nÃ©cessaire ! */}
      <OptimizedButton onClick={handleCountChange} increment={1}>+1</OptimizedButton>
      <OptimizedButton onClick={handleCountChange} increment={5}>+5</OptimizedButton>
      
      <OptimizedList 
        items={items} 
        onItemClick={handleClick}
        onItemRemove={removeItem}
      />
      
      <OptimizedAddForm 
        onAdd={addItem}
        onAddWithPrefix={addItemWithPrefix}
      />
    </div>
  )
}

// Maintenant ces composants ne re-render que si leurs props changent vraiment !
const OptimizedButton = memo(function OptimizedButton({ onClick, increment, children }) {
  console.log(`ğŸ”˜ OptimizedButton (+${increment}) re-rendu`)
  
  return (
    <button onClick={() => onClick(increment)} style={{ margin: '5px' }}>
      {children}
    </button>
  )
})

const OptimizedList = memo(function OptimizedList({ items, onItemClick, onItemRemove }) {
  console.log('ğŸ“ OptimizedList re-rendu')
  
  return (
    <ul>
      {items.map(item => (
        <li key={item.id} style={{ display: 'flex', justifyContent: 'space-between' }}>
          <span onClick={() => onItemClick(item.id)} style={{ cursor: 'pointer' }}>
            {item.text}
          </span>
          <button onClick={() => onItemRemove(item.id)}>âŒ</button>
        </li>
      ))}
    </ul>
  )
})

const OptimizedAddForm = memo(function OptimizedAddForm({ onAdd, onAddWithPrefix }) {
  console.log('ğŸ“ OptimizedAddForm re-rendu')
  const [input, setInput] = useState('')

  const handleSubmit = (e) => {
    e.preventDefault()
    if (input.trim()) {
      onAdd(input.trim())
      setInput('')
    }
  }

  const handleSubmitWithPrefix = (e) => {
    e.preventDefault()
    if (input.trim()) {
      onAddWithPrefix(input.trim())
      setInput('')
    }
  }

  return (
    <form>
      <input
        value={input}
        onChange={e => setInput(e.target.value)}
        placeholder="Nouvel Ã©lÃ©ment..."
      />
      <button type="submit" onClick={handleSubmit}>Ajouter</button>
      <button type="button" onClick={handleSubmitWithPrefix}>Avec prÃ©fixe</button>
    </form>
  )
})
```

---

## Ressources Pour Aller Plus Loin

- ğŸ“š [useCallback Documentation](https://react.dev/reference/react/useCallback)
- ğŸ’¡ [When to useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)
- âš¡ [React Performance](https://react.dev/learn/render-and-commit)
- ğŸ”§ [React.memo vs useCallback](https://dmitripavlutin.com/use-react-memo-wisely/)
