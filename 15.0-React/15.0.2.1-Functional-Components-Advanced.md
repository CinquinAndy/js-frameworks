# React - Composants Fonctionnels AvancÃ©s

## Introduction

Les **composants fonctionnels** sont le cÅ“ur de React moderne. Comme dit la doc officielle : *"Functional components are some of the more common components that will come across while working in React. These are simply JavaScript functions."*

Cette section complÃ¨te le chapitre **15.0.2-Basics.md** avec des concepts avancÃ©s et exemples pratiques !

---

## RÃ©volution des Composants Fonctionnels

### Avant vs Maintenant

```jsx
// AVANT - Class Component (2015-2019) âŒ
class CompteurOldSchool extends React.Component {
  constructor(props) {
    super(props)
    this.state = { count: 0 }
    this.handleClick = this.handleClick.bind(this)
  }

  handleClick() {
    this.setState({ count: this.state.count + 1 })
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleClick}>+1</button>
      </div>
    )
  }
}

// MAINTENANT - Functional Component (2019+) âœ…
function CompteurModerne() {
  const [count, setCount] = useState(0)

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  )
}
```

**Pourquoi cette rÃ©volution ?**

- **Moins de code** (5 lignes vs 20 lignes)
- **Plus lisible** et comprÃ©hensible
- **Hooks** permettent tout ce que faisaient les classes
- **Performance optimisÃ©e** par React
- **Recommandation officielle** depuis 2019

---

## Ã‰tat = MÃ©moire du Composant

### Concept fondamental

L'**Ã©tat** (state), c'est la **mÃ©moire** de ton composant. Il lui permet de :

1. **Se souvenir** d'informations entre les rendus
2. **DÃ©clencher un re-rendu** quand les donnÃ©es changent

```jsx
import { useState } from 'react'

function ExempleMemoire() {
  // âŒ Variable normale = Reset Ã  chaque rendu
  let variableNormale = 0

  // âœ… Ã‰tat = Persiste entre les rendus
  const [etat, setEtat] = useState(0)

  const incrementer = () => {
    variableNormale++        // Ne marche pas !
    console.log('Variable normale:', variableNormale) // Toujours 1

    setEtat(etat + 1)        // Marche !
  }

  return (
    <div>
      <p>Variable normale: {variableNormale}</p>
      <p>Ã‰tat: {etat}</p>
      <button onClick={incrementer}>Incrementer</button>
    </div>
  )
}
```

### useState en dÃ©tail

```jsx
import { useState } from 'react'

function ExempleUseState() {
  // useState retourne un tableau avec 2 Ã©lÃ©ments :
  const [valeur, setValeur] = useState('valeur initiale')
  //     ^^^^^^  ^^^^^^^^^
  //     |       |
  //     |       +-- Fonction pour modifier l'Ã©tat
  //     +-- Valeur actuelle de l'Ã©tat

  // DiffÃ©rentes faÃ§ons de modifier l'Ã©tat
  const exemples = () => {
    // 1. Valeur directe
    setValeur('nouvelle valeur')

    // 2. Fonction de mise Ã  jour (recommandÃ©e pour les calculs)
    setValeur(prevValeur => prevValeur + ' modifiÃ©e')

    // 3. Avec Ã©tat complexe
    setValeur(prev => {
      console.log('Ancienne valeur:', prev)
      return 'nouvelle valeur calculÃ©e'
    })
  }

  return (
    <div>
      <p>Valeur: {valeur}</p>
      <button onClick={() => setValeur('clic simple')}>Simple</button>
      <button onClick={() => setValeur(prev => prev + '!')}>Avec fonction</button>
    </div>
  )
}
```

### RÃ¨gles cruciales pour useState

âš ï¸ **TRÃˆS IMPORTANT** - Ces rÃ¨gles sont **NON-NÃ‰GOCIABLES** :

1. **AppelÃ© uniquement au top level** du composant
2. **Pas dans des boucles, conditions ou fonctions imbriquÃ©es**
3. **MÃªme ordre Ã  chaque rendu**

```jsx
// âœ… CORRECT
function BonExemple() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')
  const [visible, setVisible] = useState(true)

  if (count > 5) {
    // âŒ INCORRECT - useState dans une condition
    // const [error, setError] = useState('')
  }

  for (let i = 0; i < 3; i++) {
    // âŒ INCORRECT - useState dans une boucle
    // const [items, setItems] = useState([])
  }

  const handleClick = () => {
    // âŒ INCORRECT - useState dans une fonction
    // const [temp, setTemp] = useState(0)
  }

  return <div>...</div>
}
```

### Ã‰tat local vs partagÃ©

```jsx
// Chaque instance a son propre Ã©tat
function Compteur({ id }) {
  const [count, setCount] = useState(0)

  return (
    <div>
      <h3>Compteur {id}</h3>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  )
}

function App() {
  return (
    <div>
      <Compteur id="A" />  {/* Ã‰tat indÃ©pendant */}
      <Compteur id="B" />  {/* Ã‰tat indÃ©pendant */}
      <Compteur id="C" />  {/* Ã‰tat indÃ©pendant */}
    </div>
  )
}
```

---

## Exemples Pratiques AvancÃ©s

### 1. Formulaire de Contact Intelligent

```jsx
function FormulaireContact() {
  const [formData, setFormData] = useState({
    nom: '',
    email: '',
    message: ''
  })
  const [erreurs, setErreurs] = useState({})
  const [envoye, setEnvoye] = useState(false)
  const [enCoursEnvoi, setEnCoursEnvoi] = useState(false)

  const validerChamp = (field, value) => {
    const nouvellesErreurs = { ...erreurs }

    switch (field) {
      case 'nom':
        if (!value.trim()) {
          nouvellesErreurs.nom = 'Le nom est requis'
        } else if (value.length < 2) {
          nouvellesErreurs.nom = 'Le nom doit faire au moins 2 caractÃ¨res'
        } else {
          delete nouvellesErreurs.nom
        }
        break

      case 'email':
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
        if (!value.trim()) {
          nouvellesErreurs.email = 'L\'email est requis'
        } else if (!emailRegex.test(value)) {
          nouvellesErreurs.email = 'Format d\'email invalide'
        } else {
          delete nouvellesErreurs.email
        }
        break

      case 'message':
        if (!value.trim()) {
          nouvellesErreurs.message = 'Le message est requis'
        } else if (value.length < 10) {
          nouvellesErreurs.message = 'Le message doit faire au moins 10 caractÃ¨res'
        } else {
          delete nouvellesErreurs.message
        }
        break
    }

    setErreurs(nouvellesErreurs)
    return Object.keys(nouvellesErreurs).length === 0
  }

  const handleChange = (field, value) => {
    setFormData({ ...formData, [field]: value })

    // Validation en temps rÃ©el
    if (formData[field] !== '') {
      validerChamp(field, value)
    }
  }

  const handleSubmit = async (e) => {
    e.preventDefault()

    // Validation complÃ¨te
    const champsValides = Object.keys(formData).every(field =>
      validerChamp(field, formData[field])
    )

    if (champsValides && Object.keys(erreurs).length === 0) {
      setEnCoursEnvoi(true)

      try {
        // Simulation d'envoi API
        await new Promise(resolve => setTimeout(resolve, 2000))

        console.log('ğŸ“§ Email envoyÃ©:', formData)
        setEnvoye(true)

        // Reset automatique aprÃ¨s succÃ¨s
        setTimeout(() => {
          setEnvoye(false)
          setFormData({ nom: '', email: '', message: '' })
          setErreurs({})
        }, 4000)

      } catch (error) {
        setErreurs({ general: 'Erreur lors de l\'envoi. Veuillez rÃ©essayer.' })
      } finally {
        setEnCoursEnvoi(false)
      }
    }
  }

  // Rendu de succÃ¨s
  if (envoye) {
    return (
      <div className="success-container">
        <div className="success-message">
          <h2>âœ… Message envoyÃ© avec succÃ¨s!</h2>
          <p>Merci <strong>{formData.nom}</strong>, nous vous rÃ©pondrons sous 24h Ã  l'adresse :</p>
          <p><strong>{formData.email}</strong></p>
          <div className="success-animation">ğŸ‰</div>
        </div>
      </div>
    )
  }

  const peutEnvoyer = Object.keys(erreurs).length === 0 &&
    formData.nom && formData.email && formData.message

  return (
    <div className="contact-form-container">
      <form onSubmit={handleSubmit} className="contact-form">
        <h2>ğŸ“¬ Contactez-nous</h2>

        {erreurs.general && (
          <div className="error-banner">
            âŒ {erreurs.general}
          </div>
        )}

        <div className="field-group">
          <label htmlFor="nom">
            Nom complet *
            {formData.nom && !erreurs.nom && <span className="valid">âœ“</span>}
          </label>
          <input
            id="nom"
            type="text"
            value={formData.nom}
            onChange={(e) => handleChange('nom', e.target.value)}
            className={erreurs.nom ? 'error' : formData.nom ? 'valid' : ''}
            disabled={enCoursEnvoi}
            placeholder="Votre nom et prÃ©nom"
          />
          {erreurs.nom && <span className="error-text">{erreurs.nom}</span>}
        </div>

        <div className="field-group">
          <label htmlFor="email">
            Adresse email *
            {formData.email && !erreurs.email && <span className="valid">âœ“</span>}
          </label>
          <input
            id="email"
            type="email"
            value={formData.email}
            onChange={(e) => handleChange('email', e.target.value)}
            className={erreurs.email ? 'error' : formData.email ? 'valid' : ''}
            disabled={enCoursEnvoi}
            placeholder="votre@email.com"
          />
          {erreurs.email && <span className="error-text">{erreurs.email}</span>}
        </div>

        <div className="field-group">
          <label htmlFor="message">
            Votre message *
            <span className="counter">
              ({formData.message.length}/10 min)
            </span>
            {formData.message.length >= 10 && !erreurs.message && <span className="valid">âœ“</span>}
          </label>
          <textarea
            id="message"
            value={formData.message}
            onChange={(e) => handleChange('message', e.target.value)}
            className={erreurs.message ? 'error' : formData.message.length >= 10 ? 'valid' : ''}
            disabled={enCoursEnvoi}
            rows={6}
            placeholder="DÃ©crivez votre demande en dÃ©tail..."
          />
          {erreurs.message && <span className="error-text">{erreurs.message}</span>}
        </div>

        <button
          type="submit"
          disabled={!peutEnvoyer || enCoursEnvoi}
          className={`submit-btn ${peutEnvoyer ? 'ready' : 'disabled'}`}
        >
          {enCoursEnvoi ? (
            <>â³ Envoi en cours...</>
          ) : peutEnvoyer ? (
            <>ğŸ“¤ Envoyer le message</>
          ) : (
            <>ğŸ“ Remplissez tous les champs</>
          )}
        </button>

        <p className="form-info">
          <small>* Champs obligatoires. Vos donnÃ©es sont protÃ©gÃ©es.</small>
        </p>
      </form>
    </div>
  )
}
```

### 2. Timer/ChronomÃ¨tre AvancÃ©

```jsx
function TimerAvance() {
  const [temps, setTemps] = useState(0)
  const [actif, setActif] = useState(false)
  const [mode, setMode] = useState('chrono') // 'chrono' ou 'minuteur'
  const [objectif, setObjectif] = useState(300) // 5 minutes par dÃ©faut
  const [laps, setLaps] = useState([])

  // Gestion du timer
  useEffect(() => {
    let intervalId = null

    if (actif) {
      intervalId = setInterval(() => {
        setTemps(prevTemps => {
          if (mode === 'minuteur') {
            const nouveau = prevTemps - 1
            if (nouveau <= 0) {
              setActif(false)
              alert('â° Temps Ã©coulÃ©!')
              return 0
            }
            return nouveau
          } else {
            return prevTemps + 1
          }
        })
      }, 1000)
    }

    return () => {
      if (intervalId) clearInterval(intervalId)
    }
  }, [actif, mode])

  const demarrer = () => {
    if (mode === 'minuteur' && temps === 0) {
      setTemps(objectif)
    }
    setActif(true)
  }

  const arreter = () => setActif(false)

  const reset = () => {
    setTemps(mode === 'minuteur' ? objectif : 0)
    setActif(false)
    setLaps([])
  }

  const ajouterLap = () => {
    if (mode === 'chrono' && actif) {
      setLaps([...laps, temps])
    }
  }

  const changerMode = (nouveauMode) => {
    setMode(nouveauMode)
    setActif(false)
    setLaps([])
    setTemps(nouveauMode === 'minuteur' ? objectif : 0)
  }

  const formatTemps = (secondes) => {
    const heures = Math.floor(Math.abs(secondes) / 3600)
    const minutes = Math.floor((Math.abs(secondes) % 3600) / 60)
    const sec = Math.abs(secondes) % 60

    if (heures > 0) {
      return `${heures.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`
    }
    return `${minutes.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`
  }

  const pourcentageProgress = mode === 'minuteur' ?
    ((objectif - temps) / objectif) * 100 : 0

  return (
    <div className="timer-avance">
      <div className="timer-header">
        <div className="mode-selector">
          <button
            className={mode === 'chrono' ? 'active' : ''}
            onClick={() => changerMode('chrono')}
            disabled={actif}
          >
            â±ï¸ ChronomÃ¨tre
          </button>
          <button
            className={mode === 'minuteur' ? 'active' : ''}
            onClick={() => changerMode('minuteur')}
            disabled={actif}
          >
            â²ï¸ Minuteur
          </button>
        </div>
      </div>

      {mode === 'minuteur' && (
        <div className="objectif-setter">
          <label>DurÃ©e (minutes):</label>
          <input
            type="number"
            min="1"
            max="60"
            value={Math.floor(objectif / 60)}
            onChange={(e) => setObjectif(Number(e.target.value) * 60)}
            disabled={actif}
          />
          <div className="progress-bar">
            <div
              className="progress"
              style={{ width: `${pourcentageProgress}%` }}
            />
          </div>
        </div>
      )}

      <div className={`display ${mode === 'minuteur' && temps <= 10 ? 'urgent' : ''}`}>
        <h1 className="time-display">{formatTemps(temps)}</h1>
        <p className="status">
          {actif ? (
            mode === 'chrono' ? 'â° En cours' : 'â³ DÃ©compte'
          ) : (
            'â¸ï¸ ArrÃªtÃ©'
          )}
        </p>
      </div>

      <div className="controls">
        <button
          onClick={demarrer}
          disabled={actif}
          className="start-btn"
        >
          â–¶ï¸ {mode === 'chrono' ? 'Start' : 'DÃ©marrer'}
        </button>

        <button
          onClick={arreter}
          disabled={!actif}
          className="pause-btn"
        >
          â¸ï¸ Pause
        </button>

        {mode === 'chrono' && (
          <button
            onClick={ajouterLap}
            disabled={!actif}
            className="lap-btn"
          >
            ğŸ Lap
          </button>
        )}

        <button
          onClick={reset}
          className="reset-btn"
        >
          ğŸ”„ Reset
        </button>
      </div>

      {mode === 'chrono' && laps.length > 0 && (
        <div className="laps-section">
          <h3>Tours enregistrÃ©s:</h3>
          <ul className="laps-list">
            {laps.map((lap, index) => (
              <li key={index}>
                <span>Tour {index + 1}:</span>
                <span>{formatTemps(lap)}</span>
                {index > 0 && (
                  <span className="diff">
                    (+{formatTemps(lap - laps[index - 1])})
                  </span>
                )}
              </li>
            )).reverse()}
          </ul>
        </div>
      )}

      <div className="stats">
        {mode === 'chrono' ? (
          <>
            <p>Sessions: {Math.floor(temps / 60)} min</p>
            {temps > 300 && <p>ğŸ‰ Plus de 5 minutes !</p>}
            {temps > 1800 && <p>ğŸ† Plus de 30 minutes - Champion!</p>}
          </>
        ) : (
          <>
            <p>Temps restant: {formatTemps(temps)}</p>
            {temps <= 30 && temps > 0 && <p>âš ï¸ BientÃ´t fini!</p>}
          </>
        )}
      </div>
    </div>
  )
}
```

### 3. Dashboard avec Authentification et RÃ´les

```jsx
function Dashboard({ user, notifications = [] }) {
  const [ongletActif, setOngletActif] = useState('profil')
  const [sidebarOuverte, setSidebarOuverte] = useState(false)
  const [modeNuit, setModeNuit] = useState(false)

  // Guard clause - pattern trÃ¨s important
  if (!user) {
    return <EcranConnexion />
  }

  // Logique des permissions
  const permissions = {
    canViewAnalytics: user.role === 'admin' || user.role === 'manager',
    canManageUsers: user.role === 'admin',
    canEditSettings: user.role !== 'guest'
  }

  // Gestion des notifications
  const notificationsNonLues = notifications.filter(n => !n.lue).length
  const notificationsUrgentes = notifications.filter(n => n.priorite === 'urgent').length

  // Rendu conditionnel intelligent
  const renderContenu = () => {
    switch (ongletActif) {
      case 'profil':
        return <ProfilUtilisateur user={user} />

      case 'notifications':
        return (
          <SectionNotifications
            notifications={notifications}
            onMarkAsRead={(id) => markNotificationAsRead(id)}
          />
        )

      case 'parametres':
        if (!permissions.canEditSettings) {
          return <AccesDenie message="Vous n'avez pas les permissions pour modifier les paramÃ¨tres" />
        }
        return <Parametres user={user} />

      case 'analytics':
        if (!permissions.canViewAnalytics) {
          return <AccesDenie message="AccÃ¨s limitÃ© aux administrateurs et managers" />
        }
        return <Analytics userRole={user.role} />

      case 'users':
        if (!permissions.canManageUsers) {
          return <AccesDenie message="Fonction rÃ©servÃ©e aux administrateurs" />
        }
        return <GestionUtilisateurs />

      default:
        return <Page404 />
    }
  }

  // Calcul dynamique des onglets disponibles
  const onglets = [
    { id: 'profil', nom: 'ğŸ‘¤ Profil', icone: 'ğŸ‘¤' },
    {
      id: 'notifications',
      nom: 'ğŸ”” Notifications',
      badge: notificationsNonLues,
      urgent: notificationsUrgentes > 0
    },
    ...(permissions.canEditSettings ? [{ id: 'parametres', nom: 'âš™ï¸ ParamÃ¨tres' }] : []),
    ...(permissions.canViewAnalytics ? [{ id: 'analytics', nom: 'ğŸ“Š Analytics' }] : []),
    ...(permissions.canManageUsers ? [{ id: 'users', nom: 'ğŸ‘¥ Utilisateurs' }] : [])
  ]

  return (
    <div className={`dashboard ${sidebarOuverte ? 'sidebar-open' : ''} ${modeNuit ? 'dark-mode' : ''}`}>

      <header className="dashboard-header">
        <div className="header-left">
          <button
            className="menu-toggle"
            onClick={() => setSidebarOuverte(!sidebarOuverte)}
            aria-label="Toggle sidebar"
          >
            â˜°
          </button>
          <h1>Dashboard</h1>
        </div>

        <div className="header-right">
          <button
            className="theme-toggle"
            onClick={() => setModeNuit(!modeNuit)}
            aria-label="Toggle dark mode"
          >
            {modeNuit ? 'â˜€ï¸' : 'ğŸŒ™'}
          </button>

          <div className="user-info">
            <img
              src={user.avatar || '/default-avatar.png'}
              alt={`Avatar de ${user.nom}`}
              className="user-avatar"
            />
            <div>
              <span className="user-name">ğŸ‘‹ {user.nom}</span>
              <span className="user-role">{user.role}</span>
            </div>
          </div>
        </div>
      </header>

      <aside className={`sidebar ${sidebarOuverte ? 'open' : ''}`}>
        <nav>
          <ul className="nav-list">
            {onglets.map(onglet => (
              <li key={onglet.id}>
                <button
                  className={`nav-button ${ongletActif === onglet.id ? 'active' : ''}`}
                  onClick={() => {
                    setOngletActif(onglet.id)
                    setSidebarOuverte(false) // Ferme sur mobile
                  }}
                >
                  <span className="nav-label">{onglet.nom}</span>

                  {onglet.badge > 0 && (
                    <span className={`badge ${onglet.urgent ? 'urgent' : ''}`}>
                      {onglet.badge}
                    </span>
                  )}
                </button>
              </li>
            ))}
          </ul>
        </nav>

        <div className="sidebar-footer">
          <button className="logout-btn">
            ğŸšª DÃ©connexion
          </button>
        </div>
      </aside>

      <main className="dashboard-content">
        <div className="content-header">
          <h2>{onglets.find(o => o.id === ongletActif)?.nom || 'Page'}</h2>
          {notificationsUrgentes > 0 && (
            <div className="alert-banner">
              âš ï¸ {notificationsUrgentes} notification(s) urgente(s)
            </div>
          )}
        </div>

        <div className="content-body">
          {renderContenu()}
        </div>
      </main>

      {/* Overlay pour mobile */}
      {sidebarOuverte && (
        <div
          className="sidebar-overlay"
          onClick={() => setSidebarOuverte(false)}
        />
      )}
    </div>
  )
}

// Composants helpers
function EcranConnexion() {
  return (
    <div className="login-screen">
      <div className="login-card">
        <h2>ğŸ” AccÃ¨s restreint</h2>
        <p>Veuillez vous connecter pour accÃ©der au dashboard</p>
        <button className="login-btn">Se connecter</button>
      </div>
    </div>
  )
}

function AccesDenie({ message }) {
  return (
    <div className="access-denied">
      <h3>â›” AccÃ¨s refusÃ©</h3>
      <p>{message}</p>
      <button onClick={() => window.history.back()}>
        â† Retour
      </button>
    </div>
  )
}

function Page404() {
  return (
    <div className="not-found">
      <h2>404 - Page non trouvÃ©e</h2>
      <p>Cette section n'existe pas ou plus.</p>
    </div>
  )
}
```

---

## Rendu Conditionnel - Techniques AvancÃ©es

### 1. Early Return Pattern

```jsx
function UserProfile({ user, loading, error }) {
  // Early returns pour gÃ©rer les cas d'erreur rapidement
  if (loading) {
    return <LoadingSpinner message="Chargement du profil..." />
  }

  if (error) {
    return <ErrorMessage error={error} retry={() => window.location.reload()} />
  }

  if (!user) {
    return <EmptyState message="Aucun utilisateur trouvÃ©" />
  }

  // Code principal seulement si tout va bien
  return (
    <div className="user-profile">
      <h1>Profil de {user.name}</h1>
      {/* ... reste du composant */}
    </div>
  )
}
```

### 2. Switch/Case avec JSX

```jsx
function StatusBadge({ status, user }) {
  const renderStatusBadge = () => {
    switch (status) {
      case 'online':
        return <span className="status online">ğŸŸ¢ En ligne</span>
      case 'offline':
        return <span className="status offline">ğŸ”´ Hors ligne</span>
      case 'away':
        return <span className="status away">ğŸŸ¡ Absent</span>
      case 'busy':
        return <span className="status busy">ğŸ”´ OccupÃ©</span>
      default:
        return <span className="status unknown">â“ Inconnu</span>
    }
  }

  return (
    <div className="user-status">
      <img src={user.avatar} alt={user.name} />
      <span>{user.name}</span>
      {renderStatusBadge()}
    </div>
  )
}
```

### 3. Rendu conditionnel avec logique complexe

```jsx
function ArticleCard({ article, user, permissions }) {
  const canEdit = permissions.canEdit && (user.id === article.authorId || user.role === 'admin')
  const canDelete = permissions.canDelete && user.role === 'admin'
  const isOwner = user.id === article.authorId
  const isPublished = article.status === 'published'

  return (
    <article className="article-card">
      <h2>{article.title}</h2>

      {/* Badge de statut */}
      {isPublished ? (
        <span className="badge published">âœ… PubliÃ©</span>
      ) : (
        <span className="badge draft">ğŸ“ Brouillon</span>
      )}

      <p>{article.excerpt}</p>

      {/* Actions conditionnelles */}
      <div className="article-actions">
        <button>ğŸ‘ï¸ Lire</button>

        {canEdit && (
          <button className="edit-btn">âœï¸ Modifier</button>
        )}

        {isOwner && !isPublished && (
          <button className="publish-btn">ğŸš€ Publier</button>
        )}

        {canDelete && (
          <button className="delete-btn">ğŸ—‘ï¸ Supprimer</button>
        )}
      </div>

      {/* Infos d'auteur */}
      <footer className="article-footer">
        <span>Par {article.author}</span>
        {isOwner && <span className="owner-badge">ğŸ‘‘ Votre article</span>}
        <time>{new Date(article.createdAt).toLocaleDateString()}</time>
      </footer>
    </article>
  )
}
```

---

## Performance et Bonnes Pratiques

### 1. Ã‰viter les re-renders inutiles

```jsx
// âŒ Mauvais - objet crÃ©Ã© Ã  chaque render
function BadExample() {
  const [user, setUser] = useState({ name: '', email: '' })

  return (
    <UserForm
      user={user}
      style={{ margin: '20px' }}  // âŒ Nouvel objet Ã  chaque render
      onSubmit={() => {           // âŒ Nouvelle fonction Ã  chaque render
        console.log('Submit')
      }}
    />
  )
}

// âœ… Bon - objets stables
function GoodExample() {
  const [user, setUser] = useState({ name: '', email: '' })

  // Style stable
  const formStyle = { margin: '20px' }

  // Fonction stable
  const handleSubmit = useCallback(() => {
    console.log('Submit')
  }, [])

  return (
    <UserForm
      user={user}
      style={formStyle}
      onSubmit={handleSubmit}
    />
  )
}
```

### 2. Gestion d'Ã©tat complexe

```jsx
function useFormState(initialData) {
  const [data, setData] = useState(initialData)
  const [errors, setErrors] = useState({})
  const [touched, setTouched] = useState({})

  const updateField = useCallback((field, value) => {
    setData(prev => ({ ...prev, [field]: value }))

    // Marquer comme touchÃ©
    setTouched(prev => ({ ...prev, [field]: true }))

    // Valider le champ
    if (touched[field]) {
      validateField(field, value)
    }
  }, [touched])

  const validateField = useCallback((field, value) => {
    // Logique de validation...
    setErrors(prev => ({ ...prev, [field]: error }))
  }, [])

  return {
    data,
    errors,
    touched,
    updateField,
    isValid: Object.keys(errors).length === 0
  }
}
```

---

## Points ClÃ©s Ã  Retenir

1. **Composants Fonctionnels** = standard moderne React (depuis 2019)
2. **useState** = mÃ©moire du composant, suit des rÃ¨gles strictes
3. **Props** = communication unidirectionnelle parent â†’ enfant
4. **Hooks uniquement au top level** = rÃ¨gle NON-NÃ‰GOCIABLE
5. **Early returns** = pattern pour gÃ©rer les cas d'erreur
6. **State isolation** = chaque instance a son Ã©tat privÃ©
7. **Rendu conditionnel** = if/else, ternaire, &&, switch/case
8. **Performance** = Ã©viter les re-renders inutiles

---

## Ressources ComplÃ©mentaires

- ğŸ¯ [Composants React officiels](https://react.dev/reference/react/Component)
- ğŸ“š [Votre premier composant](https://react.dev/learn/your-first-component)
- ğŸ”§ [Passer des props](https://react.dev/learn/passing-props-to-a-component)
- ğŸ’¾ [State = mÃ©moire du composant](https://react.dev/learn/state-a-components-memory)
- ğŸ”€ [Rendu conditionnel](https://react.dev/learn/conditional-rendering)
- ğŸ“– [Thinking in React](https://react.dev/learn/thinking-in-react)

**Prochaine Ã©tape :** Les hooks avancÃ©s (useEffect, useContext, useMemo...) dans `15.0.4-Hooks.md` !
