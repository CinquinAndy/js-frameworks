# React - Types et Validation avec Zod & TypeScript

Salut ! Maintenant qu'on sait faire des formulaires, parlons de la **validation** des donnÃ©es

---

## Le ProblÃ¨me avec la Validation

### TypeScript, c'est bien mais

TypeScript te protÃ¨ge **pendant le dÃ©veloppement**, mais :

```tsx
// âœ… TypeScript valide Ã§a au build
interface User {
  name: string
  age: number
  email: string
}

function processUser(user: User) {
  // TypeScript sait que user.name est un string
  console.log(user.name.toUpperCase())
}

// âŒ Mais Ã§a peut arriver Ã  runtime !
const userFromAPI = JSON.parse(response) // any ğŸ˜±
processUser(userFromAPI) // BOOM si userFromAPI n'a pas la bonne structure !
```

### Les Dangers du Runtime

- ğŸŒ **APIs externes** : peuvent renvoyer n'importe quoi
- ğŸ“ **Formulaires utilisateur** : donnÃ©es non fiables
- ğŸª **LocalStorage/SessionStorage** : peut Ãªtre corrompu
- ğŸ”— **URL parameters** : manipulables cÃ´tÃ© client

### La Solution ? Validation Runtime

Il nous faut valider les donnÃ©es **Ã  l'exÃ©cution** ET avoir la sÃ©curitÃ© des types TypeScript !

---

## Zod - Le Saint Graal ! âš¡

### Installation

```bash
npm install zod
```

### Philosophie de Zod

1. **Schema-first** : tu dÃ©finis le schÃ©ma une fois
2. **Type inference** : TypeScript types gÃ©nÃ©rÃ©s automatiquement
3. **Runtime validation** : validation Ã  l'exÃ©cution
4. **Developer-friendly** : messages d'erreur clairs

### Premier Exemple

```tsx
import { z } from 'zod'

// ğŸ”¥ DÃ©finis le schÃ©ma une fois
const UserSchema = z.object({
  name: z.string().min(1, 'Nom requis'),
  age: z.number().min(0).max(120),
  email: z.string().email('Email invalide'),
})

// âœ… Type TypeScript gÃ©nÃ©rÃ© automatiquement !
type User = z.infer<typeof UserSchema>
// type User = { name: string; age: number; email: string }

// ğŸ›¡ï¸ Validation runtime
function createUser(data: unknown): User {
  // Ã‡a peut throw une ZodError si invalid
  return UserSchema.parse(data)
}

// ğŸš€ Utilisation
try {
  const user = createUser({
    name: "Andy",
    age: 25,
    email: "andy@example.com"
  })
  console.log(user.name) // TypeScript sait que c'est un string !
} catch (error) {
  if (error instanceof z.ZodError) {
    console.log(error.issues) // DÃ©tails des erreurs
  }
}
```

---

## Validation de DonnÃ©es API

### ProblÃ¨me Classique

```tsx
// âŒ Code dangereux qu'on voit partout
async function getUser(id: string) {
  const response = await fetch(`/api/users/${id}`)
  const user = await response.json() // any - DANGER !
  
  // Qu'est-ce qui se passe si l'API renvoie autre chose ?
  return user.name.toUpperCase() // PEUT CRASH !
}
```

### Solution Zod

```tsx
import { z } from 'zod'

// SchÃ©ma de validation
const UserApiSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
  avatar: z.string().url().optional(),
  createdAt: z.string().datetime(),
  settings: z.object({
    theme: z.enum(['light', 'dark']),
    notifications: z.boolean()
  })
})

type UserApi = z.infer<typeof UserApiSchema>

async function getUser(id: string): Promise<UserApi> {
  try {
    const response = await fetch(`/api/users/${id}`)
    if (!response.ok) throw new Error('API Error')
    
    const data = await response.json()
    
    // ğŸ›¡ï¸ Validation des donnÃ©es de l'API
    const user = UserApiSchema.parse(data)
    
    return user // 100% sÃ»r maintenant !
  } catch (error) {
    if (error instanceof z.ZodError) {
      console.error('Invalid API response:', error.issues)
    }
    throw error
  }
}

// ğŸš€ Utilisation sÃ»re
const user = await getUser('123')
console.log(user.name.toUpperCase()) // âœ… SÃ»r !
console.log(user.settings.theme) // âœ… TypeScript autocomplete parfait
```

---

## Validation de Formulaires AvancÃ©e

### SchÃ©mas Complexes

```tsx
const ContactFormSchema = z.object({
  // Validation string avancÃ©e
  name: z.string()
    .min(1, 'Nom requis')
    .min(2, 'Au moins 2 caractÃ¨res')
    .max(50, 'Max 50 caractÃ¨res')
    .regex(/^[a-zA-ZÃ€-Ã¿\s]+$/, 'CaractÃ¨res invalides'),
  
  // Email avec domaine whitelist
  email: z.string()
    .email('Format email invalide')
    .refine(
      email => ['gmail.com', 'outlook.com', 'company.com'].includes(email.split('@')[1]),
      'Domaine email non autorisÃ©'
    ),
  
  // NumÃ©ro de tÃ©lÃ©phone franÃ§ais
  phone: z.string()
    .regex(/^(?:(?:\+33|0)[1-9](?:[0-9]{8}))$/, 'NumÃ©ro franÃ§ais invalide')
    .optional(),
  
  // Ã‚ge avec validation mÃ©tier
  age: z.number()
    .min(16, 'Vous devez avoir au moins 16 ans')
    .max(100, 'Ã‚ge invalide'),
  
  // Password avec critÃ¨res de sÃ©curitÃ©
  password: z.string()
    .min(8, 'Au moins 8 caractÃ¨res')
    .regex(/[A-Z]/, 'Au moins une majuscule')
    .regex(/[a-z]/, 'Au moins une minuscule')
    .regex(/[0-9]/, 'Au moins un chiffre')
    .regex(/[^A-Za-z0-9]/, 'Au moins un caractÃ¨re spÃ©cial'),
  
  // Confirmation mot de passe
  confirmPassword: z.string(),
  
  // Acceptation conditions
  acceptTerms: z.boolean().refine(val => val === true, 'Conditions requises'),
  
  // Array de hobbies avec validation
  hobbies: z.array(
    z.object({
      name: z.string().min(1),
      level: z.enum(['beginner', 'intermediate', 'expert'])
    })
  ).min(1, 'Au moins un hobby').max(5, 'Max 5 hobbies')
})
  // Validation cross-field
  .refine(data => data.password === data.confirmPassword, {
    message: 'Mots de passe diffÃ©rents',
    path: ['confirmPassword'] // Erreur sur le champ confirmPassword
  })

type ContactFormData = z.infer<typeof ContactFormSchema>
```

---

## Validation API Routes (Next.js)

### Server-Side Validation

```tsx
// app/api/users/route.ts
import { z } from 'zod'
import { NextRequest, NextResponse } from 'next/server'

const CreateUserSchema = z.object({
  name: z.string().min(1).max(100),
  email: z.string().email(),
  age: z.number().min(16).max(100)
})

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // ğŸ›¡ï¸ Validation des donnÃ©es reÃ§ues
    const userData = CreateUserSchema.parse(body)
    
    // DonnÃ©es validÃ©es, on peut les utiliser en sÃ©curitÃ©
    const user = await createUserInDatabase(userData)
    
    return NextResponse.json({ success: true, user })
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Validation failed',
          details: error.issues 
        },
        { status: 400 }
      )
    }
    
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
```

---

## Techniques AvancÃ©es

### SchÃ©mas Conditionnels

```tsx
const UserSchema = z.object({
  type: z.enum(['admin', 'user']),
  name: z.string(),
  email: z.string().email()
})
  .and(
    z.discriminatedUnion('type', [
      z.object({
        type: z.literal('admin'),
        permissions: z.array(z.string()).min(1)
      }),
      z.object({
        type: z.literal('user'),
        department: z.string()
      })
    ])
  )
```

### Transformation de DonnÃ©es

```tsx
const DateSchema = z.string()
  .datetime()
  .transform(str => new Date(str))

const PriceSchema = z.string()
  .regex(/^\d+(\.\d{2})?$/)
  .transform(str => parseFloat(str))

const ProductSchema = z.object({
  name: z.string(),
  price: PriceSchema, // string â†’ number
  createdAt: DateSchema // string â†’ Date
})
```

## Ressources Pour Aller Plus Loin

- ğŸ“š [Zod Documentation](https://zod.dev/)
- ğŸ¥ [Zod Tutorial](https://www.youtube.com/watch?v=L6BE-U3oy80)
- ğŸ“– [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- ğŸ”§ [React Hook Form + Zod](https://react-hook-form.com/get-started#SchemaValidation)
- âš¡ [Total TypeScript](https://www.totaltypescript.com/)
