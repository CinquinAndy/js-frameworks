# React - useCallback : Mémorisation de Fonctions

**useCallback** = Éviter les **fonctions recréées** ! 🎯

Quand tu passes des fonctions en props à des composants memo(), useCallback va **mémoriser** la fonction et éviter les re-renders inutiles.

---

## Le Problème des Fonctions Recréées

### Nouvelles Fonctions à Chaque Rendu

```jsx
function ProblematicParent() {
  const [count, setCount] = useState(0)
  const [items, setItems] = useState([])
  const [name, setName] = useState('')

  // ❌ PROBLÈME - Nouvelle fonction à chaque rendu !
  const addItem = (text) => {
    setItems(prev => [...prev, { id: Date.now(), text }])
  }

  // ❌ PROBLÈME - Nouvelle fonction à chaque rendu !
  const handleClick = (id) => {
    console.log('Item clicked:', id)
  }

  // ❌ PROBLÈME - Nouvelle fonction à chaque rendu !
  const handleSubmit = (e) => {
    e.preventDefault()
    console.log('Form submitted')
  }

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
      
      {/* Ces composants re-render même si leurs props logiques n'ont pas changé ! */}
      <ExpensiveForm onSubmit={handleSubmit} />
      <ExpensiveList items={items} onItemClick={handleClick} />
      <ExpensiveAddButton onAdd={addItem} />
    </div>
  )
}

// Ces composants optimisés ne servent à rien car les fonctions changent toujours !
const ExpensiveForm = memo(function ExpensiveForm({ onSubmit }) {
  console.log('📝 ExpensiveForm re-rendu') // ← Toujours appelé !
  return <form onSubmit={onSubmit}><button>Submit</button></form>
})

const ExpensiveList = memo(function ExpensiveList({ items, onItemClick }) {
  console.log('📝 ExpensiveList re-rendu') // ← Toujours appelé !
  return (
    <ul>
      {items.map(item => (
        <li key={item.id} onClick={() => onItemClick(item.id)}>
          {item.text}
        </li>
      ))}
    </ul>
  )
})

const ExpensiveAddButton = memo(function ExpensiveAddButton({ onAdd }) {
  console.log('🔘 ExpensiveAddButton re-rendu') // ← Toujours appelé !
  return <button onClick={() => onAdd('New item')}>Add Item</button>
})
```

---

## useCallback à la Rescousse

### Syntaxe et Usage Basique

```jsx
import { useCallback } from 'react'

function OptimizedParent() {
  const [count, setCount] = useState(0)
  const [items, setItems] = useState([])
  const [name, setName] = useState('')

  // ✅ SOLUTION - Fonction mémorisée stable
  const addItem = useCallback((text) => {
    setItems(prev => [...prev, { id: Date.now(), text, completed: false }])
  }, []) // ← Pas de dépendances = fonction stable

  // ✅ SOLUTION - Fonction mémorisée stable
  const handleClick = useCallback((id) => {
    console.log('Item clicked:', id)
    // Logique qui n'a pas de dépendances externes
  }, [])

  // ✅ SOLUTION - Fonction avec dépendances
  const addItemWithPrefix = useCallback((text) => {
    const prefix = name ? `[${name}] ` : ''
    setItems(prev => [...prev, { 
      id: Date.now(), 
      text: prefix + text,
      completed: false 
    }])
  }, [name]) // ← Se recrée seulement si name change

  // ✅ SOLUTION - Event handler optimisé
  const handleCountChange = useCallback((increment) => {
    setCount(prev => prev + increment)
  }, [])

  // ✅ SOLUTION - Fonction de suppression
  const removeItem = useCallback((id) => {
    setItems(prev => prev.filter(item => item.id !== id))
  }, [])

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1 (non-optimisé)</button>
      
      <input 
        value={name} 
        onChange={e => setName(e.target.value)} 
        placeholder="Préfixe..."
      />
      
      {/* Maintenant ces composants ne re-render que si nécessaire ! */}
      <OptimizedButton onClick={handleCountChange} increment={1}>+1</OptimizedButton>
      <OptimizedButton onClick={handleCountChange} increment={5}>+5</OptimizedButton>
      
      <OptimizedList 
        items={items} 
        onItemClick={handleClick}
        onItemRemove={removeItem}
      />
      
      <OptimizedAddForm 
        onAdd={addItem}
        onAddWithPrefix={addItemWithPrefix}
      />
    </div>
  )
}

// Maintenant ces composants ne re-render que si leurs props changent vraiment !
const OptimizedButton = memo(function OptimizedButton({ onClick, increment, children }) {
  console.log(`🔘 OptimizedButton (+${increment}) re-rendu`)
  
  return (
    <button onClick={() => onClick(increment)} style={{ margin: '5px' }}>
      {children}
    </button>
  )
})

const OptimizedList = memo(function OptimizedList({ items, onItemClick, onItemRemove }) {
  console.log('📝 OptimizedList re-rendu')
  
  return (
    <ul>
      {items.map(item => (
        <li key={item.id} style={{ display: 'flex', justifyContent: 'space-between' }}>
          <span onClick={() => onItemClick(item.id)} style={{ cursor: 'pointer' }}>
            {item.text}
          </span>
          <button onClick={() => onItemRemove(item.id)}>❌</button>
        </li>
      ))}
    </ul>
  )
})

const OptimizedAddForm = memo(function OptimizedAddForm({ onAdd, onAddWithPrefix }) {
  console.log('📝 OptimizedAddForm re-rendu')
  const [input, setInput] = useState('')

  const handleSubmit = (e) => {
    e.preventDefault()
    if (input.trim()) {
      onAdd(input.trim())
      setInput('')
    }
  }

  const handleSubmitWithPrefix = (e) => {
    e.preventDefault()
    if (input.trim()) {
      onAddWithPrefix(input.trim())
      setInput('')
    }
  }

  return (
    <form>
      <input
        value={input}
        onChange={e => setInput(e.target.value)}
        placeholder="Nouvel élément..."
      />
      <button type="submit" onClick={handleSubmit}>Ajouter</button>
      <button type="button" onClick={handleSubmitWithPrefix}>Avec préfixe</button>
    </form>
  )
})
```

---

## Exemples Pratiques

### Todo App Optimisée

```jsx
function TodoApp() {
  const [todos, setTodos] = useState([])
  const [filter, setFilter] = useState('all')
  const [editingId, setEditingId] = useState(null)

  // ✅ Actions mémorisées pour optimiser les composants enfants
  const addTodo = useCallback((text) => {
    setTodos(prev => [...prev, {
      id: Date.now(),
      text: text.trim(),
      completed: false,
      createdAt: new Date().toISOString()
    }])
  }, [])

  const toggleTodo = useCallback((id) => {
    setTodos(prev => 
      prev.map(todo =>
        todo.id === id 
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    )
  }, [])

  const deleteTodo = useCallback((id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id))
  }, [])

  const editTodo = useCallback((id, newText) => {
    if (newText.trim()) {
      setTodos(prev => 
        prev.map(todo =>
          todo.id === id 
            ? { ...todo, text: newText.trim() }
            : todo
        )
      )
    }
    setEditingId(null)
  }, [])

  const startEditing = useCallback((id) => {
    setEditingId(id)
  }, [])

  const cancelEditing = useCallback(() => {
    setEditingId(null)
  }, [])

  const clearCompleted = useCallback(() => {
    setTodos(prev => prev.filter(todo => !todo.completed))
  }, [])

  // ✅ Mémoriser aussi les handlers de filtres
  const handleFilterChange = useCallback((newFilter) => {
    setFilter(newFilter)
  }, [])

  // Computed values (pas besoin de useCallback pour ça)
  const filteredTodos = useMemo(() => {
    switch (filter) {
      case 'active':
        return todos.filter(todo => !todo.completed)
      case 'completed':
        return todos.filter(todo => todo.completed)
      default:
        return todos
    }
  }, [todos, filter])

  const stats = useMemo(() => ({
    total: todos.length,
    active: todos.filter(t => !t.completed).length,
    completed: todos.filter(t => t.completed).length
  }), [todos])

  return (
    <div style={{ maxWidth: '600px', margin: '0 auto', padding: '20px' }}>
      <h1>Todo App Optimisée</h1>
      
      <TodoInput onAdd={addTodo} />
      
      <TodoFilters 
        currentFilter={filter}
        onFilterChange={handleFilterChange}
        stats={stats}
      />
      
      <TodoList
        todos={filteredTodos}
        editingId={editingId}
        onToggle={toggleTodo}
        onDelete={deleteTodo}
        onEdit={editTodo}
        onStartEditing={startEditing}
        onCancelEditing={cancelEditing}
      />
      
      {stats.completed > 0 && (
        <div style={{ marginTop: '20px' }}>
          <button 
            onClick={clearCompleted}
            style={{ background: '#dc3545', color: 'white', padding: '10px 15px' }}
          >
            Supprimer les terminées ({stats.completed})
          </button>
        </div>
      )}
    </div>
  )
}

const TodoInput = memo(function TodoInput({ onAdd }) {
  console.log('📝 TodoInput re-rendu')
  const [input, setInput] = useState('')

  const handleSubmit = (e) => {
    e.preventDefault()
    if (input.trim()) {
      onAdd(input)
      setInput('')
    }
  }

  return (
    <form onSubmit={handleSubmit} style={{ marginBottom: '20px' }}>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Nouvelle tâche..."
        style={{ padding: '10px', width: '70%', marginRight: '10px' }}
      />
      <button type="submit" style={{ padding: '10px 20px' }}>
        Ajouter
      </button>
    </form>
  )
})

const TodoFilters = memo(function TodoFilters({ currentFilter, onFilterChange, stats }) {
  console.log('🔍 TodoFilters re-rendu')
  
  const filters = [
    { key: 'all', label: `Toutes (${stats.total})` },
    { key: 'active', label: `Actives (${stats.active})` },
    { key: 'completed', label: `Terminées (${stats.completed})` }
  ]

  return (
    <div style={{ marginBottom: '20px', textAlign: 'center' }}>
      {filters.map(filter => (
        <button
          key={filter.key}
          onClick={() => onFilterChange(filter.key)}
          style={{
            padding: '8px 16px',
            margin: '0 5px',
            backgroundColor: currentFilter === filter.key ? '#007bff' : '#f8f9fa',
            color: currentFilter === filter.key ? 'white' : 'black',
            border: '1px solid #ddd',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        >
          {filter.label}
        </button>
      ))}
    </div>
  )
})

const TodoList = memo(function TodoList({ 
  todos, 
  editingId, 
  onToggle, 
  onDelete, 
  onEdit, 
  onStartEditing, 
  onCancelEditing 
}) {
  console.log('📋 TodoList re-rendu')
  
  return (
    <ul style={{ listStyle: 'none', padding: 0 }}>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          isEditing={editingId === todo.id}
          onToggle={() => onToggle(todo.id)}
          onDelete={() => onDelete(todo.id)}
          onEdit={(newText) => onEdit(todo.id, newText)}
          onStartEditing={() => onStartEditing(todo.id)}
          onCancelEditing={onCancelEditing}
        />
      ))}
    </ul>
  )
})

const TodoItem = memo(function TodoItem({ 
  todo, 
  isEditing, 
  onToggle, 
  onDelete, 
  onEdit, 
  onStartEditing, 
  onCancelEditing 
}) {
  const [editText, setEditText] = useState(todo.text)

  // Reset du texte d'édition quand on commence à éditer
  useEffect(() => {
    if (isEditing) {
      setEditText(todo.text)
    }
  }, [isEditing, todo.text])

  const handleEdit = () => {
    onEdit(editText)
    setEditText(todo.text)
  }

  const handleCancel = () => {
    setEditText(todo.text)
    onCancelEditing()
  }

  return (
    <li style={{
      display: 'flex',
      alignItems: 'center',
      padding: '12px',
      borderBottom: '1px solid #eee',
      backgroundColor: todo.completed ? '#f8f9fa' : 'white'
    }}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={onToggle}
        style={{ marginRight: '12px' }}
      />

      {isEditing ? (
        <div style={{ flex: 1, display: 'flex', alignItems: 'center' }}>
          <input
            value={editText}
            onChange={(e) => setEditText(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter') handleEdit()
              if (e.key === 'Escape') handleCancel()
            }}
            autoFocus
            style={{ flex: 1, padding: '8px', marginRight: '8px' }}
          />
          <button onClick={handleEdit} style={{ marginRight: '4px' }}>✅</button>
          <button onClick={handleCancel}>❌</button>
        </div>
      ) : (
        <>
          <span
            style={{
              flex: 1,
              textDecoration: todo.completed ? 'line-through' : 'none',
              color: todo.completed ? '#666' : 'black',
              cursor: 'pointer'
            }}
            onDoubleClick={onStartEditing}
          >
            {todo.text}
          </span>
          <button 
            onClick={onStartEditing}
            style={{ marginRight: '8px', padding: '4px 8px' }}
          >
            ✏️
          </button>
          <button 
            onClick={onDelete}
            style={{ background: '#dc3545', color: 'white', padding: '4px 8px' }}
          >
            🗑️
          </button>
        </>
      )}
    </li>
  )
})
```

### Système d'Events Optimisé

```jsx
function EventsSystem() {
  const [events, setEvents] = useState([])
  const [selectedCategory, setSelectedCategory] = useState('all')
  const [sortBy, setSortBy] = useState('date')

  // ✅ Event handlers mémorisés
  const addEvent = useCallback((eventData) => {
    setEvents(prev => [...prev, {
      ...eventData,
      id: Date.now(),
      createdAt: new Date().toISOString()
    }])
  }, [])

  const updateEvent = useCallback((id, updates) => {
    setEvents(prev => 
      prev.map(event =>
        event.id === id ? { ...event, ...updates } : event
      )
    )
  }, [])

  const deleteEvent = useCallback((id) => {
    setEvents(prev => prev.filter(event => event.id !== id))
  }, [])

  const toggleEventStatus = useCallback((id) => {
    setEvents(prev => 
      prev.map(event =>
        event.id === id 
          ? { ...event, completed: !event.completed }
          : event
      )
    )
  }, [])

  // ✅ Filter handlers mémorisés
  const handleCategoryChange = useCallback((category) => {
    setSelectedCategory(category)
  }, [])

  const handleSortChange = useCallback((sort) => {
    setSortBy(sort)
  }, [])

  // ✅ Batch operations mémorisées
  const markAllCompleted = useCallback(() => {
    setEvents(prev => 
      prev.map(event => ({ ...event, completed: true }))
    )
  }, [])

  const deleteCompleted = useCallback(() => {
    setEvents(prev => prev.filter(event => !event.completed))
  }, [])

  const duplicateEvent = useCallback((id) => {
    setEvents(prev => {
      const eventToDuplicate = prev.find(event => event.id === id)
      if (!eventToDuplicate) return prev
      
      return [...prev, {
        ...eventToDuplicate,
        id: Date.now(),
        title: `${eventToDuplicate.title} (Copie)`,
        completed: false,
        createdAt: new Date().toISOString()
      }]
    })
  }, [])

  return (
    <div style={{ maxWidth: '800px', margin: '0 auto', padding: '20px' }}>
      <h1>Système d'Events Optimisé</h1>
      
      <EventForm onAdd={addEvent} />
      
      <EventControls
        selectedCategory={selectedCategory}
        sortBy={sortBy}
        onCategoryChange={handleCategoryChange}
        onSortChange={handleSortChange}
        onMarkAllCompleted={markAllCompleted}
        onDeleteCompleted={deleteCompleted}
        eventCount={events.length}
        completedCount={events.filter(e => e.completed).length}
      />
      
      <EventList
        events={events}
        selectedCategory={selectedCategory}
        sortBy={sortBy}
        onUpdate={updateEvent}
        onDelete={deleteEvent}
        onToggleStatus={toggleEventStatus}
        onDuplicate={duplicateEvent}
      />
    </div>
  )
}

const EventForm = memo(function EventForm({ onAdd }) {
  console.log('📝 EventForm re-rendu')
  const [formData, setFormData] = useState({
    title: '',
    category: 'work',
    priority: 'medium',
    date: '',
    description: ''
  })

  const handleSubmit = (e) => {
    e.preventDefault()
    if (formData.title.trim()) {
      onAdd(formData)
      setFormData({
        title: '',
        category: 'work',
        priority: 'medium',
        date: '',
        description: ''
      })
    }
  }

  const handleChange = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }))
  }

  return (
    <form onSubmit={handleSubmit} style={{ 
      background: '#f8f9fa', 
      padding: '20px', 
      borderRadius: '8px', 
      marginBottom: '20px' 
    }}>
      <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '10px' }}>
        <input
          value={formData.title}
          onChange={(e) => handleChange('title', e.target.value)}
          placeholder="Titre de l'event..."
          required
        />
        
        <select
          value={formData.category}
          onChange={(e) => handleChange('category', e.target.value)}
        >
          <option value="work">Travail</option>
          <option value="personal">Personnel</option>
          <option value="health">Santé</option>
          <option value="social">Social</option>
        </select>
        
        <select
          value={formData.priority}
          onChange={(e) => handleChange('priority', e.target.value)}
        >
          <option value="low">Basse</option>
          <option value="medium">Moyenne</option>
          <option value="high">Haute</option>
        </select>
        
        <input
          type="date"
          value={formData.date}
          onChange={(e) => handleChange('date', e.target.value)}
        />
      </div>
      
      <textarea
        value={formData.description}
        onChange={(e) => handleChange('description', e.target.value)}
        placeholder="Description (optionnel)..."
        style={{ width: '100%', marginTop: '10px' }}
        rows={3}
      />
      
      <button type="submit" style={{ marginTop: '10px', padding: '10px 20px' }}>
        Ajouter Event
      </button>
    </form>
  )
})

const EventControls = memo(function EventControls({
  selectedCategory,
  sortBy,
  onCategoryChange,
  onSortChange,
  onMarkAllCompleted,
  onDeleteCompleted,
  eventCount,
  completedCount
}) {
  console.log('🎛️ EventControls re-rendu')
  
  return (
    <div style={{ 
      display: 'flex', 
      justifyContent: 'space-between', 
      alignItems: 'center', 
      marginBottom: '20px',
      padding: '15px',
      background: '#e9ecef',
      borderRadius: '8px'
    }}>
      <div>
        <select value={selectedCategory} onChange={(e) => onCategoryChange(e.target.value)}>
          <option value="all">Toutes catégories</option>
          <option value="work">Travail</option>
          <option value="personal">Personnel</option>
          <option value="health">Santé</option>
          <option value="social">Social</option>
        </select>
        
        <select value={sortBy} onChange={(e) => onSortChange(e.target.value)} style={{ marginLeft: '10px' }}>
          <option value="date">Par date</option>
          <option value="priority">Par priorité</option>
          <option value="title">Par titre</option>
          <option value="category">Par catégorie</option>
        </select>
      </div>
      
      <div>
        <span style={{ marginRight: '15px' }}>
          {eventCount} events ({completedCount} terminés)
        </span>
        <button onClick={onMarkAllCompleted} style={{ marginRight: '10px' }}>
          ✅ Tout marquer
        </button>
        <button onClick={onDeleteCompleted} disabled={completedCount === 0}>
          🗑️ Supprimer terminés
        </button>
      </div>
    </div>
  )
})

const EventList = memo(function EventList({ 
  events, 
  selectedCategory, 
  sortBy, 
  onUpdate, 
  onDelete, 
  onToggleStatus, 
  onDuplicate 
}) {
  console.log('📋 EventList re-rendu')
  
  const filteredAndSortedEvents = useMemo(() => {
    let filtered = events
    
    if (selectedCategory !== 'all') {
      filtered = filtered.filter(event => event.category === selectedCategory)
    }
    
    return filtered.sort((a, b) => {
      switch (sortBy) {
        case 'priority':
          const priorityOrder = { high: 3, medium: 2, low: 1 }
          return priorityOrder[b.priority] - priorityOrder[a.priority]
        case 'title':
          return a.title.localeCompare(b.title)
        case 'category':
          return a.category.localeCompare(b.category)
        case 'date':
        default:
          return new Date(b.createdAt) - new Date(a.createdAt)
      }
    })
  }, [events, selectedCategory, sortBy])

  return (
    <div>
      {filteredAndSortedEvents.map(event => (
        <EventItem
          key={event.id}
          event={event}
          onUpdate={(updates) => onUpdate(event.id, updates)}
          onDelete={() => onDelete(event.id)}
          onToggleStatus={() => onToggleStatus(event.id)}
          onDuplicate={() => onDuplicate(event.id)}
        />
      ))}
    </div>
  )
})

const EventItem = memo(function EventItem({ event, onUpdate, onDelete, onToggleStatus, onDuplicate }) {
  const [isEditing, setIsEditing] = useState(false)
  
  return (
    <div style={{
      border: '1px solid #ddd',
      borderRadius: '8px',
      padding: '15px',
      marginBottom: '10px',
      backgroundColor: event.completed ? '#f8f9fa' : 'white',
      opacity: event.completed ? 0.7 : 1
    }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
        <div style={{ flex: 1 }}>
          <div style={{ display: 'flex', alignItems: 'center', marginBottom: '8px' }}>
            <input
              type="checkbox"
              checked={event.completed}
              onChange={onToggleStatus}
              style={{ marginRight: '10px' }}
            />
            <h4 style={{ 
              margin: 0, 
              textDecoration: event.completed ? 'line-through' : 'none' 
            }}>
              {event.title}
            </h4>
            <span style={{
              marginLeft: '10px',
              padding: '2px 8px',
              borderRadius: '12px',
              fontSize: '12px',
              backgroundColor: 
                event.priority === 'high' ? '#dc3545' :
                event.priority === 'medium' ? '#ffc107' : '#28a745',
              color: 'white'
            }}>
              {event.priority}
            </span>
          </div>
          
          <div style={{ color: '#666', fontSize: '14px' }}>
            <span>Catégorie: {event.category}</span>
            {event.date && <span style={{ marginLeft: '15px' }}>Date: {event.date}</span>}
          </div>
          
          {event.description && (
            <p style={{ margin: '8px 0', color: '#555' }}>
              {event.description}
            </p>
          )}
        </div>
        
        <div style={{ display: 'flex', gap: '8px' }}>
          <button onClick={() => setIsEditing(true)}>✏️</button>
          <button onClick={onDuplicate}>📋</button>
          <button onClick={onDelete} style={{ color: '#dc3545' }}>🗑️</button>
        </div>
      </div>
    </div>
  )
})
```

---

## Patterns Avancés

### Custom Hooks avec useCallback

```jsx
// Hook custom avec callbacks optimisés
function useOptimizedApi(baseUrl) {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)

  // ✅ Fonctions d'API mémorisées
  const get = useCallback(async (endpoint) => {
    try {
      setLoading(true)
      setError(null)
      const response = await fetch(`${baseUrl}${endpoint}`)
      if (!response.ok) throw new Error(`HTTP ${response.status}`)
      const result = await response.json()
      setData(result)
      return result
    } catch (err) {
      setError(err.message)
      throw err
    } finally {
      setLoading(false)
    }
  }, [baseUrl])

  const post = useCallback(async (endpoint, body) => {
    try {
      setLoading(true)
      setError(null)
      const response = await fetch(`${baseUrl}${endpoint}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      })
      if (!response.ok) throw new Error(`HTTP ${response.status}`)
      const result = await response.json()
      setData(result)
      return result
    } catch (err) {
      setError(err.message)
      throw err
    } finally {
      setLoading(false)
    }
  }, [baseUrl])

  const put = useCallback(async (endpoint, body) => {
    try {
      setLoading(true)
      setError(null)
      const response = await fetch(`${baseUrl}${endpoint}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      })
      if (!response.ok) throw new Error(`HTTP ${response.status}`)
      const result = await response.json()
      setData(result)
      return result
    } catch (err) {
      setError(err.message)
      throw err
    } finally {
      setLoading(false)
    }
  }, [baseUrl])

  const del = useCallback(async (endpoint) => {
    try {
      setLoading(true)
      setError(null)
      const response = await fetch(`${baseUrl}${endpoint}`, {
        method: 'DELETE'
      })
      if (!response.ok) throw new Error(`HTTP ${response.status}`)
      setData(null)
      return true
    } catch (err) {
      setError(err.message)
      throw err
    } finally {
      setLoading(false)
    }
  }, [baseUrl])

  const reset = useCallback(() => {
    setData(null)
    setError(null)
    setLoading(false)
  }, [])

  return {
    data,
    loading,
    error,
    get,
    post,
    put,
    delete: del,
    reset
  }
}

// Utilisation du hook avec des composants optimisés
function UserManager() {
  const api = useOptimizedApi('/api')
  const [users, setUsers] = useState([])

  const handleLoadUsers = useCallback(async () => {
    try {
      const result = await api.get('/users')
      setUsers(result)
    } catch (error) {
      console.error('Erreur chargement users:', error)
    }
  }, [api.get])

  const handleCreateUser = useCallback(async (userData) => {
    try {
      const newUser = await api.post('/users', userData)
      setUsers(prev => [...prev, newUser])
    } catch (error) {
      console.error('Erreur création user:', error)
    }
  }, [api.post])

  const handleUpdateUser = useCallback(async (id, userData) => {
    try {
      const updatedUser = await api.put(`/users/${id}`, userData)
      setUsers(prev => prev.map(user => 
        user.id === id ? updatedUser : user
      ))
    } catch (error) {
      console.error('Erreur mise à jour user:', error)
    }
  }, [api.put])

  const handleDeleteUser = useCallback(async (id) => {
    try {
      await api.delete(`/users/${id}`)
      setUsers(prev => prev.filter(user => user.id !== id))
    } catch (error) {
      console.error('Erreur suppression user:', error)
    }
  }, [api.delete])

  return (
    <div>
      <h3>User Manager avec API Optimisée</h3>
      
      <UserControls 
        onLoadUsers={handleLoadUsers}
        loading={api.loading}
      />
      
      <UserForm onCreateUser={handleCreateUser} />
      
      <UserList 
        users={users}
        onUpdateUser={handleUpdateUser}
        onDeleteUser={handleDeleteUser}
      />
      
      {api.error && (
        <div style={{ color: 'red', marginTop: '10px' }}>
          Erreur: {api.error}
        </div>
      )}
    </div>
  )
}
```

### Event System avec useCallback

```jsx
function useEventSystem() {
  const [listeners, setListeners] = useState(new Map())

  const addEventListener = useCallback((eventName, callback) => {
    setListeners(prev => {
      const newListeners = new Map(prev)
      const eventListeners = newListeners.get(eventName) || []
      newListeners.set(eventName, [...eventListeners, callback])
      return newListeners
    })

    // Retourner une fonction de cleanup
    return () => {
      setListeners(prev => {
        const newListeners = new Map(prev)
        const eventListeners = newListeners.get(eventName) || []
        const filteredListeners = eventListeners.filter(cb => cb !== callback)
        
        if (filteredListeners.length === 0) {
          newListeners.delete(eventName)
        } else {
          newListeners.set(eventName, filteredListeners)
        }
        
        return newListeners
      })
    }
  }, [])

  const removeEventListener = useCallback((eventName, callback) => {
    setListeners(prev => {
      const newListeners = new Map(prev)
      const eventListeners = newListeners.get(eventName) || []
      const filteredListeners = eventListeners.filter(cb => cb !== callback)
      
      if (filteredListeners.length === 0) {
        newListeners.delete(eventName)
      } else {
        newListeners.set(eventName, filteredListeners)
      }
      
      return newListeners
    })
  }, [])

  const emit = useCallback((eventName, data) => {
    const eventListeners = listeners.get(eventName) || []
    eventListeners.forEach(callback => {
      try {
        callback(data)
      } catch (error) {
        console.error(`Erreur dans le listener pour l'event "${eventName}":`, error)
      }
    })
  }, [listeners])

  const clearListeners = useCallback((eventName) => {
    if (eventName) {
      setListeners(prev => {
        const newListeners = new Map(prev)
        newListeners.delete(eventName)
        return newListeners
      })
    } else {
      setListeners(new Map())
    }
  }, [])

  return {
    addEventListener,
    removeEventListener,
    emit,
    clearListeners,
    listenerCount: listeners.size
  }
}

// Utilisation du système d'events
function EventSystemDemo() {
  const events = useEventSystem()
  const [messages, setMessages] = useState([])

  // ✅ Handlers d'events mémorisés
  const handleUserAction = useCallback((data) => {
    setMessages(prev => [...prev, `Action utilisateur: ${data.action}`])
  }, [])

  const handleSystemEvent = useCallback((data) => {
    setMessages(prev => [...prev, `Event système: ${data.message}`])
  }, [])

  const handleError = useCallback((data) => {
    setMessages(prev => [...prev, `❌ Erreur: ${data.error}`])
  }, [])

  // Setup des listeners
  useEffect(() => {
    const cleanup1 = events.addEventListener('user:action', handleUserAction)
    const cleanup2 = events.addEventListener('system:event', handleSystemEvent)
    const cleanup3 = events.addEventListener('error', handleError)

    return () => {
      cleanup1()
      cleanup2()
      cleanup3()
    }
  }, [events.addEventListener, handleUserAction, handleSystemEvent, handleError])

  // ✅ Fonctions d'émission mémorisées
  const emitUserAction = useCallback((action) => {
    events.emit('user:action', { action, timestamp: Date.now() })
  }, [events.emit])

  const emitSystemEvent = useCallback((message) => {
    events.emit('system:event', { message, timestamp: Date.now() })
  }, [events.emit])

  const emitError = useCallback((error) => {
    events.emit('error', { error, timestamp: Date.now() })
  }, [events.emit])

  const clearMessages = useCallback(() => {
    setMessages([])
  }, [])

  return (
    <div>
      <h3>Système d'Events Optimisé</h3>
      <p>Listeners actifs: {events.listenerCount}</p>
      
      <div style={{ display: 'flex', gap: '10px', marginBottom: '20px' }}>
        <button onClick={() => emitUserAction('click')}>
          User Click
        </button>
        <button onClick={() => emitUserAction('scroll')}>
          User Scroll
        </button>
        <button onClick={() => emitSystemEvent('données sauvegardées')}>
          System Save
        </button>
        <button onClick={() => emitError('Connexion échouée')}>
          Emit Error
        </button>
        <button onClick={clearMessages}>
          Clear Messages
        </button>
      </div>

      <EventsDisplay 
        messages={messages}
        onEmitUserAction={emitUserAction}
        onEmitSystemEvent={emitSystemEvent}
        onEmitError={emitError}
      />
    </div>
  )
}

const EventsDisplay = memo(function EventsDisplay({ 
  messages, 
  onEmitUserAction, 
  onEmitSystemEvent, 
  onEmitError 
}) {
  console.log('📺 EventsDisplay re-rendu')
  
  return (
    <div>
      <h4>Messages d'events ({messages.length})</h4>
      <div style={{ 
        height: '200px', 
        overflow: 'auto', 
        border: '1px solid #ddd', 
        padding: '10px',
        backgroundColor: '#f8f9fa'
      }}>
        {messages.map((message, index) => (
          <div key={index} style={{ marginBottom: '5px', fontSize: '14px' }}>
            {message}
          </div>
        ))}
      </div>
      
      <div style={{ marginTop: '10px' }}>
        <p>Composant optimisé - ne re-render que si messages change !</p>
        <button onClick={() => onEmitUserAction('from child')}>
          Emit depuis enfant
        </button>
      </div>
    </div>
  )
})
```

---

## Points Clés à Retenir

1. **useCallback** = mémorise les **fonctions**
2. **Composants memo()** = seuls bénéficiaires de useCallback
3. **Dépendances** = variables utilisées dans la fonction
4. **Stabilité** = fonction stable = pas de re-render enfant
5. **Event handlers** = cas d'usage principal
6. **Custom hooks** = excellent endroit pour useCallback
7. **Performance** = mesurer l'impact avant d'optimiser

---

## Bonnes Pratiques

### Quand Utiliser useCallback

```jsx
function GoodPractices() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')

  // ✅ BON - Fonction passée à un composant memo
  const handleClick = useCallback(() => {
    console.log('Clicked!')
  }, [])

  // ❌ INUTILE - Fonction non passée à un composant memo
  const badCallback = useCallback(() => {
    console.log('Bad callback')
  }, [])

  // ✅ BON - Fonction avec dépendances pour composant memo
  const handleNamedClick = useCallback(() => {
    console.log(`Hello ${name}`)
  }, [name])

  return (
    <div>
      {/* ✅ Bénéficie de useCallback */}
      <MemoizedButton onClick={handleClick} />
      <MemoizedButton onClick={handleNamedClick} />
      
      {/* ❌ N'a pas besoin de useCallback */}
      <button onClick={badCallback}>Regular Button</button>
    </div>
  )
}

const MemoizedButton = memo(function MemoizedButton({ onClick }) {
  return <button onClick={onClick}>Memoized Button</button>
})
```

### Erreurs Communes

```jsx
function CommonMistakes() {
  const [items, setItems] = useState([])

  // ❌ MAUVAIS - Dépendances manquantes
  const badCallback = useCallback((id) => {
    const item = items.find(item => item.id === id) // items utilisé !
    console.log(item)
  }, []) // ❌ items manquant dans les dépendances !

  // ✅ BON - Toutes les dépendances
  const goodCallback = useCallback((id) => {
    const item = items.find(item => item.id === id)
    console.log(item)
  }, [items])

  // ❌ MAUVAIS - useCallback sans memo enfant
  const uselessCallback = useCallback(() => {
    console.log('Useless')
  }, [])

  return (
    <div>
      {/* ❌ Re-render quand même car pas de memo */}
      <RegularComponent onClick={uselessCallback} />
      
      {/* ✅ Évite les re-renders grâce à memo */}
      <MemoComponent onClick={goodCallback} />
    </div>
  )
}
```

---

## Ressources Pour Aller Plus Loin

- 📚 [useCallback Documentation](https://react.dev/reference/react/useCallback)
- 💡 [When to useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)
- ⚡ [React Performance](https://react.dev/learn/render-and-commit)
- 🔧 [React.memo vs useCallback](https://dmitripavlutin.com/use-react-memo-wisely/)

---

**Prochaine étape :** La gestion d'état complexe avec `useReducer` dans `15.0.4.5-useReducer.md` ! 🔄
