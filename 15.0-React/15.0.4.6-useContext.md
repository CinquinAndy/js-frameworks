# React - useContext : Partage de Donn√©es

**useContext** = Fini le **prop drilling** ! üåê

Quand tu dois passer des donn√©es √† travers 5-6 composants, useContext va te sauver la vie. C'est le partage de donn√©es **sans se prendre la t√™te** !

---

## Le Probl√®me : Prop Drilling

### L'Enfer du Prop Drilling

```jsx
// ‚ùå CAUCHEMAR - Prop drilling sur 6 niveaux !
function App() {
  const [user, setUser] = useState({ name: 'Andy', theme: 'light' })
  const [cart, setCart] = useState([])

  return (
    <Layout user={user} setUser={setUser} cart={cart} setCart={setCart}>
      <Dashboard user={user} setUser={setUser} cart={cart} setCart={setCart}>
        <Sidebar user={user} setUser={setUser}>
          <Profile user={user} setUser={setUser} />
        </Sidebar>
        <MainContent cart={cart} setCart={setCart}>
          <ProductList cart={cart} setCart={setCart} />
          <CartWidget cart={cart} />
        </MainContent>
      </Dashboard>
    </Layout>
  )
}

function Layout({ user, setUser, cart, setCart, children }) {
  return (
    <div>
      <Header user={user} setUser={setUser} cart={cart} />
      {children}
    </div>
  )
}

function Header({ user, setUser, cart }) {
  return (
    <header>
      <UserInfo user={user} setUser={setUser} />
      <CartIcon cart={cart} />
    </header>
  )
}

function UserInfo({ user, setUser }) {
  return (
    <div>
      <span>Salut {user.name} !</span>
      <ThemeToggle user={user} setUser={setUser} />
    </div>
  )
}

function ThemeToggle({ user, setUser }) {
  const toggleTheme = () => {
    setUser(prev => ({
      ...prev,
      theme: prev.theme === 'light' ? 'dark' : 'light'
    }))
  }

  return (
    <button onClick={toggleTheme}>
      {user.theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
    </button>
  )
}

// üòµ Props pass√©es partout !
// üêõ Difficile √† maintenir !
// üíÄ Composants interm√©diaires pollu√©s !
```

---

## La Solution : useContext

### Cr√©er un Context

```jsx
import { createContext, useContext, useState } from 'react'

// 1. ‚úÖ Cr√©er le Context
const UserContext = createContext()

// 2. ‚úÖ Provider Component
function UserProvider({ children }) {
  const [user, setUser] = useState({
    name: 'Andy',
    email: 'andy@example.com',
    theme: 'light',
    preferences: {
      notifications: true,
      language: 'fr'
    }
  })

  // Fonctions pour modifier l'utilisateur
  const updateUser = useCallback((updates) => {
    setUser(prev => ({ ...prev, ...updates }))
  }, [])

  const updatePreferences = useCallback((prefUpdates) => {
    setUser(prev => ({
      ...prev,
      preferences: { ...prev.preferences, ...prefUpdates }
    }))
  }, [])

  const toggleTheme = useCallback(() => {
    setUser(prev => ({
      ...prev,
      theme: prev.theme === 'light' ? 'dark' : 'light'
    }))
  }, [])

  // M√©moriser la valeur pour √©viter les re-renders
  const contextValue = useMemo(() => ({
    user,
    updateUser,
    updatePreferences,
    toggleTheme
  }), [user, updateUser, updatePreferences, toggleTheme])

  return (
    <UserContext.Provider value={contextValue}>
      {children}
    </UserContext.Provider>
  )
}

// 3. ‚úÖ Hook custom pour utiliser le Context
function useUser() {
  const context = useContext(UserContext)
  
  if (!context) {
    throw new Error('useUser must be used within a UserProvider')
  }
  
  return context
}

// 4. ‚úÖ Usage dans les composants (MAGIC !)
function AppWithContext() {
  return (
    <UserProvider>
      <div>
        <Layout>
          <Dashboard />
        </Layout>
      </div>
    </UserProvider>
  )
}

// Plus besoin de props ! üéâ
function Layout({ children }) {
  const { user } = useUser()

  return (
    <div style={{
      backgroundColor: user.theme === 'dark' ? '#333' : '#fff',
      color: user.theme === 'dark' ? '#fff' : '#333',
      minHeight: '100vh'
    }}>
      <Header />
      <main style={{ padding: '20px' }}>
        {children}
      </main>
    </div>
  )
}

function Header() {
  return (
    <header style={{ padding: '20px', borderBottom: '1px solid #ccc' }}>
      <UserInfo />
    </header>
  )
}

function UserInfo() {
  const { user, toggleTheme } = useUser()

  return (
    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
      <div>
        <h2>Salut {user.name} !</h2>
        <p>Th√®me: {user.theme}</p>
      </div>
      <button onClick={toggleTheme}>
        {user.theme === 'light' ? 'üåô Mode sombre' : '‚òÄÔ∏è Mode clair'}
      </button>
    </div>
  )
}

function Dashboard() {
  return (
    <div>
      <h3>Dashboard</h3>
      <div style={{ display: 'flex', gap: '20px' }}>
        <Profile />
        <Settings />
      </div>
    </div>
  )
}

function Profile() {
  const { user, updateUser } = useUser()
  const [isEditing, setIsEditing] = useState(false)
  const [tempName, setTempName] = useState(user.name)

  const handleSave = () => {
    updateUser({ name: tempName })
    setIsEditing(false)
  }

  const handleCancel = () => {
    setTempName(user.name)
    setIsEditing(false)
  }

  return (
    <div style={{ border: '1px solid #ccc', padding: '20px', borderRadius: '8px' }}>
      <h4>Profil</h4>
      
      {isEditing ? (
        <div>
          <input
            value={tempName}
            onChange={e => setTempName(e.target.value)}
          />
          <div>
            <button onClick={handleSave}>‚úÖ Sauvegarder</button>
            <button onClick={handleCancel}>‚ùå Annuler</button>
          </div>
        </div>
      ) : (
        <div>
          <p><strong>Nom:</strong> {user.name}</p>
          <p><strong>Email:</strong> {user.email}</p>
          <button onClick={() => setIsEditing(true)}>‚úèÔ∏è Modifier</button>
        </div>
      )}
    </div>
  )
}

function Settings() {
  const { user, updatePreferences } = useUser()

  return (
    <div style={{ border: '1px solid #ccc', padding: '20px', borderRadius: '8px' }}>
      <h4>Param√®tres</h4>
      
      <div>
        <label>
          <input
            type="checkbox"
            checked={user.preferences.notifications}
            onChange={e => updatePreferences({ notifications: e.target.checked })}
          />
          Notifications
        </label>
      </div>
      
      <div>
        <label>
          Langue:
          <select
            value={user.preferences.language}
            onChange={e => updatePreferences({ language: e.target.value })}
          >
            <option value="fr">Fran√ßais</option>
            <option value="en">English</option>
            <option value="es">Espa√±ol</option>
          </select>
        </label>
      </div>
    </div>
  )
}
```

---

## Multiples Contexts

### Architecture avec Plusieurs Contexts

```jsx
// Context pour l'authentification
const AuthContext = createContext()

function AuthProvider({ children }) {
  const [authState, setAuthState] = useState({
    isAuthenticated: false,
    user: null,
    loading: true
  })

  const login = useCallback(async (credentials) => {
    setAuthState(prev => ({ ...prev, loading: true }))
    
    try {
      // Simulation d'une API d'auth
      await new Promise(resolve => setTimeout(resolve, 1000))
      
      const user = { 
        id: 1, 
        name: credentials.username,
        email: `${credentials.username}@example.com`
      }
      
      setAuthState({
        isAuthenticated: true,
        user,
        loading: false
      })
      
      return { success: true }
    } catch (error) {
      setAuthState(prev => ({ ...prev, loading: false }))
      return { success: false, error: error.message }
    }
  }, [])

  const logout = useCallback(() => {
    setAuthState({
      isAuthenticated: false,
      user: null,
      loading: false
    })
  }, [])

  const value = useMemo(() => ({
    ...authState,
    login,
    logout
  }), [authState, login, logout])

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  )
}

function useAuth() {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  return context
}

// Context pour les notifications
const NotificationContext = createContext()

function NotificationProvider({ children }) {
  const [notifications, setNotifications] = useState([])

  const addNotification = useCallback((message, type = 'info', duration = 5000) => {
    const id = Date.now()
    const notification = { id, message, type }
    
    setNotifications(prev => [...prev, notification])

    if (duration > 0) {
      setTimeout(() => {
        removeNotification(id)
      }, duration)
    }
  }, [])

  const removeNotification = useCallback((id) => {
    setNotifications(prev => prev.filter(n => n.id !== id))
  }, [])

  const clearAll = useCallback(() => {
    setNotifications([])
  }, [])

  const value = useMemo(() => ({
    notifications,
    addNotification,
    removeNotification,
    clearAll
  }), [notifications, addNotification, removeNotification, clearAll])

  return (
    <NotificationContext.Provider value={value}>
      {children}
    </NotificationContext.Provider>
  )
}

function useNotifications() {
  const context = useContext(NotificationContext)
  if (!context) {
    throw new Error('useNotifications must be used within NotificationProvider')
  }
  return context
}

// Context pour les param√®tres globaux
const SettingsContext = createContext()

function SettingsProvider({ children }) {
  const [settings, setSettings] = useState({
    theme: 'light',
    language: 'fr',
    sidebar: true,
    autoSave: true
  })

  const updateSetting = useCallback((key, value) => {
    setSettings(prev => ({ ...prev, [key]: value }))
  }, [])

  const resetSettings = useCallback(() => {
    setSettings({
      theme: 'light',
      language: 'fr',
      sidebar: true,
      autoSave: true
    })
  }, [])

  const value = useMemo(() => ({
    settings,
    updateSetting,
    resetSettings
  }), [settings, updateSetting, resetSettings])

  return (
    <SettingsContext.Provider value={value}>
      {children}
    </SettingsContext.Provider>
  )
}

function useSettings() {
  const context = useContext(SettingsContext)
  if (!context) {
    throw new Error('useSettings must be used within SettingsProvider')
  }
  return context
}

// App avec multiples Providers
function MultiContextApp() {
  return (
    <AuthProvider>
      <SettingsProvider>
        <NotificationProvider>
          <AppContent />
          <NotificationDisplay />
        </NotificationProvider>
      </SettingsProvider>
    </AuthProvider>
  )
}

function AppContent() {
  const { isAuthenticated, loading } = useAuth()

  if (loading) {
    return <div>Chargement...</div>
  }

  return isAuthenticated ? <AuthenticatedApp /> : <LoginForm />
}

function LoginForm() {
  const [credentials, setCredentials] = useState({ username: '', password: '' })
  const [isLoading, setIsLoading] = useState(false)
  const { login } = useAuth()
  const { addNotification } = useNotifications()

  const handleSubmit = async (e) => {
    e.preventDefault()
    
    if (!credentials.username || !credentials.password) {
      addNotification('Veuillez remplir tous les champs', 'error')
      return
    }

    setIsLoading(true)
    const result = await login(credentials)
    setIsLoading(false)

    if (result.success) {
      addNotification('Connexion r√©ussie !', 'success')
    } else {
      addNotification('Erreur de connexion', 'error')
    }
  }

  return (
    <div style={{ maxWidth: '400px', margin: '50px auto', padding: '20px' }}>
      <h2>Connexion</h2>
      
      <form onSubmit={handleSubmit}>
        <div style={{ marginBottom: '15px' }}>
          <input
            type="text"
            value={credentials.username}
            onChange={e => setCredentials(prev => ({ ...prev, username: e.target.value }))}
            placeholder="Nom d'utilisateur"
            style={{ width: '100%', padding: '10px' }}
          />
        </div>
        
        <div style={{ marginBottom: '15px' }}>
          <input
            type="password"
            value={credentials.password}
            onChange={e => setCredentials(prev => ({ ...prev, password: e.target.value }))}
            placeholder="Mot de passe"
            style={{ width: '100%', padding: '10px' }}
          />
        </div>
        
        <button
          type="submit"
          disabled={isLoading}
          style={{
            width: '100%',
            padding: '10px',
            backgroundColor: isLoading ? '#ccc' : '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: '4px'
          }}
        >
          {isLoading ? 'Connexion...' : 'Se connecter'}
        </button>
      </form>
    </div>
  )
}

function AuthenticatedApp() {
  const { user, logout } = useAuth()
  const { addNotification } = useNotifications()
  const { settings, updateSetting } = useSettings()

  const handleAction = (action) => {
    addNotification(`Action "${action}" ex√©cut√©e`, 'info')
  }

  return (
    <div style={{
      backgroundColor: settings.theme === 'dark' ? '#333' : '#fff',
      color: settings.theme === 'dark' ? '#fff' : '#333',
      minHeight: '100vh',
      padding: '20px'
    }}>
      <header style={{ 
        display: 'flex', 
        justifyContent: 'space-between', 
        alignItems: 'center',
        marginBottom: '30px' 
      }}>
        <div>
          <h1>Salut {user.name} !</h1>
          <p>Th√®me: {settings.theme} | Langue: {settings.language}</p>
        </div>
        <div>
          <button onClick={() => updateSetting('theme', settings.theme === 'light' ? 'dark' : 'light')}>
            {settings.theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
          </button>
          <button onClick={logout} style={{ marginLeft: '10px' }}>
            D√©connexion
          </button>
        </div>
      </header>

      <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '20px' }}>
        <button onClick={() => handleAction('Cr√©er document')}>
          üìÑ Cr√©er document
        </button>
        <button onClick={() => handleAction('Voir rapports')}>
          üìä Voir rapports
        </button>
        <button onClick={() => handleAction('G√©rer utilisateurs')}>
          üë• G√©rer utilisateurs
        </button>
      </div>

      <div style={{ marginTop: '30px' }}>
        <h3>Param√®tres</h3>
        <div>
          <label>
            <input
              type="checkbox"
              checked={settings.sidebar}
              onChange={e => updateSetting('sidebar', e.target.checked)}
            />
            Afficher sidebar
          </label>
        </div>
        <div>
          <label>
            <input
              type="checkbox"
              checked={settings.autoSave}
              onChange={e => updateSetting('autoSave', e.target.checked)}
            />
            Sauvegarde automatique
          </label>
        </div>
      </div>
    </div>
  )
}

function NotificationDisplay() {
  const { notifications, removeNotification } = useNotifications()

  return (
    <div style={{
      position: 'fixed',
      top: '20px',
      right: '20px',
      zIndex: 1000
    }}>
      {notifications.map(notification => (
        <div
          key={notification.id}
          style={{
            padding: '15px',
            marginBottom: '10px',
            borderRadius: '8px',
            color: 'white',
            backgroundColor:
              notification.type === 'error' ? '#dc3545' :
              notification.type === 'success' ? '#28a745' : '#007bff',
            cursor: 'pointer',
            minWidth: '300px'
          }}
          onClick={() => removeNotification(notification.id)}
        >
          {notification.message}
        </div>
      ))}
    </div>
  )
}
```

---

## Patterns Avanc√©s

### Context avec useReducer

```jsx
// Combiner useContext avec useReducer pour un state management puissant
const AppStateContext = createContext()

// Actions
const ACTIONS = {
  SET_LOADING: 'SET_LOADING',
  SET_USER: 'SET_USER',
  ADD_TODO: 'ADD_TODO',
  TOGGLE_TODO: 'TOGGLE_TODO',
  SET_FILTER: 'SET_FILTER',
  SET_THEME: 'SET_THEME'
}

// Reducer
function appStateReducer(state, action) {
  switch (action.type) {
    case ACTIONS.SET_LOADING:
      return { ...state, loading: action.payload }

    case ACTIONS.SET_USER:
      return { ...state, user: action.payload }

    case ACTIONS.ADD_TODO:
      return {
        ...state,
        todos: [...state.todos, {
          id: Date.now(),
          text: action.payload.text,
          completed: false,
          createdAt: new Date().toISOString()
        }]
      }

    case ACTIONS.TOGGLE_TODO:
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.id
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      }

    case ACTIONS.SET_FILTER:
      return { ...state, filter: action.payload.filter }

    case ACTIONS.SET_THEME:
      return { ...state, theme: action.payload.theme }

    default:
      return state
  }
}

// Provider avec useReducer
function AppStateProvider({ children }) {
  const [state, dispatch] = useReducer(appStateReducer, {
    user: null,
    todos: [],
    filter: 'all',
    theme: 'light',
    loading: false
  })

  // Action creators pour simplifier l'usage
  const actions = useMemo(() => ({
    setLoading: (loading) => dispatch({
      type: ACTIONS.SET_LOADING,
      payload: loading
    }),

    setUser: (user) => dispatch({
      type: ACTIONS.SET_USER,
      payload: user
    }),

    addTodo: (text) => dispatch({
      type: ACTIONS.ADD_TODO,
      payload: { text }
    }),

    toggleTodo: (id) => dispatch({
      type: ACTIONS.TOGGLE_TODO,
      payload: { id }
    }),

    setFilter: (filter) => dispatch({
      type: ACTIONS.SET_FILTER,
      payload: { filter }
    }),

    setTheme: (theme) => dispatch({
      type: ACTIONS.SET_THEME,
      payload: { theme }
    })
  }), [])

  // Computed values
  const computed = useMemo(() => {
    const filteredTodos = state.todos.filter(todo => {
      switch (state.filter) {
        case 'active': return !todo.completed
        case 'completed': return todo.completed
        default: return true
      }
    })

    return {
      filteredTodos,
      todosCount: state.todos.length,
      activeCount: state.todos.filter(t => !t.completed).length,
      completedCount: state.todos.filter(t => t.completed).length
    }
  }, [state.todos, state.filter])

  const value = useMemo(() => ({
    state,
    actions,
    computed,
    dispatch // Pour les cas avanc√©s
  }), [state, actions, computed])

  return (
    <AppStateContext.Provider value={value}>
      {children}
    </AppStateContext.Provider>
  )
}

// Hook custom
function useAppState() {
  const context = useContext(AppStateContext)
  if (!context) {
    throw new Error('useAppState must be used within AppStateProvider')
  }
  return context
}

// Composants utilisant le context
function TodoApp() {
  const { state, actions, computed } = useAppState()

  return (
    <div style={{
      backgroundColor: state.theme === 'dark' ? '#333' : '#fff',
      color: state.theme === 'dark' ? '#fff' : '#333',
      minHeight: '100vh',
      padding: '20px'
    }}>
      <header style={{ marginBottom: '20px' }}>
        <h1>Todo App</h1>
        <button onClick={() => actions.setTheme(state.theme === 'light' ? 'dark' : 'light')}>
          {state.theme === 'light' ? 'üåô' : '‚òÄÔ∏è'} Toggle Theme
        </button>
      </header>

      <TodoInput />
      <TodoFilters />
      <TodoList />
      <TodoStats />
    </div>
  )
}

function TodoInput() {
  const [input, setInput] = useState('')
  const { actions } = useAppState()

  const handleSubmit = (e) => {
    e.preventDefault()
    if (input.trim()) {
      actions.addTodo(input.trim())
      setInput('')
    }
  }

  return (
    <form onSubmit={handleSubmit} style={{ marginBottom: '20px' }}>
      <input
        value={input}
        onChange={e => setInput(e.target.value)}
        placeholder="Nouvelle t√¢che..."
        style={{ padding: '10px', marginRight: '10px', width: '300px' }}
      />
      <button type="submit">Ajouter</button>
    </form>
  )
}

function TodoFilters() {
  const { state, actions } = useAppState()

  const filters = [
    { key: 'all', label: 'Toutes' },
    { key: 'active', label: 'Actives' },
    { key: 'completed', label: 'Termin√©es' }
  ]

  return (
    <div style={{ marginBottom: '20px' }}>
      {filters.map(filter => (
        <button
          key={filter.key}
          onClick={() => actions.setFilter(filter.key)}
          style={{
            padding: '5px 15px',
            marginRight: '10px',
            backgroundColor: state.filter === filter.key ? '#007bff' : '#f8f9fa',
            color: state.filter === filter.key ? 'white' : 'black',
            border: '1px solid #ddd',
            borderRadius: '4px'
          }}
        >
          {filter.label}
        </button>
      ))}
    </div>
  )
}

function TodoList() {
  const { computed, actions } = useAppState()

  return (
    <ul style={{ listStyle: 'none', padding: 0 }}>
      {computed.filteredTodos.map(todo => (
        <li key={todo.id} style={{
          display: 'flex',
          alignItems: 'center',
          padding: '10px',
          borderBottom: '1px solid #eee'
        }}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => actions.toggleTodo(todo.id)}
            style={{ marginRight: '10px' }}
          />
          <span style={{
            textDecoration: todo.completed ? 'line-through' : 'none'
          }}>
            {todo.text}
          </span>
        </li>
      ))}
    </ul>
  )
}

function TodoStats() {
  const { computed } = useAppState()

  return (
    <div style={{ marginTop: '20px', padding: '10px', backgroundColor: '#f8f9fa' }}>
      <p>Total: {computed.todosCount}</p>
      <p>Actives: {computed.activeCount}</p>
      <p>Termin√©es: {computed.completedCount}</p>
    </div>
  )
}
```

---

## Optimisations Performance

### √âviter les Re-renders Inutiles

```jsx
// ‚ùå PROBL√àME - Context value recr√©√© √† chaque render
function BadProvider({ children }) {
  const [user, setUser] = useState(null)
  const [settings, setSettings] = useState({})

  return (
    <UserContext.Provider value={{
      user,
      setUser,
      settings, 
      setSettings
    }}> {/* ‚Üê Nouvel objet √† chaque render ! */}
      {children}
    </UserContext.Provider>
  )
}

// ‚úÖ SOLUTION - M√©moriser la valeur
function GoodProvider({ children }) {
  const [user, setUser] = useState(null)
  const [settings, setSettings] = useState({})

  // M√©moriser la valeur du context
  const contextValue = useMemo(() => ({
    user,
    setUser,
    settings,
    setSettings
  }), [user, settings])

  return (
    <UserContext.Provider value={contextValue}>
      {children}
    </UserContext.Provider>
  )
}

// ‚úÖ ENCORE MIEUX - S√©parer les contexts
const UserContext = createContext()
const SettingsContext = createContext()

function UserProvider({ children }) {
  const [user, setUser] = useState(null)

  const value = useMemo(() => ({ user, setUser }), [user])

  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  )
}

function SettingsProvider({ children }) {
  const [settings, setSettings] = useState({})

  const value = useMemo(() => ({ settings, setSettings }), [settings])

  return (
    <SettingsContext.Provider value={value}>
      {children}
    </SettingsContext.Provider>
  )
}

// Utilisation
function App() {
  return (
    <UserProvider>
      <SettingsProvider>
        <AppContent />
      </SettingsProvider>
    </UserProvider>
  )
}

// Les composants ne re-render que si leur context sp√©cifique change !
```

### Context Selector Pattern

```jsx
// Pattern avanc√© pour optimiser les performances
function createContextSelector(name) {
  const Context = createContext()
  
  function Provider({ value, children }) {
    const contextValue = useMemo(() => value, [value])
    return <Context.Provider value={contextValue}>{children}</Context.Provider>
  }
  
  function useSelector(selector) {
    const context = useContext(Context)
    if (!context) {
      throw new Error(`useSelector must be used within ${name}Provider`)
    }
    
    return useMemo(() => selector(context), [selector, context])
  }
  
  return { Provider, useSelector }
}

// Usage
const { Provider: StoreProvider, useSelector } = createContextSelector('Store')

function App() {
  const [state, setState] = useState({
    user: { name: 'Andy', age: 25 },
    todos: [],
    theme: 'light'
  })

  return (
    <StoreProvider value={{ state, setState }}>
      <Header />
      <TodoList />
    </StoreProvider>
  )
}

// Ces composants ne re-render que si leur partie sp√©cifique change
function Header() {
  const user = useSelector(store => store.state.user)
  const theme = useSelector(store => store.state.theme)
  
  return <h1>Hello {user.name} (Theme: {theme})</h1>
}

function TodoList() {
  const todos = useSelector(store => store.state.todos)
  
  return (
    <ul>
      {todos.map(todo => <li key={todo.id}>{todo.text}</li>)}
    </ul>
  )
}
```

---

## Points Cl√©s √† Retenir

1. **useContext** = partage de donn√©es sans prop drilling
2. **createContext** = cr√©er le context
3. **Provider** = fournir les donn√©es aux enfants
4. **Custom hook** = encapsuler useContext + validation
5. **Multiples contexts** = diviser pour mieux r√©gner
6. **Performance** = m√©moriser les valeurs avec useMemo
7. **Architectures** = Context + useReducer = mini-Redux

---

## Bonnes Pratiques

### Structure de Dossiers

```
contexts/
‚îú‚îÄ‚îÄ AuthContext.js
‚îú‚îÄ‚îÄ SettingsContext.js
‚îú‚îÄ‚îÄ NotificationContext.js
‚îî‚îÄ‚îÄ index.js          // Export tous les contexts

hooks/
‚îú‚îÄ‚îÄ useAuth.js
‚îú‚îÄ‚îÄ useSettings.js
‚îú‚îÄ‚îÄ useNotifications.js
‚îî‚îÄ‚îÄ index.js

providers/
‚îî‚îÄ‚îÄ AppProviders.js    // Combine tous les providers
```

### Patterns √† Suivre

```jsx
// ‚úÖ Toujours valider le context
function useMyContext() {
  const context = useContext(MyContext)
  if (!context) {
    throw new Error('useMyContext must be used within MyProvider')
  }
  return context
}

// ‚úÖ S√©parer les contexts par domaine
// Auth, Settings, Notifications = contexts s√©par√©s

// ‚úÖ M√©moriser les valeurs complexes
const value = useMemo(() => ({
  state,
  actions
}), [state, actions])

// ‚úÖ Actions creators pour simplifier l'usage
const actions = useMemo(() => ({
  login: (credentials) => dispatch({ type: 'LOGIN', payload: credentials }),
  logout: () => dispatch({ type: 'LOGOUT' })
}), [])
```

---

## Erreurs Communes

### 1. Oublier le Provider

```jsx
// ‚ùå Erreur - Utiliser le context sans Provider
function App() {
  return <ComponentUsingContext /> // ‚ùå Crash !
}

// ‚úÖ Correct - Wrapper avec le Provider
function App() {
  return (
    <MyProvider>
      <ComponentUsingContext />
    </MyProvider>
  )
}
```

### 2. Context Value qui Change Toujours

```jsx
// ‚ùå Mauvais - Re-render tous les enfants
<MyContext.Provider value={{ data, setData }}>

// ‚úÖ Bon - Valeur m√©moris√©e
const value = useMemo(() => ({ data, setData }), [data])
<MyContext.Provider value={value}>
```

### 3. Trop de Donn√©es dans un Context

```jsx
// ‚ùå Mauvais - Tout dans un context
const value = { user, todos, settings, notifications, cart, ... }

// ‚úÖ Mieux - Contexts s√©par√©s par domaine
<UserProvider>
  <TodoProvider>
    <SettingsProvider>
      <App />
    </SettingsProvider>
  </TodoProvider>
</UserProvider>
```

---

## Ressources Pour Aller Plus Loin

- üìö [useContext Documentation](https://react.dev/reference/react/useContext)
- üéØ [Passing Data Deeply with Context](https://react.dev/learn/passing-data-deeply-with-context)
- üí° [Context Best Practices](https://kentcdodds.com/blog/how-to-use-react-context-effectively)
- üîÑ [Context vs Redux](https://react.dev/learn/managing-state#scaling-up-with-reducer-and-context)

---

```jsx
import { createContext, useContext } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
  return (
    <ThemeContext value="dark">
      <Form />
    </ThemeContext>
  )
}

function Form() {
  return (
    <Panel title="Welcome">
      <Button>Sign up</Button>
      <Button>Log in</Button>
    </Panel>
  );
}

function Panel({ title, children }) {
  const theme = useContext(ThemeContext);
  const className = 'panel-' + theme;
  return (
    <section className={className}>
      <h1>{title}</h1>
      {children}
    </section>
  )
}

function Button({ children }) {
  const theme = useContext(ThemeContext);
  const className = 'button-' + theme;
  return (
    <button className={className}>
      {children}
    </button>
  );
}
```
