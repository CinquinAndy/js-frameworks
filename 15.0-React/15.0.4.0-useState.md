# React - useState : Gestion d'√âtat Local

**useState** = Le hook le plus important ! üéØ

C'est lui qui va te permettre de **m√©moriser** et **modifier** des donn√©es dans tes composants. Sans lui, ton composant est **stateless** (sans √©tat).
( l'√©quivalent de notre variable un peu dans l'id√©e )

---

## Pourquoi useState ?

### Avant les Hooks (Class Components)

```jsx
// ‚ùå ANCIEN - Class Component (verbeux et compliqu√©)
class CompteurOldSchool extends React.Component {
  constructor(props) {
    super(props)
    this.state = { count: 0, name: '' }
    this.handleClick = this.handleClick.bind(this)
  }

  handleClick() {
    this.setState({ count: this.state.count + 1 })
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <input
          value={this.state.name}
          onChange={e => this.setState({ name: e.target.value })}
        />
        <button onClick={this.handleClick}>+1</button>
      </div>
    )
  }
}
```

### Avec useState (Composants Fonctionnels)

```jsx
// ‚úÖ MODERNE - Functional Component avec useState
import { useState } from 'react'

function CompteurModerne() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')

  return (
    <div>
      <p>Count: {count}</p>
      <input
        value={name}
        onChange={e => setName(e.target.value)}
      />
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  )
}
```

**Pourquoi c'est mieux ?**

- üî• **Moins de code** : 50% de lignes en moins
- üìù **Plus lisible** : pas de this.state partout
- üöÄ **Plus simple** : pas de constructor ni de bind
- üí™ **Plus puissant** : hooks customs possibles

---

## useState - Les Bases

### Syntaxe et Utilisation

```jsx
import { useState } from 'react'

function ExemplesUseState() {
  // Syntaxe de base : [valeur, fonction_pour_modifier]
  const [count, setCount] = useState(0)          // Nombre
  const [name, setName] = useState('')           // String
  const [isVisible, setIsVisible] = useState(true) // Boolean
  const [items, setItems] = useState([])         // Array
  const [user, setUser] = useState({})           // Object

  return (
    <div>
      {/* Afficher la valeur */}
      <p>Count: {count}</p>
      
      {/* Modifier la valeur */}
      <button onClick={() => setCount(count + 1)}>+1</button>
      <button onClick={() => setCount(0)}>Reset</button>

      {/* Input contr√¥l√© */}
      <input
        value={name}
        onChange={e => setName(e.target.value)}
        placeholder="Votre nom..."
      />

      {/* Toggle boolean */}
      <button onClick={() => setIsVisible(!isVisible)}>
        {isVisible ? 'Masquer' : 'Afficher'}
      </button>
      {isVisible && <p>Je suis visible !</p>}
    </div>
  )
}
```

### Convention de Nommage

```jsx
function ConventionsNommage() {
  // ‚úÖ BON - Noms explicites
  const [isLoading, setIsLoading] = useState(false)
  const [userEmail, setUserEmail] = useState('')
  const [selectedItems, setSelectedItems] = useState([])
  const [modalOpen, setModalOpen] = useState(false)

  // ‚ùå MAUVAIS - Noms peu clairs
  const [flag, setFlag] = useState(false)
  const [data, setData] = useState('')
  const [stuff, setStuff] = useState([])
  const [x, setX] = useState(false)

  // ‚úÖ Pattern recommand√© : [thing, setThing]
  const [theme, setTheme] = useState('light')
  const [language, setLanguage] = useState('fr')
  const [notifications, setNotifications] = useState(true)
}
```

---

## Mise √† Jour Bas√©e sur l'√âtat Pr√©c√©dent

### Le Pi√®ge des Closures

```jsx
function PiegeClosures() {
  const [count, setCount] = useState(0)

  // ‚ùå PROBL√àME - Double increment ne marche pas !
  const incrementTwiceBad = () => {
    setCount(count + 1) // count = 0, donc 0 + 1 = 1
    setCount(count + 1) // count = 0 encore ! donc 0 + 1 = 1
    // R√©sultat : count = 1 (au lieu de 2)
  }

  // ‚úÖ SOLUTION - Fonction de mise √† jour
  const incrementTwiceGood = () => {
    setCount(prev => prev + 1) // prev = 0, donc 1
    setCount(prev => prev + 1) // prev = 1, donc 2
    // R√©sultat : count = 2 ‚ú®
  }

  // ‚úÖ Exemples pratiques
  const increment = () => setCount(prev => prev + 1)
  const decrement = () => setCount(prev => prev - 1)
  const double = () => setCount(prev => prev * 2)
  const reset = () => setCount(0)

  return (
    <div>
      <h3>Count: {count}</h3>
      <button onClick={increment}>+1</button>
      <button onClick={decrement}>-1</button>
      <button onClick={double}>x2</button>
      <button onClick={incrementTwiceBad}>+2 (Mauvais)</button>
      <button onClick={incrementTwiceGood}>+2 (Bon)</button>
      <button onClick={reset}>Reset</button>
    </div>
  )
}
```

### Calculs Complexes

```jsx
function CalculsComplexes() {
  const [score, setScore] = useState(100)
  const [multiplier, setMultiplier] = useState(1)

  const updateScore = (operation) => {
    setScore(prevScore => {
      let newScore

      switch (operation) {
        case 'win':
          newScore = prevScore + (50 * multiplier)
          break
        case 'lose':
          newScore = Math.max(0, prevScore - 25)
          break
        case 'bonus':
          newScore = prevScore * 1.5
          break
        default:
          newScore = prevScore
      }

      // Log pour debug
      console.log(`Score: ${prevScore} ‚Üí ${newScore}`)
      
      // Validation
      return Math.min(1000, Math.max(0, newScore))
    })
  }

  return (
    <div>
      <h3>Score: {score} (x{multiplier})</h3>
      
      <div>
        <button onClick={() => updateScore('win')}>Gagner (+50)</button>
        <button onClick={() => updateScore('lose')}>Perdre (-25)</button>
        <button onClick={() => updateScore('bonus')}>Bonus (x1.5)</button>
      </div>

      <div>
        <label>
          Multiplicateur:
          <input
            type="range"
            min="1"
            max="5"
            value={multiplier}
            onChange={e => setMultiplier(Number(e.target.value))}
          />
        </label>
      </div>
    </div>
  )
}
```

---

## Gestion d'Objets et Tableaux

### √âtats Objets

```jsx
function GestionObjets() {
  const [user, setUser] = useState({
    nom: '',
    email: '',
    age: 0,
    preferences: {
      theme: 'light',
      notifications: true,
      language: 'fr'
    },
    hobbies: []
  })

  // ‚úÖ Mise √† jour simple
  const updateField = (field, value) => {
    setUser(prevUser => ({
      ...prevUser,      // Spread l'objet existant
      [field]: value    // Overwrite le champ sp√©cifique
    }))
  }

  // ‚úÖ Mise √† jour objet imbriqu√©
  const updatePreference = (prefKey, value) => {
    setUser(prevUser => ({
      ...prevUser,
      preferences: {
        ...prevUser.preferences,
        [prefKey]: value
      }
    }))
  }

  // ‚úÖ Toggle boolean dans objet imbriqu√©
  const toggleNotifications = () => {
    setUser(prevUser => ({
      ...prevUser,
      preferences: {
        ...prevUser.preferences,
        notifications: !prevUser.preferences.notifications
      }
    }))
  }

  return (
    <div>
      <h3>Profil Utilisateur</h3>
      
      <div>
        <input
          value={user.nom}
          onChange={e => updateField('nom', e.target.value)}
          placeholder="Nom"
        />
        <input
          value={user.email}
          onChange={e => updateField('email', e.target.value)}
          placeholder="Email"
        />
        <input
          type="number"
          value={user.age}
          onChange={e => updateField('age', Number(e.target.value))}
          placeholder="√Çge"
        />
      </div>

      <div>
        <h4>Pr√©f√©rences</h4>
        <label>
          <input
            type="checkbox"
            checked={user.preferences.notifications}
            onChange={toggleNotifications}
          />
          Notifications
        </label>
        
        <select
          value={user.preferences.theme}
          onChange={e => updatePreference('theme', e.target.value)}
        >
          <option value="light">Clair</option>
          <option value="dark">Sombre</option>
        </select>
      </div>

      <pre>{JSON.stringify(user, null, 2)}</pre>
    </div>
  )
}
```

### √âtats Tableaux

```jsx
function GestionTableaux() {
  const [todos, setTodos] = useState([])
  const [inputValue, setInputValue] = useState('')

  // ‚úÖ Ajouter un √©l√©ment
  const addTodo = () => {
    if (inputValue.trim()) {
      setTodos(prevTodos => [
        ...prevTodos,
        {
          id: Date.now(),
          text: inputValue,
          completed: false,
          createdAt: new Date().toISOString()
        }
      ])
      setInputValue('')
    }
  }

  // ‚úÖ Modifier un √©l√©ment (toggle completed)
  const toggleTodo = (id) => {
    setTodos(prevTodos =>
      prevTodos.map(todo =>
        todo.id === id
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    )
  }

  // ‚úÖ Modifier un √©l√©ment (edit text)
  const editTodo = (id, newText) => {
    setTodos(prevTodos =>
      prevTodos.map(todo =>
        todo.id === id
          ? { ...todo, text: newText }
          : todo
      )
    )
  }

  // ‚úÖ Supprimer un √©l√©ment
  const deleteTodo = (id) => {
    setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id))
  }

  // ‚úÖ Supprimer tous les termin√©s
  const clearCompleted = () => {
    setTodos(prevTodos => prevTodos.filter(todo => !todo.completed))
  }

  // ‚úÖ R√©organiser (move up/down)
  const moveUp = (index) => {
    if (index > 0) {
      setTodos(prevTodos => {
        const newTodos = [...prevTodos]
        const temp = newTodos[index]
        newTodos[index] = newTodos[index - 1]
        newTodos[index - 1] = temp
        return newTodos
      })
    }
  }

  const stats = {
    total: todos.length,
    completed: todos.filter(t => t.completed).length,
    remaining: todos.filter(t => !t.completed).length
  }

  return (
    <div>
      <h3>Todo List Avanc√©e</h3>
      
      <div>
        <input
          value={inputValue}
          onChange={e => setInputValue(e.target.value)}
          placeholder="Nouvelle t√¢che..."
          onKeyDown={e => e.key === 'Enter' && addTodo()}
        />
        <button onClick={addTodo}>Ajouter</button>
      </div>

      <div>
        <p>Total: {stats.total} | Termin√©es: {stats.completed} | Restantes: {stats.remaining}</p>
        {stats.completed > 0 && (
          <button onClick={clearCompleted}>
            Supprimer termin√©es ({stats.completed})
          </button>
        )}
      </div>

      <ul style={{ listStyle: 'none', padding: 0 }}>
        {todos.map((todo, index) => (
          <TodoItem
            key={todo.id}
            todo={todo}
            index={index}
            onToggle={() => toggleTodo(todo.id)}
            onEdit={(newText) => editTodo(todo.id, newText)}
            onDelete={() => deleteTodo(todo.id)}
            onMoveUp={() => moveUp(index)}
            canMoveUp={index > 0}
          />
        ))}
      </ul>
    </div>
  )
}

function TodoItem({ todo, index, onToggle, onEdit, onDelete, onMoveUp, canMoveUp }) {
  const [isEditing, setIsEditing] = useState(false)
  const [editText, setEditText] = useState(todo.text)

  const handleSave = () => {
    if (editText.trim()) {
      onEdit(editText.trim())
      setIsEditing(false)
    }
  }

  const handleCancel = () => {
    setEditText(todo.text)
    setIsEditing(false)
  }

  return (
    <li style={{
      display: 'flex',
      alignItems: 'center',
      padding: '10px',
      borderBottom: '1px solid #eee',
      backgroundColor: todo.completed ? '#f8f9fa' : 'white'
    }}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={onToggle}
      />

      {isEditing ? (
        <div style={{ flex: 1, marginLeft: '10px' }}>
          <input
            value={editText}
            onChange={e => setEditText(e.target.value)}
            onKeyDown={e => {
              if (e.key === 'Enter') handleSave()
              if (e.key === 'Escape') handleCancel()
            }}
            autoFocus
          />
          <button onClick={handleSave}>‚úÖ</button>
          <button onClick={handleCancel}>‚ùå</button>
        </div>
      ) : (
        <span
          style={{
            flex: 1,
            marginLeft: '10px',
            textDecoration: todo.completed ? 'line-through' : 'none',
            color: todo.completed ? '#666' : 'black',
            cursor: 'pointer'
          }}
          onDoubleClick={() => setIsEditing(true)}
        >
          {todo.text}
        </span>
      )}

      <div>
        {canMoveUp && (
          <button onClick={onMoveUp} title="D√©placer vers le haut">‚¨ÜÔ∏è</button>
        )}
        <button onClick={() => setIsEditing(true)} title="Modifier">‚úèÔ∏è</button>
        <button onClick={onDelete} title="Supprimer">üóëÔ∏è</button>
      </div>
    </li>
  )
}
```

---

## Optimisation de l'Initialisation

### Le Probl√®me

```jsx
function calculateExpensiveInitialValue() {
  console.log('üí∞ Calcul co√ªteux... (ne devrait arriver qu\'une fois)')
  
  // Simulation d'un calcul co√ªteux
  let result = 0
  for (let i = 0; i < 1000000; i++) {
    result += Math.random()
  }
  
  return Math.floor(result)
}

function BadInitialization() {
  // ‚ùå MAUVAIS - Fonction appel√©e √† chaque rendu !
  const [expensiveValue, setExpensiveValue] = useState(calculateExpensiveInitialValue())
  const [renderCount, setRenderCount] = useState(0)

  return (
    <div>
      <h3>‚ùå Mauvaise initialisation</h3>
      <p>Expensive Value: {expensiveValue}</p>
      <p>Render Count: {renderCount}</p>
      <button onClick={() => setRenderCount(c => c + 1)}>
        Re-render (regarde la console)
      </button>
    </div>
  )
}
```

### La Solution

```jsx
function GoodInitialization() {
  // ‚úÖ BON - Fonction appel√©e une seule fois !
  const [expensiveValue, setExpensiveValue] = useState(() => {
    console.log('üöÄ Calcul initial (UNE SEULE FOIS)')
    return calculateExpensiveInitialValue()
  })
  const [renderCount, setRenderCount] = useState(0)

  return (
    <div>
      <h3>‚úÖ Bonne initialisation</h3>
      <p>Expensive Value: {expensiveValue}</p>
      <p>Render Count: {renderCount}</p>
      <button onClick={() => setRenderCount(c => c + 1)}>
        Re-render (regarde la console)
      </button>
      <button onClick={() => setExpensiveValue(Math.random())}>
        Changer value
      </button>
    </div>
  )
}
```

### Cas d'Usage Pratiques

```jsx
function PracticalLazyInit() {
  // ‚úÖ Lire localStorage une seule fois
  const [preferences, setPreferences] = useState(() => {
    try {
      const saved = localStorage.getItem('userPreferences')
      return saved ? JSON.parse(saved) : { theme: 'light', lang: 'fr' }
    } catch {
      return { theme: 'light', lang: 'fr' }
    }
  })

  // ‚úÖ G√©n√©rer ID unique une seule fois
  const [sessionId] = useState(() => {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  })

  // ‚úÖ Parser URL params une seule fois
  const [urlParams] = useState(() => {
    const params = new URLSearchParams(window.location.search)
    return Object.fromEntries(params)
  })

  // ‚úÖ Date de cr√©ation une seule fois
  const [createdAt] = useState(() => new Date().toISOString())

  const updatePreferences = (key, value) => {
    setPreferences(prev => {
      const newPrefs = { ...prev, [key]: value }
      localStorage.setItem('userPreferences', JSON.stringify(newPrefs))
      return newPrefs
    })
  }

  return (
    <div>
      <h3>Initialisation Paresseuse Pratique</h3>
      
      <div>
        <p>Session ID: {sessionId}</p>
        <p>Cr√©√© le: {createdAt}</p>
        <p>URL Params: {JSON.stringify(urlParams)}</p>
      </div>

      <div>
        <h4>Pr√©f√©rences</h4>
        <label>
          Th√®me:
          <select
            value={preferences.theme}
            onChange={e => updatePreferences('theme', e.target.value)}
          >
            <option value="light">Clair</option>
            <option value="dark">Sombre</option>
          </select>
        </label>
        
        <label>
          Langue:
          <select
            value={preferences.lang}
            onChange={e => updatePreferences('lang', e.target.value)}
          >
            <option value="fr">Fran√ßais</option>
            <option value="en">English</option>
          </select>
        </label>
      </div>
    </div>
  )
}
```

---

## Patterns Courants

### Toggle Pattern

```jsx
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue)
  
  const toggle = useCallback(() => setValue(prev => !prev), [])
  const setTrue = useCallback(() => setValue(true), [])
  const setFalse = useCallback(() => setValue(false), [])
  
  return [value, { toggle, setTrue, setFalse, setValue }]
}

function ToggleExamples() {
  const [isVisible, visibilityActions] = useToggle(false)
  const [isLoading, loadingActions] = useToggle(false)
  const [isDarkMode, themeActions] = useToggle(false)

  const simulateLoading = async () => {
    loadingActions.setTrue()
    await new Promise(resolve => setTimeout(resolve, 2000))
    loadingActions.setFalse()
  }

  return (
    <div>
      <h3>Toggle Patterns</h3>
      
      <div>
        <button onClick={visibilityActions.toggle}>
          {isVisible ? 'Masquer' : 'Afficher'} le contenu
        </button>
        {isVisible && <p>üéâ Contenu visible !</p>}
      </div>

      <div>
        <button onClick={simulateLoading} disabled={isLoading}>
          {isLoading ? 'Chargement...' : 'D√©marrer simulation'}
        </button>
      </div>

      <div>
        <label>
          <input
            type="checkbox"
            checked={isDarkMode}
            onChange={themeActions.toggle}
          />
          Mode sombre
        </label>
        <div style={{
          padding: '20px',
          backgroundColor: isDarkMode ? '#333' : '#fff',
          color: isDarkMode ? '#fff' : '#333',
          border: '1px solid #ccc'
        }}>
          Th√®me: {isDarkMode ? 'Sombre' : 'Clair'}
        </div>
      </div>
    </div>
  )
}
```

### Counter Pattern

```jsx
function useCounter(initialValue = 0, step = 1) {
  const [count, setCount] = useState(initialValue)

  const increment = useCallback(() => setCount(prev => prev + step), [step])
  const decrement = useCallback(() => setCount(prev => prev - step), [step])
  const reset = useCallback(() => setCount(initialValue), [initialValue])
  const set = useCallback((value) => setCount(value), [])

  return {
    count,
    increment,
    decrement,
    reset,
    set,
    actions: { increment, decrement, reset, set }
  }
}

function CounterExamples() {
  const basicCounter = useCounter()
  const stepCounter = useCounter(100, 5)
  const timer = useCounter(0, 1)

  useEffect(() => {
    const interval = setInterval(timer.increment, 1000)
    return () => clearInterval(interval)
  }, [timer.increment])

  return (
    <div>
      <h3>Counter Patterns</h3>
      
      <div style={{ display: 'flex', gap: '20px' }}>
        <div>
          <h4>Compteur Basic</h4>
          <p>Count: {basicCounter.count}</p>
          <button onClick={basicCounter.increment}>+1</button>
          <button onClick={basicCounter.decrement}>-1</button>
          <button onClick={basicCounter.reset}>Reset</button>
        </div>

        <div>
          <h4>Compteur Step</h4>
          <p>Count: {stepCounter.count}</p>
          <button onClick={stepCounter.increment}>+5</button>
          <button onClick={stepCounter.decrement}>-5</button>
          <button onClick={() => stepCounter.set(1000)}>Set 1000</button>
        </div>

        <div>
          <h4>Timer</h4>
          <p>Seconds: {timer.count}</p>
          <button onClick={timer.reset}>Reset Timer</button>
        </div>
      </div>
    </div>
  )
}
```

---

## Points Cl√©s √† Retenir

1. **useState** = hook fondamental pour l'√©tat local
2. **Destructuring** = `[valeur, setValeur] = useState(initial)`
3. **Fonction de mise √† jour** = `setCount(prev => prev + 1)` pour √©viter les bugs
4. **Objets/Arrays** = toujours utiliser le spread operator `...`
5. **Lazy initialization** = `useState(() => expensiveCalculation())` pour optimiser
6. **Convention** = noms explicites et pattern `[thing, setThing]`
7. **Asynchrone** = les setters sont asynchrones, pas de `setCount` puis `console.log(count)`

---

## Erreurs Communes

### 1. Mutation directe

```jsx
// ‚ùå MAUVAIS - Mutation directe
const [user, setUser] = useState({name: 'Andy'})
user.name = 'Marie' // ‚ùå React ne d√©tecte pas le changement !

// ‚úÖ BON - Nouveau objet
setUser(prev => ({...prev, name: 'Marie'}))
```

### 2. Oublier les d√©pendances

```jsx
// ‚ùå MAUVAIS - count dans la closure
const [count, setCount] = useState(0)
const increment = () => setCount(count + 1) // ‚ùå Stale closure !

// ‚úÖ BON - Fonction de mise √† jour
const increment = () => setCount(prev => prev + 1)
```

### 3. Trop de useState

```jsx
// ‚ùå MAUVAIS - √âtats li√©s mais s√©par√©s
const [firstName, setFirstName] = useState('')
const [lastName, setLastName] = useState('')
const [email, setEmail] = useState('')

// ‚úÖ MIEUX - Grouper les √©tats li√©s
const [user, setUser] = useState({
  firstName: '',
  lastName: '',
  email: ''
})
```

---

## Ressources Pour Aller Plus Loin

- üìö [useState Documentation](https://react.dev/reference/react/useState)
- üéØ [useState Patterns](https://react.dev/learn/state-a-components-memory)
- üí° [Common useState Mistakes](https://react.dev/learn/updating-objects-in-state)
- üîÑ [State Updates are Asynchronous](https://react.dev/learn/queueing-a-series-of-state-updates)

