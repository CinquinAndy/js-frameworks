# React - Les Hooks

Maintenant qu'on comprend le rendu et le Virtual DOM, on va plonger dans **les hooks**

Un des trucs les plus important de React. C'est √ßa qui va vous permettre de g√©rer votre logique, et grossi√®rement votre app.
c'est √ßa qui va vous poser probl√®me dans les performances, et dans la lisibilit√© du code.

---

## Introduction aux Hooks

### La R√©volution des Hooks

```jsx
// ‚ùå AVANT - Class Component (2015-2019)
class CompteurOldSchool extends React.Component {
  constructor(props) {
    super(props)
    this.state = { count: 0, name: '' }
    this.handleClick = this.handleClick.bind(this)
  }

  componentDidMount() {
    document.title = `Count: ${this.state.count}`
  }

  componentDidUpdate() {
    document.title = `Count: ${this.state.count}`
  }

  handleClick() {
    this.setState({ count: this.state.count + 1 })
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <input
          value={this.state.name}
          onChange={e => this.setState({ name: e.target.value })}
        />
        <button onClick={this.handleClick}>+1</button>
      </div>
    )
  }
}

// ‚úÖ MAINTENANT - Functional Component avec Hooks (2019+)
function CompteurModerne() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')

  useEffect(() => {
    document.title = `Count: ${count}`
  }, [count])

  return (
    <div>
      <p>Count: {count}</p>
      <input
        value={name}
        onChange={e => setName(e.target.value)}
      />
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  )
}
```

### Pourquoi les Hooks ?

1. **Plus simple** - Moins de code boilerplate
2. **Plus lisible** - Logique group√©e par fonctionnalit√©
3. **R√©utilisable** - Custom hooks pour partager la logique
4. **Performance** - Optimisations automatiques
5. **TypeScript friendly** - Meilleure inf√©rence de types

### R√®gles des Hooks ‚ö†Ô∏è

```jsx
function R√®glesHooks() {
  // ‚úÖ CORRECT - Appel√©s au top level
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')

  // ‚ùå INCORRECT - Dans une condition
  if (count > 5) {
    // const [error, setError] = useState('') // ‚ùå NE JAMAIS FAIRE √áA
  }

  // ‚ùå INCORRECT - Dans une boucle
  for (let i = 0; i < 3; i++) {
    // const [items, setItems] = useState([]) // ‚ùå NE JAMAIS FAIRE √áA
  }

  // ‚ùå INCORRECT - Dans une fonction imbriqu√©e
  const handleClick = () => {
    // const [temp, setTemp] = useState(0) // ‚ùå NE JAMAIS FAIRE √áA
  }

  return <div>Respectez les r√®gles !</div>
}
```

---

## useState - Gestion d'√âtat

### Les Bases

```jsx
function ExemplesUseState() {
  // Syntaxe de base
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')
  const [isVisible, setIsVisible] = useState(true)

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
      <button onClick={() => setCount(0)}>Reset</button>

      <input
        value={name}
        onChange={e => setName(e.target.value)}
        placeholder="Votre nom..."
      />

      <button onClick={() => setIsVisible(!isVisible)}>
        {isVisible ? 'Masquer' : 'Afficher'}
      </button>
      {isVisible && <p>Je suis visible !</p>}
    </div>
  )
}
```

### Mise √† jour bas√©e sur l'√©tat pr√©c√©dent

```jsx
function MiseAJourAvancee() {
  const [count, setCount] = useState(0)

  // ‚ùå MAUVAIS - Peut causer des bugs
  const incrementBad = () => {
    setCount(count + 1)
    setCount(count + 1) // Ne fonctionne pas comme attendu !
  }

  // ‚úÖ BON - Utilise une fonction de mise √† jour
  const incrementGood = () => {
    setCount(prev => prev + 1)
    setCount(prev => prev + 1) // Fonctionne correctement !
  }

  // ‚úÖ BON - Pour des calculs complexes
  const complexUpdate = () => {
    setCount(prevCount => {
      const newCount = prevCount * 2
      console.log(`Ancien: ${prevCount}, Nouveau: ${newCount}`)
      return newCount
    })
  }

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={incrementBad}>Increment Bad (x2)</button>
      <button onClick={incrementGood}>Increment Good (x2)</button>
      <button onClick={complexUpdate}>Complex Update (x2)</button>
    </div>
  )
}
```

### Gestion d'objets et tableaux

```jsx
function GestionComplexe() {
  const [user, setUser] = useState({
    nom: '',
    email: '',
    age: 0,
    preferences: { theme: 'light', notifications: true }
  })

  const [todos, setTodos] = useState([])

  // ‚úÖ Mise √† jour d'objet imbriqu√©
  const updateUserName = (newName) => {
    setUser(prevUser => ({
      ...prevUser,
      nom: newName
    }))
  }

  // ‚úÖ Mise √† jour d'objet profond√©ment imbriqu√©
  const toggleTheme = () => {
    setUser(prevUser => ({
      ...prevUser,
      preferences: {
        ...prevUser.preferences,
        theme: prevUser.preferences.theme === 'light' ? 'dark' : 'light'
      }
    }))
  }

  // ‚úÖ Ajouter √† un tableau
  const addTodo = (text) => {
    setTodos(prevTodos => [
      ...prevTodos,
      { id: Date.now(), text, completed: false }
    ])
  }

  // ‚úÖ Modifier un √©l√©ment du tableau
  const toggleTodo = (id) => {
    setTodos(prevTodos =>
      prevTodos.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    )
  }

  // ‚úÖ Supprimer d'un tableau
  const deleteTodo = (id) => {
    setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id))
  }

  return (
    <div>
      <h3>Utilisateur</h3>
      <input
        value={user.nom}
        onChange={e => updateUserName(e.target.value)}
        placeholder="Nom"
      />
      <p>Th√®me: {user.preferences.theme}</p>
      <button onClick={toggleTheme}>Changer th√®me</button>

      <h3>Todos</h3>
      <button onClick={() => addTodo(`Todo ${todos.length + 1}`)}>
        Ajouter Todo
      </button>
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <span
              style={{
                textDecoration: todo.completed ? 'line-through' : 'none'
              }}
              onClick={() => toggleTodo(todo.id)}
            >
              {todo.text}
            </span>
            <button onClick={() => deleteTodo(todo.id)}>‚ùå</button>
          </li>
        ))}
      </ul>
    </div>
  )
}
```

### Optimisation de l'initialisation

```jsx
function OptimisationInit() {
  // ‚ùå MAUVAIS - Fonction appel√©e √† chaque rendu (car la fonction dans useState va s'execut√© √† chaque fois)
  const [expensiveState, setExpensiveState] = useState(calculateExpensiveValue())

  // ‚úÖ BON - Fonction appel√©e une seule fois ( ceci dit, c'est pas forc√©ment une bonne pratique, on pr√©f√©rera utiliser un useEffect, pour render le calcul SEULEMENT au chargement de la page)
  const [optimizedState, setOptimizedState] = useState(() => {
    console.log('üöÄ Calcul initial (une seule fois)')
    return calculateExpensiveValue()
  })

  return (
    <div>
      <p>State optimis√©: {optimizedState}</p>
      <button onClick={() => setOptimizedState(prev => prev + 1)}>+1</button>
    </div>
  )
}

function calculateExpensiveValue() {
  console.log('üí∞ Calcul co√ªteux...')
  return Array.from({ length: 1000000 }, (_, i) => i).reduce((a, b) => a + b, 0)
}
```

---

## useEffect - Effets de Bord (et autres utilisations)

### Comprendre useEffect

```jsx
function LifecycleWithUseEffect() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')

  // √âquivalent componentDidMount + componentDidUpdate
  useEffect(() => {
    console.log('üîÑ Composant mont√© OU mis √† jour')
    document.title = `Count: ${count}`
  })

  // √âquivalent componentDidMount seulement, (on peut du coup ce servir de √ßa, pour faire un calcul au chargement de la page c√¥t√© client !)
  useEffect(() => {
    console.log('üé¨ Composant mont√© (une seule fois)')

    // Cleanup = componentWillUnmount
    return () => {
      console.log('üíÄ Cleanup avant d√©montage')
    }
  }, []) // ‚Üê Tableau vide = une seule fois

  // Effet sp√©cifique √† count
  useEffect(() => {
    console.log('üìä Count a chang√©:', count)

    if (count > 10) {
      alert('Count d√©passe 10 !')
    }
  }, [count]) // ‚Üê Se d√©clenche quand count change ( et √† chaque fois que Count change !)

  // Effet sp√©cifique √† name
  useEffect(() => {
    console.log('üë§ Name a chang√©:', name)

    if (name.length > 0) {
      localStorage.setItem('userName', name)
    }
  }, [name]) // ‚Üê Se d√©clenche quand name change

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>

      <input
        value={name}
        onChange={e => setName(e.target.value)}
        placeholder="Votre nom..."
      />
    </div>
  )
}
```

### Patterns courants avec useEffect

```jsx
function EffectPatterns() {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  // 1. Fetch de donn√©es
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true)
        const response = await fetch('/api/data')
        const result = await response.json()
        setData(result)
      } catch (err) {
        setError(err.message)
      } finally {
        setLoading(false)
      }
    }

    fetchData()
  }, [])

  // 2. Timer/Interval
  useEffect(() => {
    const timer = setInterval(() => {
      console.log('‚è∞ Timer tick')
    }, 1000)

    // Cleanup crucial pour √©viter les fuites m√©moire
    return () => {
      clearInterval(timer)
      console.log('üßπ Timer nettoy√©')
    }
  }, [])

  // 3. Event listeners
  useEffect(() => {
    const handleResize = () => {
      console.log('üìê Window resized:', window.innerWidth)
    }

    window.addEventListener('resize', handleResize)

    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize)
    }
  }, [])

  // 4. Websocket
  useEffect(() => {
    const ws = new WebSocket('ws://localhost:8080')

    ws.onopen = () => console.log('üîå WebSocket connect√©')
    ws.onmessage = (event) => console.log('üìß Message re√ßu:', event.data)
    ws.onerror = (error) => console.error('‚ùå Erreur WebSocket:', error)

    // Cleanup
    return () => {
      ws.close()
      console.log('üîå WebSocket ferm√©')
    }
  }, [])

  if (loading) return <div>Chargement...</div>
  if (error) return <div>Erreur: {error}</div>

  return (
    <div>
      <h3>Donn√©es charg√©es !</h3>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  )
}
```

### D√©pendances et optimisations

```jsx
function EffectDependencies({ userId, filter }) {
  const [userData, setUserData] = useState(null)
  const [posts, setPosts] = useState([])

  // ‚ùå MAUVAIS - D√©pendances manquantes
  useEffect(() => {
    fetchUser(userId).then(setUserData) // userId pas dans les deps !
  }, []) // ‚Üê ESLint va crier

  // ‚úÖ BON - Toutes les d√©pendances
  useEffect(() => {
    fetchUser(userId).then(setUserData)
  }, [userId]) // ‚Üê userId dans les d√©pendances

  // ‚ùå MAUVAIS - Objet recr√©√© √† chaque rendu
  useEffect(() => {
    const options = { filter, sort: 'date' } // ‚Üê Nouvel objet √† chaque fois
    fetchPosts(userId, options).then(setPosts)
  }, [userId, options]) // ‚Üê `options` change toujours !

  // ‚úÖ BON - D√©pendances primitives
  useEffect(() => {
    const options = { filter, sort: 'date' }
    fetchPosts(userId, options).then(setPosts)
  }, [userId, filter]) // ‚Üê Seulement les valeurs primitives

  // ‚úÖ BON - Cr√©er l'objet dans l'effet
  useEffect(() => {
    const fetchData = async () => {
      const options = { filter, sort: 'date' }
      const data = await fetchPosts(userId, options)
      setPosts(data)
    }

    fetchData()
  }, [userId, filter])

  return (
    <div>
      {userData && <h2>{userData.name}</h2>}
      <ul>
        {posts.map(post => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  )
}

// Fonctions fictives
async function fetchUser(id) {
  return { id, name: `User ${id}` }
}

async function fetchPosts(userId, options) {
  return [
    { id: 1, title: 'Post 1' },
    { id: 2, title: 'Post 2' }
  ]
}
```

---

## useRef - R√©f√©rences et DOM

### Les bases de useRef

```jsx
function UseRefBasics() {
  const inputRef = useRef(null)
  const countRef = useRef(0)
  const timerRef = useRef(null)
  const [renderCount, setRenderCount] = useState(0)

  // Focus sur l'input
  const focusInput = () => {
    inputRef.current.focus()
  }

  // Incr√©ment silencieux (pas de re-rendu)
  const incrementSilent = () => {
    countRef.current++
    console.log('Count silencieux:', countRef.current)
  }

  // D√©marrer un timer
  const startTimer = () => {
    if (!timerRef.current) {
      timerRef.current = setInterval(() => {
        countRef.current++
        console.log('Timer count:', countRef.current)
      }, 1000)
    }
  }

  // Arr√™ter le timer
  const stopTimer = () => {
    if (timerRef.current) {
      clearInterval(timerRef.current)
      timerRef.current = null
    }
  }

  // Cleanup √† la fin
  useEffect(() => {
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current)
      }
    }
  }, [])

  return (
    <div>
      <h3>useRef Examples</h3>

      <div>
        <input ref={inputRef} placeholder="Clique Focus pour me s√©lectionner" />
        <button onClick={focusInput}>Focus Input</button>
      </div>

      <div>
        <p>Count silencieux: {countRef.current}</p>
        <button onClick={incrementSilent}>Increment Silent</button>
      </div>

      <div>
        <button onClick={startTimer}>Start Timer</button>
        <button onClick={stopTimer}>Stop Timer</button>
      </div>

      <div>
        <p>Render count: {renderCount}</p>
        <button onClick={() => setRenderCount(renderCount + 1)}>
          Force Re-render
        </button>
      </div>
    </div>
  )
}
```

### Cas d'usage avanc√©s

```jsx
function AdvancedRefUsage() {
  const videoRef = useRef(null)
  const canvasRef = useRef(null)
  const intersectionRef = useRef(null)
  const [isVisible, setIsVisible] = useState(false)

  // Contr√¥ler une vid√©o
  const toggleVideo = () => {
    const video = videoRef.current
    if (video.paused) {
      video.play()
    } else {
      video.pause()
    }
  }

  // Dessiner sur canvas
  const drawOnCanvas = () => {
    const canvas = canvasRef.current
    const ctx = canvas.getContext('2d')

    ctx.clearRect(0, 0, canvas.width, canvas.height)
    ctx.fillStyle = `hsl(${Math.random() * 360}, 70%, 50%)`
    ctx.fillRect(
      Math.random() * canvas.width,
      Math.random() * canvas.height,
      50,
      50
    )
  }

  // Intersection Observer
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        setIsVisible(entry.isIntersecting)
      },
      { threshold: 0.5 }
    )

    if (intersectionRef.current) {
      observer.observe(intersectionRef.current)
    }

    return () => observer.disconnect()
  }, [])

  return (
    <div>
      <h3>Contr√¥les Multim√©dia</h3>

      <video ref={videoRef} width="300" controls>
        <source src="https://www.w3schools.com/html/mov_bbb.mp4" type="video/mp4" />
      </video>
      <br />
      <button onClick={toggleVideo}>Play/Pause</button>

      <h3>Canvas Interactif</h3>
      <canvas
        ref={canvasRef}
        width="300"
        height="200"
        style={{ border: '1px solid black' }}
      />
      <br />
      <button onClick={drawOnCanvas}>Dessiner Rectangle</button>

      <h3>Intersection Observer</h3>
      <div style={{ height: '100vh', background: '#f0f0f0' }}>
        Scroll vers le bas...
      </div>
      <div
        ref={intersectionRef}
        style={{
          height: '200px',
          background: isVisible ? 'green' : 'red',
          color: 'white',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          fontSize: '20px'
        }}
      >
        {isVisible ? 'Je suis visible ! üëÄ' : 'Je ne suis pas visible üôà'}
      </div>
    </div>
  )
}
```

---

## useMemo et useCallback - Optimisation

### useMemo pour les calculs co√ªteux

```jsx
function UseMemoExample({ items, filter }) {
  const [count, setCount] = useState(0)

  // ‚ùå MAUVAIS - Calcul √† chaque rendu
  const expensiveValue = items
    .filter(item => item.category === filter)
    .reduce((sum, item) => sum + item.price, 0)

  // ‚úÖ BON - Calcul seulement si items ou filter changent
  const memoizedValue = useMemo(() => {
    console.log('üí∞ Calcul co√ªteux ex√©cut√©')
    return items
      .filter(item => item.category === filter)
      .reduce((sum, item) => sum + item.price, 0)
  }, [items, filter])

  // ‚úÖ Objet complexe m√©moris√©
  const chartData = useMemo(() => {
    console.log('üìä G√©n√©ration des donn√©es chart')
    return {
      labels: items.map(item => item.name),
      datasets: [{
        data: items.map(item => item.price),
        backgroundColor: items.map(() => `hsl(${Math.random() * 360}, 70%, 50%)`)
      }]
    }
  }, [items])

  return (
    <div>
      <h3>Optimisation avec useMemo</h3>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>

      <p>Total (non m√©moris√©): {expensiveValue}</p>
      <p>Total (m√©moris√©): {memoizedValue}</p>

      <ExpensiveChart data={chartData} />
    </div>
  )
}

const ExpensiveChart = memo(function ExpensiveChart({ data }) {
  console.log('üìà ExpensiveChart re-rendu')

  return (
    <div style={{ border: '1px solid #ccc', padding: '10px' }}>
      <h4>Chart (m√©moris√©)</h4>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  )
})
```

### useCallback pour les fonctions

```jsx
function UseCallbackExample() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')
  const [todos, setTodos] = useState([])

  // ‚ùå MAUVAIS - Nouvelle fonction √† chaque rendu
  const addTodoBad = (text) => {
    setTodos(prev => [...prev, { id: Date.now(), text }])
  }

  // ‚úÖ BON - Fonction m√©moris√©e
  const addTodoGood = useCallback((text) => {
    setTodos(prev => [...prev, { id: Date.now(), text }])
  }, []) // Pas de d√©pendances = fonction stable

  // ‚úÖ Fonction avec d√©pendances
  const addTodoWithPrefix = useCallback((text) => {
    const prefix = name ? `[${name}] ` : ''
    setTodos(prev => [...prev, { id: Date.now(), text: prefix + text }])
  }, [name]) // Se recr√©e seulement si name change

  // ‚úÖ Event handler optimis√©
  const handleCountChange = useCallback((increment) => {
    setCount(prev => prev + increment)
  }, [])

  return (
    <div>
      <h3>Optimisation avec useCallback</h3>

      <div>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>+1 (mauvais)</button>
        <OptimizedButton onClick={handleCountChange} increment={1}>
          +1 (optimis√©)
        </OptimizedButton>
        <OptimizedButton onClick={handleCountChange} increment={5}>
          +5 (optimis√©)
        </OptimizedButton>
      </div>

      <div>
        <input
          value={name}
          onChange={e => setName(e.target.value)}
          placeholder="Votre nom..."
        />
      </div>

      <TodoForm
        onAddTodo={addTodoGood}
        onAddTodoWithPrefix={addTodoWithPrefix}
      />

      <TodoList todos={todos} />
    </div>
  )
}

const OptimizedButton = memo(function OptimizedButton({ onClick, increment, children }) {
  console.log(`üîÑ OptimizedButton (+${increment}) re-rendu`)

  return (
    <button onClick={() => onClick(increment)}>
      {children}
    </button>
  )
})

const TodoForm = memo(function TodoForm({ onAddTodo, onAddTodoWithPrefix }) {
  console.log('üîÑ TodoForm re-rendu')
  const [input, setInput] = useState('')

  const handleSubmit = (e) => {
    e.preventDefault()
    if (input.trim()) {
      onAddTodo(input)
      setInput('')
    }
  }

  const handleSubmitWithPrefix = (e) => {
    e.preventDefault()
    if (input.trim()) {
      onAddTodoWithPrefix(input)
      setInput('')
    }
  }

  return (
    <form>
      <input
        value={input}
        onChange={e => setInput(e.target.value)}
        placeholder="Nouvelle t√¢che..."
      />
      <button type="submit" onClick={handleSubmit}>Ajouter</button>
      <button type="button" onClick={handleSubmitWithPrefix}>Ajouter avec pr√©fixe</button>
    </form>
  )
})

const TodoList = memo(function TodoList({ todos }) {
  console.log('üîÑ TodoList re-rendu')

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  )
})
```

---

## useReducer - Gestion d'√âtat Complexe

### Pourquoi useReducer ?

```jsx
// ‚ùå useState devient complexe avec plusieurs √©tats li√©s
function ComplexStateWithUseState() {
  const [count, setCount] = useState(0)
  const [step, setStep] = useState(1)
  const [isIncrementing, setIsIncrementing] = useState(true)
  const [history, setHistory] = useState([])

  const increment = () => {
    const newCount = count + step
    setCount(newCount)
    setHistory(prev => [...prev, { action: 'increment', value: newCount, step }])
  }

  const decrement = () => {
    const newCount = count - step
    setCount(newCount)
    setHistory(prev => [...prev, { action: 'decrement', value: newCount, step }])
  }

  const reset = () => {
    setCount(0)
    setHistory(prev => [...prev, { action: 'reset', value: 0 }])
  }

  // ... beaucoup de logique dispers√©e
}

// ‚úÖ useReducer centralise la logique
function CounterState() {
  return { count: 0, step: 1, history: [] }
}

function counterReducer(state, action) {
  switch (action.type) {
    case 'increment':
      const newCountInc = state.count + state.step
      return {
        ...state,
        count: newCountInc,
        history: [...state.history, { action: 'increment', value: newCountInc, step: state.step }]
      }

    case 'decrement':
      const newCountDec = state.count - state.step
      return {
        ...state,
        count: newCountDec,
        history: [...state.history, { action: 'decrement', value: newCountDec, step: state.step }]
      }

    case 'set_step':
      return { ...state, step: action.payload }

    case 'reset':
      return {
        ...CounterState(),
        history: [...state.history, { action: 'reset', value: 0 }]
      }

    case 'undo':
      if (state.history.length === 0) return state
      const lastAction = state.history[state.history.length - 1]
      return {
        ...state,
        count: lastAction.value,
        history: state.history.slice(0, -1)
      }

    default:
      throw new Error(`Action non g√©r√©e: ${action.type}`)
  }
}

function ComplexStateWithUseReducer() {
  const [state, dispatch] = useReducer(counterReducer, CounterState())

  return (
    <div>
      <h3>useReducer Example</h3>
      <p>Count: {state.count}</p>
      <p>Step: {state.step}</p>

      <div>
        <button onClick={() => dispatch({ type: 'increment' })}>+{state.step}</button>
        <button onClick={() => dispatch({ type: 'decrement' })}>-{state.step}</button>
        <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
        <button onClick={() => dispatch({ type: 'undo' })}>Undo</button>
      </div>

      <div>
        <label>
          Step:
          <input
            type="number"
            value={state.step}
            onChange={e => dispatch({ type: 'set_step', payload: Number(e.target.value) })}
          />
        </label>
      </div>

      <div>
        <h4>Historique</h4>
        <ul>
          {state.history.slice(-5).map((entry, index) => (
            <li key={index}>
              {entry.action} - Value: {entry.value}
              {entry.step && ` (step: ${entry.step})`}
            </li>
          ))}
        </ul>
      </div>
    </div>
  )
}
```

### Exemple avanc√© : Todo App avec useReducer

```jsx
function todoReducer(state, action) {
  switch (action.type) {
    case 'add_todo':
      return {
        ...state,
        todos: [...state.todos, {
          id: Date.now(),
          text: action.payload,
          completed: false,
          createdAt: new Date().toISOString()
        }]
      }

    case 'toggle_todo':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      }

    case 'delete_todo':
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload)
      }

    case 'set_filter':
      return { ...state, filter: action.payload }

    case 'clear_completed':
      return {
        ...state,
        todos: state.todos.filter(todo => !todo.completed)
      }

    case 'edit_todo':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.id
            ? { ...todo, text: action.payload.text }
            : todo
        )
      }

    default:
      throw new Error(`Action non g√©r√©e: ${action.type}`)
  }
}

function TodoAppWithReducer() {
  const [state, dispatch] = useReducer(todoReducer, {
    todos: [],
    filter: 'all' // all, active, completed
  })

  const filteredTodos = useMemo(() => {
    switch (state.filter) {
      case 'active':
        return state.todos.filter(todo => !todo.completed)
      case 'completed':
        return state.todos.filter(todo => todo.completed)
      default:
        return state.todos
    }
  }, [state.todos, state.filter])

  const stats = useMemo(() => ({
    total: state.todos.length,
    active: state.todos.filter(t => !t.completed).length,
    completed: state.todos.filter(t => t.completed).length
  }), [state.todos])

  return (
    <div style={{ maxWidth: '500px', margin: '0 auto', padding: '20px' }}>
      <h1>Todo App avec useReducer</h1>

      <TodoInput onAdd={(text) => dispatch({ type: 'add_todo', payload: text })} />

      <TodoFilters
        currentFilter={state.filter}
        onFilterChange={(filter) => dispatch({ type: 'set_filter', payload: filter })}
        stats={stats}
      />

      <TodoList
        todos={filteredTodos}
        onToggle={(id) => dispatch({ type: 'toggle_todo', payload: id })}
        onDelete={(id) => dispatch({ type: 'delete_todo', payload: id })}
        onEdit={(id, text) => dispatch({ type: 'edit_todo', payload: { id, text } })}
      />

      {stats.completed > 0 && (
        <button
          onClick={() => dispatch({ type: 'clear_completed' })}
          style={{ marginTop: '20px', color: '#dc3545' }}
        >
          Supprimer les t√¢ches termin√©es ({stats.completed})
        </button>
      )}
    </div>
  )
}

function TodoInput({ onAdd }) {
  const [input, setInput] = useState('')

  const handleSubmit = (e) => {
    e.preventDefault()
    if (input.trim()) {
      onAdd(input.trim())
      setInput('')
    }
  }

  return (
    <form onSubmit={handleSubmit} style={{ marginBottom: '20px' }}>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Nouvelle t√¢che..."
        style={{ padding: '10px', marginRight: '10px', width: '70%' }}
      />
      <button type="submit">Ajouter</button>
    </form>
  )
}

function TodoFilters({ currentFilter, onFilterChange, stats }) {
  const filters = [
    { key: 'all', label: `Toutes (${stats.total})` },
    { key: 'active', label: `Actives (${stats.active})` },
    { key: 'completed', label: `Termin√©es (${stats.completed})` }
  ]

  return (
    <div style={{ marginBottom: '20px' }}>
      {filters.map(filter => (
        <button
          key={filter.key}
          onClick={() => onFilterChange(filter.key)}
          style={{
            padding: '5px 10px',
            marginRight: '5px',
            backgroundColor: currentFilter === filter.key ? '#007bff' : '#f8f9fa',
            color: currentFilter === filter.key ? 'white' : 'black',
            border: '1px solid #ddd'
          }}
        >
          {filter.label}
        </button>
      ))}
    </div>
  )
}

function TodoList({ todos, onToggle, onDelete, onEdit }) {
  return (
    <ul style={{ listStyle: 'none', padding: 0 }}>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={onToggle}
          onDelete={onDelete}
          onEdit={onEdit}
        />
      ))}
    </ul>
  )
}

function TodoItem({ todo, onToggle, onDelete, onEdit }) {
  const [isEditing, setIsEditing] = useState(false)
  const [editText, setEditText] = useState(todo.text)

  const handleEdit = () => {
    if (editText.trim() && editText !== todo.text) {
      onEdit(todo.id, editText.trim())
    }
    setIsEditing(false)
  }

  return (
    <li style={{
      display: 'flex',
      alignItems: 'center',
      padding: '10px',
      borderBottom: '1px solid #eee'
    }}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
        style={{ marginRight: '10px' }}
      />

      {isEditing ? (
        <input
          value={editText}
          onChange={(e) => setEditText(e.target.value)}
          onBlur={handleEdit}
          onKeyDown={(e) => {
            if (e.key === 'Enter') handleEdit()
            if (e.key === 'Escape') {
              setEditText(todo.text)
              setIsEditing(false)
            }
          }}
          autoFocus
          style={{ flex: 1, padding: '5px' }}
        />
      ) : (
        <span
          style={{
            flex: 1,
            textDecoration: todo.completed ? 'line-through' : 'none',
            color: todo.completed ? '#666' : 'black',
            cursor: 'pointer'
          }}
          onDoubleClick={() => setIsEditing(true)}
        >
          {todo.text}
        </span>
      )}

      <button
        onClick={() => setIsEditing(!isEditing)}
        style={{ marginLeft: '10px', padding: '5px' }}
      >
        ‚úèÔ∏è
      </button>

      <button
        onClick={() => onDelete(todo.id)}
        style={{
          background: '#dc3545',
          color: 'white',
          border: 'none',
          padding: '5px 10px',
          borderRadius: '3px',
          marginLeft: '5px'
        }}
      >
        üóëÔ∏è
      </button>
    </li>
  )
}
```

---

## useContext - Partage de Donn√©es

### Probl√®me r√©solu par useContext

```jsx
// ‚ùå PROBL√àME - Prop drilling
function App() {
  const [user, setUser] = useState({ name: 'Andy', theme: 'light' })

  return (
    <Layout user={user} setUser={setUser}>
      <Dashboard user={user} setUser={setUser}>
        <Profile user={user} setUser={setUser} />
        <Settings user={user} setUser={setUser} />
      </Dashboard>
    </Layout>
  )
}

function Layout({ user, setUser, children }) {
  return (
    <div>
      <Header user={user} setUser={setUser} />
      {children}
    </div>
  )
}

function Header({ user, setUser }) {
  return (
    <header>
      <h1>Bonjour {user.name}</h1>
      <ThemeToggle user={user} setUser={setUser} />
    </header>
  )
}

// ... beaucoup de props drilling
```

### Solution avec useContext

```jsx
// ‚úÖ SOLUTION - Contexte
const UserContext = createContext()

function UserProvider({ children }) {
  const [user, setUser] = useState({
    name: 'Andy',
    email: 'andy@example.com',
    theme: 'light',
    preferences: {
      notifications: true,
      language: 'fr'
    }
  })

  const updateUser = useCallback((updates) => {
    setUser(prev => ({ ...prev, ...updates }))
  }, [])

  const updatePreferences = useCallback((prefUpdates) => {
    setUser(prev => ({
      ...prev,
      preferences: { ...prev.preferences, ...prefUpdates }
    }))
  }, [])

  const toggleTheme = useCallback(() => {
    setUser(prev => ({
      ...prev,
      theme: prev.theme === 'light' ? 'dark' : 'light'
    }))
  }, [])

  // M√©moriser la valeur du contexte pour √©viter les re-renders
  const contextValue = useMemo(() => ({
    user,
    updateUser,
    updatePreferences,
    toggleTheme
  }), [user, updateUser, updatePreferences, toggleTheme])

  return (
    <UserContext.Provider value={contextValue}>
      {children}
    </UserContext.Provider>
  )
}

// Hook custom pour utiliser le contexte
function useUser() {
  const context = useContext(UserContext)
  if (!context) {
    throw new Error('useUser doit √™tre utilis√© dans un UserProvider')
  }
  return context
}

// Composants qui utilisent le contexte
function AppWithContext() {
  return (
    <UserProvider>
      <div style={{ fontFamily: 'Arial, sans-serif' }}>
        <Layout>
          <Dashboard />
        </Layout>
      </div>
    </UserProvider>
  )
}

function Layout({ children }) {
  const { user } = useUser()

  return (
    <div style={{
      backgroundColor: user.theme === 'dark' ? '#333' : '#fff',
      color: user.theme === 'dark' ? '#fff' : '#333',
      minHeight: '100vh'
    }}>
      <Header />
      <main style={{ padding: '20px' }}>
        {children}
      </main>
    </div>
  )
}

function Header() {
  const { user, toggleTheme } = useUser()

  return (
    <header style={{
      padding: '20px',
      borderBottom: '1px solid #ccc',
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center'
    }}>
      <h1>Bonjour {user.name} !</h1>
      <div>
        <span style={{ marginRight: '10px' }}>
          Th√®me: {user.theme}
        </span>
        <button onClick={toggleTheme}>
          {user.theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
        </button>
      </div>
    </header>
  )
}

function Dashboard() {
  return (
    <div>
      <h2>Dashboard</h2>
      <div style={{ display: 'flex', gap: '20px' }}>
        <Profile />
        <Settings />
        <Notifications />
      </div>
    </div>
  )
}

function Profile() {
  const { user, updateUser } = useUser()
  const [isEditing, setIsEditing] = useState(false)
  const [name, setName] = useState(user.name)

  const handleSave = () => {
    updateUser({ name })
    setIsEditing(false)
  }

  return (
    <div style={{ border: '1px solid #ccc', padding: '20px', borderRadius: '5px' }}>
      <h3>Profil</h3>
      {isEditing ? (
        <div>
          <input
            value={name}
            onChange={(e) => setName(e.target.value)}
            style={{ marginBottom: '10px', display: 'block' }}
          />
          <button onClick={handleSave}>Sauvegarder</button>
          <button onClick={() => setIsEditing(false)}>Annuler</button>
        </div>
      ) : (
        <div>
          <p><strong>Nom:</strong> {user.name}</p>
          <p><strong>Email:</strong> {user.email}</p>
          <button onClick={() => setIsEditing(true)}>Modifier</button>
        </div>
      )}
    </div>
  )
}

function Settings() {
  const { user, updatePreferences } = useUser()

  return (
    <div style={{ border: '1px solid #ccc', padding: '20px', borderRadius: '5px' }}>
      <h3>Param√®tres</h3>
      <div>
        <label>
          <input
            type="checkbox"
            checked={user.preferences.notifications}
            onChange={(e) => updatePreferences({ notifications: e.target.checked })}
          />
          Notifications
        </label>
      </div>
      <div>
        <label>
          Langue:
          <select
            value={user.preferences.language}
            onChange={(e) => updatePreferences({ language: e.target.value })}
          >
            <option value="fr">Fran√ßais</option>
            <option value="en">English</option>
            <option value="es">Espa√±ol</option>
          </select>
        </label>
      </div>
    </div>
  )
}

function Notifications() {
  const { user } = useUser()

  return (
    <div style={{ border: '1px solid #ccc', padding: '20px', borderRadius: '5px' }}>
      <h3>Notifications</h3>
      {user.preferences.notifications ? (
        <div>
          <p>‚úÖ Notifications activ√©es</p>
          <ul>
            <li>Nouveau message re√ßu</li>
            <li>Mise √† jour disponible</li>
            <li>T√¢che termin√©e</li>
          </ul>
        </div>
      ) : (
        <p>üîï Notifications d√©sactiv√©es</p>
      )}
    </div>
  )
}
```

### Multiples contextes

```jsx
// Contexte pour l'authentification
const AuthContext = createContext()

function AuthProvider({ children }) {
  const [isAuthenticated, setIsAuthenticated] = useState(false)
  const [user, setUser] = useState(null)

  const login = useCallback(async (credentials) => {
    // Simulation d'une connexion
    await new Promise(resolve => setTimeout(resolve, 1000))
    setIsAuthenticated(true)
    setUser({ id: 1, name: credentials.username })
  }, [])

  const logout = useCallback(() => {
    setIsAuthenticated(false)
    setUser(null)
  }, [])

  const value = useMemo(() => ({
    isAuthenticated,
    user,
    login,
    logout
  }), [isAuthenticated, user, login, logout])

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  )
}

// Contexte pour les notifications
const NotificationContext = createContext()

function NotificationProvider({ children }) {
  const [notifications, setNotifications] = useState([])

  const addNotification = useCallback((message, type = 'info') => {
    const id = Date.now()
    setNotifications(prev => [...prev, { id, message, type }])

    // Auto-remove apr√®s 5 secondes
    setTimeout(() => {
      setNotifications(prev => prev.filter(n => n.id !== id))
    }, 5000)
  }, [])

  const removeNotification = useCallback((id) => {
    setNotifications(prev => prev.filter(n => n.id !== id))
  }, [])

  const value = useMemo(() => ({
    notifications,
    addNotification,
    removeNotification
  }), [notifications, addNotification, removeNotification])

  return (
    <NotificationContext.Provider value={value}>
      {children}
    </NotificationContext.Provider>
  )
}

// Hooks customs
function useAuth() {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth doit √™tre utilis√© dans un AuthProvider')
  }
  return context
}

function useNotifications() {
  const context = useContext(NotificationContext)
  if (!context) {
    throw new Error('useNotifications doit √™tre utilis√© dans un NotificationProvider')
  }
  return context
}

// App avec multiples contextes
function MultiContextApp() {
  return (
    <AuthProvider>
      <NotificationProvider>
        <div style={{ fontFamily: 'Arial, sans-serif' }}>
          <AppContent />
          <NotificationDisplay />
        </div>
      </NotificationProvider>
    </AuthProvider>
  )
}

function AppContent() {
  const { isAuthenticated } = useAuth()

  return isAuthenticated ? <AuthenticatedApp /> : <LoginForm />
}

function LoginForm() {
  const [username, setUsername] = useState('')
  const [password, setPassword] = useState('')
  const [loading, setLoading] = useState(false)
  const { login } = useAuth()
  const { addNotification } = useNotifications()

  const handleSubmit = async (e) => {
    e.preventDefault()
    if (!username || !password) {
      addNotification('Veuillez remplir tous les champs', 'error')
      return
    }

    setLoading(true)
    try {
      await login({ username, password })
      addNotification('Connexion r√©ussie !', 'success')
    } catch (error) {
      addNotification('Erreur de connexion', 'error')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div style={{ maxWidth: '400px', margin: '50px auto', padding: '20px' }}>
      <h2>Connexion</h2>
      <form onSubmit={handleSubmit}>
        <div style={{ marginBottom: '10px' }}>
          <input
            type="text"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
            placeholder="Nom d'utilisateur"
            style={{ width: '100%', padding: '10px' }}
          />
        </div>
        <div style={{ marginBottom: '10px' }}>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Mot de passe"
            style={{ width: '100%', padding: '10px' }}
          />
        </div>
        <button
          type="submit"
          disabled={loading}
          style={{ width: '100%', padding: '10px' }}
        >
          {loading ? 'Connexion...' : 'Se connecter'}
        </button>
      </form>
    </div>
  )
}

function AuthenticatedApp() {
  const { user, logout } = useAuth()
  const { addNotification } = useNotifications()

  const handleAction = (action) => {
    addNotification(`Action "${action}" ex√©cut√©e`, 'info')
  }

  return (
    <div style={{ padding: '20px' }}>
      <header style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '20px' }}>
        <h1>Bonjour {user.name} !</h1>
        <button onClick={logout}>D√©connexion</button>
      </header>

      <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '20px' }}>
        <button onClick={() => handleAction('Cr√©er un document')}>
          Cr√©er un document
        </button>
        <button onClick={() => handleAction('Voir les rapports')}>
          Voir les rapports
        </button>
        <button onClick={() => handleAction('G√©rer les utilisateurs')}>
          G√©rer les utilisateurs
        </button>
      </div>
    </div>
  )
}

function NotificationDisplay() {
  const { notifications, removeNotification } = useNotifications()

  return (
    <div style={{
      position: 'fixed',
      top: '20px',
      right: '20px',
      zIndex: 1000
    }}>
      {notifications.map(notification => (
        <div
          key={notification.id}
          style={{
            padding: '10px 15px',
            marginBottom: '10px',
            borderRadius: '5px',
            color: 'white',
            backgroundColor:
              notification.type === 'error' ? '#dc3545' :
              notification.type === 'success' ? '#28a745' : '#007bff',
            cursor: 'pointer'
          }}
          onClick={() => removeNotification(notification.id)}
        >
          {notification.message}
        </div>
      ))}
    </div>
  )
}
```

---

## Hooks Avanc√©s

### useLayoutEffect

```jsx
function UseLayoutEffectExample() {
  const [width, setWidth] = useState(0)
  const [height, setHeight] = useState(0)
  const divRef = useRef()

  // ‚ö†Ô∏è useEffect - S'ex√©cute APR√àS le paint
  useEffect(() => {
    console.log('üìê useEffect - mesure apr√®s paint')
  })

  // ‚úÖ useLayoutEffect - S'ex√©cute AVANT le paint
  useLayoutEffect(() => {
    console.log('üìè useLayoutEffect - mesure avant paint')

    if (divRef.current) {
      const { offsetWidth, offsetHeight } = divRef.current
      setWidth(offsetWidth)
      setHeight(offsetHeight)
    }
  })

  return (
    <div>
      <h3>useLayoutEffect Example</h3>
      <div
        ref={divRef}
        style={{
          width: '200px',
          height: '100px',
          background: 'lightblue',
          padding: '20px',
          border: '2px solid navy'
        }}
      >
        Content dynamique qui change de taille
      </div>
      <p>Largeur mesur√©e: {width}px</p>
      <p>Hauteur mesur√©e: {height}px</p>
    </div>
  )
}
```

### useId

```jsx
function UseIdExample() {
  const id1 = useId()
  const id2 = useId()
  const [items, setItems] = useState(['Item 1', 'Item 2'])

  const addItem = () => {
    setItems(prev => [...prev, `Item ${prev.length + 1}`])
  }

  return (
    <div>
      <h3>useId Example</h3>

      <div>
        <label htmlFor={id1}>Nom:</label>
        <input id={id1} type="text" placeholder="Votre nom" />
      </div>

      <div>
        <label htmlFor={id2}>Email:</label>
        <input id={id2} type="email" placeholder="Votre email" />
      </div>

      <div>
        <h4>Liste dynamique</h4>
        {items.map((item, index) => (
          <FormField key={index} label={item} />
        ))}
        <button onClick={addItem}>Ajouter item</button>
      </div>
    </div>
  )
}

function FormField({ label }) {
  const id = useId()

  return (
    <div>
      <label htmlFor={id}>{label}:</label>
      <input id={id} type="text" placeholder={`Entrez ${label}`} />
    </div>
  )
}
```

### useTransition et useDeferredValue

```jsx
function PerformanceHooks() {
  const [query, setQuery] = useState('')
  const [isPending, startTransition] = useTransition()
  const deferredQuery = useDeferredValue(query)

  // Simulation d'une recherche co√ªteuse
  const searchResults = useMemo(() => {
    if (!deferredQuery) return []

    console.log('üîç Recherche pour:', deferredQuery)

    // Simulation d'un calcul co√ªteux
    return Array.from({ length: 1000 }, (_, i) => ({
      id: i,
      title: `R√©sultat ${i} pour "${deferredQuery}"`
    })).filter(item =>
      item.title.toLowerCase().includes(deferredQuery.toLowerCase())
    )
  }, [deferredQuery])

  const handleInputChange = (value) => {
    // Mise √† jour urgente de l'input
    setQuery(value)

    // Mise √† jour diff√©r√©e pour la recherche
    startTransition(() => {
      // Cette mise √† jour sera moins prioritaire
      console.log('üîÑ Transition d√©marr√©e pour:', value)
    })
  }

  return (
    <div>
      <h3>Performance avec useTransition et useDeferredValue</h3>

      <div>
        <input
          value={query}
          onChange={(e) => handleInputChange(e.target.value)}
          placeholder="Rechercher..."
          style={{ padding: '10px', width: '300px' }}
        />
        {isPending && <span> ‚è≥ Recherche en cours...</span>}
      </div>

      <div style={{ marginTop: '20px' }}>
        <p>R√©sultats pour "{deferredQuery}": {searchResults.length} trouv√©s</p>

        <div style={{ maxHeight: '300px', overflow: 'auto' }}>
          {searchResults.slice(0, 50).map(result => (
            <div key={result.id} style={{ padding: '5px', borderBottom: '1px solid #eee' }}>
              {result.title}
            </div>
          ))}
          {searchResults.length > 50 && (
            <p>... et {searchResults.length - 50} autres r√©sultats</p>
          )}
        </div>
      </div>
    </div>
  )
}
```

---

## Custom Hooks

### Hook simple : useCounter

```jsx
function useCounter(initialValue = 0, step = 1) {
  const [count, setCount] = useState(initialValue)

  const increment = useCallback(() => {
    setCount(prev => prev + step)
  }, [step])

  const decrement = useCallback(() => {
    setCount(prev => prev - step)
  }, [step])

  const reset = useCallback(() => {
    setCount(initialValue)
  }, [initialValue])

  const setValue = useCallback((value) => {
    setCount(value)
  }, [])

  return {
    count,
    increment,
    decrement,
    reset,
    setValue
  }
}

function CounterExample() {
  const counter1 = useCounter(0, 1)
  const counter2 = useCounter(100, 5)
  const counter3 = useCounter(50, 10)

  return (
    <div>
      <h3>Custom Hook: useCounter</h3>

      <div style={{ display: 'flex', gap: '20px' }}>
        <div>
          <h4>Compteur 1 (step: 1)</h4>
          <p>Count: {counter1.count}</p>
          <button onClick={counter1.increment}>+1</button>
          <button onClick={counter1.decrement}>-1</button>
          <button onClick={counter1.reset}>Reset</button>
        </div>

        <div>
          <h4>Compteur 2 (step: 5)</h4>
          <p>Count: {counter2.count}</p>
          <button onClick={counter2.increment}>+5</button>
          <button onClick={counter2.decrement}>-5</button>
          <button onClick={counter2.reset}>Reset</button>
        </div>

        <div>
          <h4>Compteur 3 (step: 10)</h4>
          <p>Count: {counter3.count}</p>
          <button onClick={counter3.increment}>+10</button>
          <button onClick={counter3.decrement}>-10</button>
          <button onClick={() => counter3.setValue(1000)}>Set 1000</button>
        </div>
      </div>
    </div>
  )
}
```

### Hook avanc√© : useApi

```jsx
function useApi(url, options = {}) {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  const fetchData = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)

      const response = await fetch(url, {
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        },
        ...options
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const result = await response.json()
      setData(result)
    } catch (err) {
      setError(err.message)
    } finally {
      setLoading(false)
    }
  }, [url, options])

  useEffect(() => {
    fetchData()
  }, [fetchData])

  const refetch = useCallback(() => {
    fetchData()
  }, [fetchData])

  return {
    data,
    loading,
    error,
    refetch
  }
}

function ApiExample() {
  const { data: users, loading: usersLoading, error: usersError, refetch: refetchUsers } =
    useApi('https://jsonplaceholder.typicode.com/users')

  const { data: posts, loading: postsLoading, error: postsError, refetch: refetchPosts } =
    useApi('https://jsonplaceholder.typicode.com/posts?_limit=5')

  if (usersLoading || postsLoading) {
    return <div>Chargement des donn√©es...</div>
  }

  if (usersError || postsError) {
    return (
      <div>
        <p>Erreur: {usersError || postsError}</p>
        <button onClick={refetchUsers}>Retry Users</button>
        <button onClick={refetchPosts}>Retry Posts</button>
      </div>
    )
  }

  return (
    <div>
      <h3>Custom Hook: useApi</h3>

      <div style={{ display: 'flex', gap: '20px' }}>
        <div>
          <h4>Utilisateurs</h4>
          <button onClick={refetchUsers}>üîÑ Rafra√Æchir</button>
          <ul>
            {users?.slice(0, 3).map(user => (
              <li key={user.id}>{user.name} - {user.email}</li>
            ))}
          </ul>
        </div>

        <div>
          <h4>Posts</h4>
          <button onClick={refetchPosts}>üîÑ Rafra√Æchir</button>
          <ul>
            {posts?.map(post => (
              <li key={post.id}>{post.title}</li>
            ))}
          </ul>
        </div>
      </div>
    </div>
  )
}
```

### Hook complexe : useLocalStorage

```jsx
function useLocalStorage(key, initialValue) {
  // R√©cup√©rer la valeur initiale du localStorage
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      console.error(`Erreur lors de la lecture du localStorage pour la cl√© "${key}":`, error)
      return initialValue
    }
  })

  // Fonction pour mettre √† jour le state et le localStorage
  const setValue = useCallback((value) => {
    try {
      // Permettre √† value d'√™tre une fonction pour √™tre compatible avec useState
      const valueToStore = value instanceof Function ? value(storedValue) : value

      setStoredValue(valueToStore)

      if (valueToStore === undefined) {
        window.localStorage.removeItem(key)
      } else {
        window.localStorage.setItem(key, JSON.stringify(valueToStore))
      }
    } catch (error) {
      console.error(`Erreur lors de l'√©criture dans localStorage pour la cl√© "${key}":`, error)
    }
  }, [key, storedValue])

  // Fonction pour supprimer la valeur
  const removeValue = useCallback(() => {
    try {
      window.localStorage.removeItem(key)
      setStoredValue(initialValue)
    } catch (error) {
      console.error(`Erreur lors de la suppression du localStorage pour la cl√© "${key}":`, error)
    }
  }, [key, initialValue])

  return [storedValue, setValue, removeValue]
}

function LocalStorageExample() {
  const [name, setName, removeName] = useLocalStorage('user-name', '')
  const [preferences, setPreferences, removePreferences] = useLocalStorage('user-preferences', {
    theme: 'light',
    notifications: true,
    language: 'fr'
  })
  const [todos, setTodos, removeTodos] = useLocalStorage('todos', [])

  const addTodo = (text) => {
    setTodos(prev => [...prev, { id: Date.now(), text, completed: false }])
  }

  const toggleTodo = (id) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ))
  }

  const updatePreference = (key, value) => {
    setPreferences(prev => ({ ...prev, [key]: value }))
  }

  return (
    <div>
      <h3>Custom Hook: useLocalStorage</h3>

      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '20px' }}>
        <div>
          <h4>Nom d'utilisateur</h4>
          <input
            value={name}
            onChange={(e) => setName(e.target.value)}
            placeholder="Votre nom..."
          />
          <br />
          <button onClick={removeName}>Supprimer</button>
          <p>Stock√©: {name || 'Aucun'}</p>
        </div>

        <div>
          <h4>Pr√©f√©rences</h4>
          <div>
            <label>
              <input
                type="checkbox"
                checked={preferences.notifications}
                onChange={(e) => updatePreference('notifications', e.target.checked)}
              />
              Notifications
            </label>
          </div>
          <div>
            <label>
              Th√®me:
              <select
                value={preferences.theme}
                onChange={(e) => updatePreference('theme', e.target.value)}
              >
                <option value="light">Clair</option>
                <option value="dark">Sombre</option>
              </select>
            </label>
          </div>
          <div>
            <label>
              Langue:
              <select
                value={preferences.language}
                onChange={(e) => updatePreference('language', e.target.value)}
              >
                <option value="fr">Fran√ßais</option>
                <option value="en">English</option>
              </select>
            </label>
          </div>
          <button onClick={removePreferences}>Reset pr√©f√©rences</button>
        </div>

        <div>
          <h4>Todos persistantes</h4>
          <div>
            <input
              onKeyDown={(e) => {
                if (e.key === 'Enter' && e.target.value.trim()) {
                  addTodo(e.target.value.trim())
                  e.target.value = ''
                }
              }}
              placeholder="Nouvelle t√¢che..."
            />
          </div>
          <ul style={{ listStyle: 'none', padding: 0 }}>
            {todos.map(todo => (
              <li key={todo.id}>
                <label>
                  <input
                    type="checkbox"
                    checked={todo.completed}
                    onChange={() => toggleTodo(todo.id)}
                  />
                  <span style={{
                    textDecoration: todo.completed ? 'line-through' : 'none'
                  }}>
                    {todo.text}
                  </span>
                </label>
              </li>
            ))}
          </ul>
          <button onClick={removeTodos}>Supprimer toutes</button>
        </div>
      </div>

      <div style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}>
        <h4>√âtat du localStorage</h4>
        <pre>{JSON.stringify({
          'user-name': name,
          'user-preferences': preferences,
          'todos': todos
        }, null, 2)}</pre>
      </div>
    </div>
  )
}
```

---

## Exemple Pratique Complet

```jsx
// Hook compos√© utilisant plusieurs hooks
function useShoppingCart() {
  const [items, setItems] = useLocalStorage('cart-items', [])
  const [isOpen, setIsOpen] = useState(false)

  const addItem = useCallback((product) => {
    setItems(prev => {
      const existingItem = prev.find(item => item.id === product.id)
      if (existingItem) {
        return prev.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        )
      }
      return [...prev, { ...product, quantity: 1 }]
    })
  }, [setItems])

  const removeItem = useCallback((productId) => {
    setItems(prev => prev.filter(item => item.id !== productId))
  }, [setItems])

  const updateQuantity = useCallback((productId, quantity) => {
    if (quantity <= 0) {
      removeItem(productId)
      return
    }

    setItems(prev =>
      prev.map(item =>
        item.id === productId ? { ...item, quantity } : item
      )
    )
  }, [setItems, removeItem])

  const clearCart = useCallback(() => {
    setItems([])
  }, [setItems])

  const total = useMemo(() => {
    return items.reduce((sum, item) => sum + (item.price * item.quantity), 0)
  }, [items])

  const itemCount = useMemo(() => {
    return items.reduce((sum, item) => sum + item.quantity, 0)
  }, [items])

  return {
    items,
    isOpen,
    setIsOpen,
    addItem,
    removeItem,
    updateQuantity,
    clearCart,
    total,
    itemCount
  }
}

// Context pour le panier
const CartContext = createContext()

function CartProvider({ children }) {
  const cart = useShoppingCart()

  return (
    <CartContext.Provider value={cart}>
      {children}
    </CartContext.Provider>
  )
}

function useCart() {
  const context = useContext(CartContext)
  if (!context) {
    throw new Error('useCart doit √™tre utilis√© dans un CartProvider')
  }
  return context
}

// Application e-commerce compl√®te
function ECommerceApp() {
  return (
    <CartProvider>
      <div style={{ fontFamily: 'Arial, sans-serif' }}>
        <Header />
        <ProductList />
        <Cart />
      </div>
    </CartProvider>
  )
}

function Header() {
  const { itemCount, setIsOpen } = useCart()

  return (
    <header style={{
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: '20px',
      background: '#f8f9fa',
      borderBottom: '1px solid #dee2e6'
    }}>
      <h1>üõçÔ∏è Mon E-Shop</h1>
      <button
        onClick={() => setIsOpen(true)}
        style={{
          position: 'relative',
          padding: '10px 15px',
          background: '#007bff',
          color: 'white',
          border: 'none',
          borderRadius: '5px',
          cursor: 'pointer'
        }}
      >
        üõí Panier
        {itemCount > 0 && (
          <span style={{
            position: 'absolute',
            top: '-8px',
            right: '-8px',
            background: '#dc3545',
            color: 'white',
            borderRadius: '50%',
            width: '24px',
            height: '24px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '12px'
          }}>
            {itemCount}
          </span>
        )}
      </button>
    </header>
  )
}

function ProductList() {
  const products = [
    { id: 1, name: 'MacBook Pro', price: 2499, image: 'üíª' },
    { id: 2, name: 'iPhone', price: 999, image: 'üì±' },
    { id: 3, name: 'AirPods', price: 199, image: 'üéß' },
    { id: 4, name: 'iPad', price: 599, image: 'üì±' },
    { id: 5, name: 'Apple Watch', price: 399, image: '‚åö' },
    { id: 6, name: 'Magic Mouse', price: 99, image: 'üñ±Ô∏è' }
  ]

  return (
    <div style={{ padding: '20px' }}>
      <h2>Produits</h2>
      <div style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))',
        gap: '20px'
      }}>
        {products.map(product => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>
    </div>
  )
}

function ProductCard({ product }) {
  const { addItem } = useCart()
  const { addNotification } = useNotifications() || { addNotification: () => {} }

  const handleAddToCart = () => {
    addItem(product)
    addNotification?.(`${product.name} ajout√© au panier`, 'success')
  }

  return (
    <div style={{
      border: '1px solid #dee2e6',
      borderRadius: '8px',
      padding: '20px',
      textAlign: 'center',
      background: 'white'
    }}>
      <div style={{ fontSize: '48px', marginBottom: '10px' }}>
        {product.image}
      </div>
      <h3>{product.name}</h3>
      <p style={{ fontSize: '24px', fontWeight: 'bold', color: '#007bff' }}>
        {product.price}‚Ç¨
      </p>
      <button
        onClick={handleAddToCart}
        style={{
          padding: '10px 20px',
          background: '#28a745',
          color: 'white',
          border: 'none',
          borderRadius: '5px',
          cursor: 'pointer',
          width: '100%'
        }}
      >
        Ajouter au panier
      </button>
    </div>
  )
}

function Cart() {
  const {
    items,
    isOpen,
    setIsOpen,
    removeItem,
    updateQuantity,
    clearCart,
    total
  } = useCart()

  if (!isOpen) return null

  return (
    <div style={{
      position: 'fixed',
      top: 0,
      right: 0,
      width: '400px',
      height: '100%',
      background: 'white',
      boxShadow: '-2px 0 10px rgba(0,0,0,0.1)',
      zIndex: 1000,
      display: 'flex',
      flexDirection: 'column'
    }}>
      <div style={{
        padding: '20px',
        borderBottom: '1px solid #dee2e6',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center'
      }}>
        <h2>Panier</h2>
        <button
          onClick={() => setIsOpen(false)}
          style={{ background: 'none', border: 'none', fontSize: '20px' }}
        >
          ‚ùå
        </button>
      </div>

      <div style={{ flex: 1, overflow: 'auto', padding: '20px' }}>
        {items.length === 0 ? (
          <p>Votre panier est vide</p>
        ) : (
          items.map(item => (
            <div key={item.id} style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              padding: '10px 0',
              borderBottom: '1px solid #eee'
            }}>
              <div>
                <h4>{item.name}</h4>
                <p>{item.price}‚Ç¨</p>
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                <button
                  onClick={() => updateQuantity(item.id, item.quantity - 1)}
                  style={{ padding: '5px 10px' }}
                >
                  -
                </button>
                <span>{item.quantity}</span>
                <button
                  onClick={() => updateQuantity(item.id, item.quantity + 1)}
                  style={{ padding: '5px 10px' }}
                >
                  +
                </button>
                <button
                  onClick={() => removeItem(item.id)}
                  style={{ padding: '5px 10px', background: '#dc3545', color: 'white' }}
                >
                  üóëÔ∏è
                </button>
              </div>
            </div>
          ))
        )}
      </div>

      {items.length > 0 && (
        <div style={{ padding: '20px', borderTop: '1px solid #dee2e6' }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '10px' }}>
            <strong>Total: {total.toFixed(2)}‚Ç¨</strong>
          </div>
          <button
            style={{
              width: '100%',
              padding: '15px',
              background: '#007bff',
              color: 'white',
              border: 'none',
              borderRadius: '5px',
              marginBottom: '10px'
            }}
          >
            Commander
          </button>
          <button
            onClick={clearCart}
            style={{
              width: '100%',
              padding: '10px',
              background: '#6c757d',
              color: 'white',
              border: 'none',
              borderRadius: '5px'
            }}
          >
            Vider le panier
          </button>
        </div>
      )}
    </div>
  )
}
```

---

## Points Cl√©s √† Retenir

1. **Hooks = fonctions sp√©ciales** qui commencent par "use"
2. **R√®gles des hooks** = toujours au top level, m√™me ordre
3. **useState** = √©tat local, mise √† jour asynchrone
4. **useEffect** = effets de bord, cleanup crucial
5. **useRef** = r√©f√©rences DOM et valeurs mutables
6. **useMemo/useCallback** = optimisations performance
7. **useReducer** = gestion d'√©tat complexe
8. **useContext** = partage de donn√©es sans prop drilling
9. **Custom hooks** = r√©utiliser la logique entre composants
10. **Composition** = combiner plusieurs hooks

---

## Ressources pour aller plus loin

- üìö [R√©f√©rence compl√®te des Hooks](https://react.dev/reference/react)
- üéØ [useEffect en d√©tail](https://react.dev/reference/react/useEffect)
- üíæ [useState patterns](https://react.dev/reference/react/useState)
- üîÑ [useReducer guide](https://react.dev/reference/react/useReducer)
- üåê [useContext patterns](https://react.dev/reference/react/useContext)
- ‚ö° [useMemo optimisations](https://react.dev/reference/react/useMemo)
- üéõÔ∏è [useCallback guide](https://react.dev/reference/react/useCallback)

**Prochaine √©tape :** Le routing avec React Router dans `15.0.5-Router.md` !
