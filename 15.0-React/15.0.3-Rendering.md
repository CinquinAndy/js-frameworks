# React - Rendu et Virtual DOM

Maintenant qu'on maîtrise les composants fonctionnels, on va comprendre **comment React fonctionne sous le capot** !

React suit une approche **déclarative** pour le rendu des composants, ce qui signifie que tu spécifies **ce à quoi** un composant doit ressembler, et React s'occupe de l'afficher à l'écran. C'est l'opposé d'une approche **impérative**, où tu écrirais du code pour manipuler manuellement le DOM.

---

## Le Processus de Rendu React

### Les 3 étapes fondamentales

React fonctionne comme un **serveur dans un restaurant** :

1. **🎯 Trigger (Déclenchement)** - Le client passe commande
2. **🔄 Render (Rendu)** - Le chef prépare le plat
3. **📦 Commit (Validation)** - Le serveur apporte le plat

```jsx
function ExempleRendu() {
  const [count, setCount] = useState(0)

  console.log('🔄 RENDER: Composant en cours de rendu')

  const handleClick = () => {
    console.log('🎯 TRIGGER: Changement d\'état déclenché')
    setCount(count + 1) // ← Déclenche un nouveau rendu
  }

  return (
    <div>
      <p>Compteur: {count}</p>
      <button onClick={handleClick}>+1</button>
    </div>
  )
}
```

### 1. Trigger - Quand React décide de faire un rendu

React fait un rendu dans **2 cas seulement** :

```jsx
function QuandReactRend() {
  const [state, setState] = useState(0)

  // ✅ CAS 1: Rendu initial (première fois)
  useEffect(() => {
    console.log('🎬 Premier rendu du composant')
  }, [])

  // ✅ CAS 2: Changement d'état
  const triggerReRender = () => {
    setState(state + 1) // ← Déclenche un re-rendu
  }

  return (
    <div>
      <p>State: {state}</p>
      <button onClick={triggerReRender}>Changer état</button>
    </div>
  )
}
```

### 2. Render - React appelle tes composants

```jsx
function ExempleRenderPur() {
  const [count, setCount] = useState(0)

  // ⚠️ Cette fonction DOIT être pure !
  // Mêmes inputs = mêmes outputs
  console.log('🔄 Render appelé avec count =', count)

  return <div>Count: {count}</div>
}

// ❌ MAUVAIS - Effet de bord pendant le render
function BadExample() {
  const [count, setCount] = useState(0)

  // ❌ Ne jamais faire ça dans le render !
  document.title = `Count: ${count}` // Effet de bord
  Math.random() // Non-déterministe

  return <div>{count}</div>
}

// ✅ BON - Render pur
function GoodExample() {
  const [count, setCount] = useState(0)

  // ✅ Effets de bord dans useEffect
  useEffect(() => {
    document.title = `Count: ${count}`
  }, [count])

  return <div>{count}</div>
}
```

### 3. Commit - React met à jour le DOM

```jsx
function ExempleCommit() {
  const [color, setColor] = useState('red')

  return (
    <div>
      {/* React ne mettra à jour QUE la couleur dans le DOM */}
      <div style={{ backgroundColor: color, padding: '20px' }}>
        <h2>Titre inchangé</h2>
        <p>Paragraphe inchangé</p>
        <button onClick={() => setColor(color === 'red' ? 'blue' : 'red')}>
          Changer couleur
        </button>
      </div>
    </div>
  )
}
```

---

## Virtual DOM - La Magie de React

### Qu'est-ce que le Virtual DOM ?

Le **Virtual DOM (VDOM)** est une représentation **en mémoire** du DOM réel. C'est comme un **brouillon** que React utilise pour optimiser les mises à jour.

```jsx
// Ce que tu écris en JSX
function MonComposant() {
  return (
    <div className="container">
      <h1>Titre</h1>
      <p>Paragraphe</p>
    </div>
  )
}

// Ce que React crée en Virtual DOM (simplifié)
const virtualDOM = {
  type: 'div',
  props: { className: 'container' },
  children: [
    { type: 'h1', props: {}, children: ['Titre'] },
    { type: 'p', props: {}, children: ['Paragraphe'] }
  ]
}
```

### Le Processus de Réconciliation

```jsx
function ExempleReconciliation() {
  const [items, setItems] = useState(['A', 'B', 'C'])

  const ajouterItem = () => {
    setItems([...items, `Item ${Date.now()}`])
  }

  return (
    <div>
      <h2>Liste d'items</h2>
      {/*
        React compare :
        - AVANT: ['A', 'B', 'C']
        - APRÈS: ['A', 'B', 'C', 'Item 12345']

        Résultat: React ajoute SEULEMENT le nouvel élément au DOM
      */}
      <ul>
        {items.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
      <button onClick={ajouterItem}>Ajouter item</button>
    </div>
  )
}
```

### Pourquoi c'est important ?

```jsx
// Sans Virtual DOM (manipulation directe)
function updateWithoutVDOM() {
  // ❌ Lent et inefficace
  document.getElementById('title').textContent = 'Nouveau titre'
  document.getElementById('count').textContent = '42'
  document.getElementById('status').className = 'active'
  // ... 50 autres mises à jour
}

// Avec Virtual DOM (React)
function updateWithVDOM() {
  // ✅ React calcule automatiquement les changements minimaux
  setTitle('Nouveau titre')
  setCount(42)
  setStatus('active')
  // React met à jour SEULEMENT ce qui a changé
}
```

### Démonstration pratique

```jsx
function DemoVirtualDOM() {
  const [highlightIndex, setHighlightIndex] = useState(0)

  useEffect(() => {
    const interval = setInterval(() => {
      setHighlightIndex(prev => (prev + 1) % 5)
    }, 1000)

    return () => clearInterval(interval)
  }, [])

  return (
    <div>
      <h3>React met à jour SEULEMENT l'élément surligné</h3>
      <ul>
        {['Item 1', 'Item 2', 'Item 3', 'Item 4', 'Item 5'].map((item, index) => (
          <li
            key={index}
            style={{
              backgroundColor: index === highlightIndex ? 'yellow' : 'transparent',
              padding: '10px',
              transition: 'background-color 0.3s'
            }}
          >
            {item}
          </li>
        ))}
      </ul>
      <p>👆 Ouvre les DevTools et regarde: seule la couleur change dans le DOM !</p>
    </div>
  )
}
```

---

## Quand React Fait des Re-Rendus

### Les règles d'or

React re-rend un composant **SEULEMENT** dans ces cas :

1. **Changement d'état** dans le composant
2. **Changement de props** reçues du parent
3. **Re-rendu du parent** (cascade)

```jsx
function ParentComponent() {
  const [parentState, setParentState] = useState(0)

  console.log('🔄 Parent re-rend')

  return (
    <div>
      <h2>Parent State: {parentState}</h2>
      <button onClick={() => setParentState(parentState + 1)}>
        Changer Parent
      </button>

      {/* Ces enfants vont AUSSI re-rendre quand le parent re-rend */}
      <EnfantSansProps />
      <EnfantAvecProps value={parentState} />
    </div>
  )
}

function EnfantSansProps() {
  console.log('🔄 Enfant SANS props re-rend quand même')
  return <p>Je n'ai pas de props mais je re-rend !</p>
}

function EnfantAvecProps({ value }) {
  console.log('🔄 Enfant AVEC props re-rend')
  return <p>Ma valeur: {value}</p>
}
```

### Optimiser les re-rendus

```jsx
import { memo, useMemo, useCallback } from 'react'

// ✅ Optimisé avec React.memo
const EnfantOptimise = memo(function EnfantOptimise({ value }) {
  console.log('🚀 Je ne re-rend QUE si mes props changent')
  return <p>Valeur optimisée: {value}</p>
})

function ParentOptimise() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('Andy')

  // ✅ Calcul coûteux optimisé
  const expensiveValue = useMemo(() => {
    console.log('💰 Calcul coûteux exécuté')
    return count * 1000
  }, [count])

  // ✅ Fonction optimisée
  const handleNameChange = useCallback((newName) => {
    setName(newName)
  }, [])

  return (
    <div>
      <h2>Count: {count}</h2>
      <h3>Name: {name}</h3>

      <button onClick={() => setCount(count + 1)}>Count +1</button>
      <button onClick={() => setName(name + '!')}>Name +!</button>

      {/* Ne re-rend que si expensiveValue change */}
      <EnfantOptimise value={expensiveValue} />

      {/* Ne re-rend que si handleNameChange change (jamais ici) */}
      <EnfantAvecCallback onNameChange={handleNameChange} />
    </div>
  )
}
```

---

## Cycle de Vie des Composants avec Hooks

### Migration Class → Hooks

```jsx
// ❌ AVANT - Class Component (deprecated)
class OldLifecycle extends React.Component {
  componentDidMount() {
    console.log('Composant monté')
  }

  componentDidUpdate(prevProps, prevState) {
    console.log('Composant mis à jour')
  }

  componentWillUnmount() {
    console.log('Composant va être démonté')
  }

  render() {
    return <div>Old way</div>
  }
}

// ✅ MAINTENANT - Functional Component avec useEffect
function NewLifecycle() {
  const [count, setCount] = useState(0)

  // équivalent componentDidMount + componentDidUpdate
  useEffect(() => {
    console.log('Composant monté OU mis à jour')
  })

  // équivalent componentDidMount uniquement
  useEffect(() => {
    console.log('Composant monté (une seule fois)')
  }, []) // ← Tableau vide = une seule fois

  // équivalent componentDidUpdate pour count
  useEffect(() => {
    console.log('Count a changé:', count)
  }, [count]) // ← Se déclenche quand count change

  // équivalent componentWillUnmount
  useEffect(() => {
    return () => {
      console.log('Nettoyage avant démontage')
    }
  }, [])

  return <div>Count: {count}</div>
}
```

### Exemples pratiques de cycles de vie

```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null)
  const [loading, setLoading] = useState(true)

  // Charger les données utilisateur quand le composant monte
  // ou quand userId change
  useEffect(() => {
    setLoading(true)

    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => {
        setUser(data)
        setLoading(false)
      })
  }, [userId]) // ← Re-fetch si userId change

  // Nettoyage des timers/subscriptions
  useEffect(() => {
    const timer = setInterval(() => {
      console.log('Timer actif')
    }, 1000)

    // Cleanup function
    return () => {
      clearInterval(timer)
      console.log('Timer nettoyé')
    }
  }, [])

  if (loading) return <div>Chargement...</div>
  if (!user) return <div>Utilisateur non trouvé</div>

  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  )
}
```

### Pattern avancé : Custom Hook pour le cycle de vie

```jsx
function useLifecycle(name) {
  useEffect(() => {
    console.log(`🎬 ${name} monté`)

    return () => {
      console.log(`💀 ${name} démonté`)
    }
  }, [name])

  useEffect(() => {
    console.log(`🔄 ${name} mis à jour`)
  })
}

function MyComponent() {
  useLifecycle('MyComponent')

  return <div>Composant avec logs automatiques</div>
}
```

---

## Refs - Échapper au Flux de Données React

### Quand utiliser les Refs ?

Les **refs** sont une "porte de sortie" pour les cas où tu dois **sortir du flux normal de React** :

```jsx
function ExemplesRefs() {
  const inputRef = useRef(null)
  const timerRef = useRef(null)
  const countRef = useRef(0)

  // ✅ CAS 1: Focus sur un élément DOM
  const focusInput = () => {
    inputRef.current.focus()
  }

  // ✅ CAS 2: Stocker un timer ID
  const startTimer = () => {
    timerRef.current = setInterval(() => {
      countRef.current++
      console.log('Timer:', countRef.current)
    }, 1000)
  }

  const stopTimer = () => {
    clearInterval(timerRef.current)
  }

  // ✅ CAS 3: Valeur qui ne doit PAS déclencher de re-rendu
  const incrementSilent = () => {
    countRef.current++ // ← Pas de re-rendu !
    console.log('Count silencieux:', countRef.current)
  }

  return (
    <div>
      <input ref={inputRef} placeholder="Clique Focus pour me sélectionner" />
      <button onClick={focusInput}>Focus Input</button>

      <div>
        <button onClick={startTimer}>Start Timer</button>
        <button onClick={stopTimer}>Stop Timer</button>
        <button onClick={incrementSilent}>Count Silencieux</button>
      </div>
    </div>
  )
}
```

### Refs vs State - La différence cruciale

```jsx
function RefsVsState() {
  const [stateCount, setStateCount] = useState(0)
  const refCount = useRef(0)

  const incrementState = () => {
    setStateCount(stateCount + 1) // ← Déclenche un re-rendu
  }

  const incrementRef = () => {
    refCount.current++ // ← PAS de re-rendu
    console.log('Ref count:', refCount.current)
  }

  console.log('🔄 Composant re-rendu')

  return (
    <div>
      <p>State Count: {stateCount}</p>
      <p>Ref Count: {refCount.current}</p>

      <button onClick={incrementState}>State +1 (re-rend)</button>
      <button onClick={incrementRef}>Ref +1 (pas de re-rend)</button>
    </div>
  )
}
```

### Manipulation du DOM avec Refs

```jsx
function DOMManipulation() {
  const videoRef = useRef(null)
  const scrollRef = useRef(null)
  const canvasRef = useRef(null)

  const playPause = () => {
    const video = videoRef.current
    if (video.paused) {
      video.play()
    } else {
      video.pause()
    }
  }

  const scrollToTop = () => {
    scrollRef.current.scrollTo({
      top: 0,
      behavior: 'smooth'
    })
  }

  const drawOnCanvas = () => {
    const canvas = canvasRef.current
    const ctx = canvas.getContext('2d')

    ctx.fillStyle = 'red'
    ctx.fillRect(50, 50, 100, 100)
  }

  return (
    <div>
      <h3>Contrôle vidéo</h3>
      <video ref={videoRef} width="300" controls>
        <source src="https://www.w3schools.com/html/mov_bbb.mp4" type="video/mp4" />
      </video>
      <button onClick={playPause}>Play/Pause</button>

      <h3>Scroll automatique</h3>
      <div
        ref={scrollRef}
        style={{ height: '200px', overflow: 'auto', border: '1px solid black' }}
      >
        {Array.from({ length: 50 }, (_, i) => (
          <p key={i}>Ligne {i + 1}</p>
        ))}
      </div>
      <button onClick={scrollToTop}>Scroll to Top</button>

      <h3>Dessin sur Canvas</h3>
      <canvas ref={canvasRef} width="200" height="200" style={{ border: '1px solid black' }} />
      <button onClick={drawOnCanvas}>Dessiner Rectangle</button>
    </div>
  )
}
```

### Pattern avancé : forwardRef

```jsx
import { forwardRef, useImperativeHandle } from 'react'

// Composant enfant qui expose des méthodes au parent
const FancyInput = forwardRef((props, ref) => {
  const inputRef = useRef()

  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus()
    },
    getValue: () => {
      return inputRef.current.value
    },
    clear: () => {
      inputRef.current.value = ''
    }
  }))

  return <input ref={inputRef} {...props} />
})

// Composant parent qui utilise les méthodes exposées
function ParentWithForwardRef() {
  const fancyInputRef = useRef()

  const handleFocus = () => fancyInputRef.current.focus()
  const handleGetValue = () => {
    alert(fancyInputRef.current.getValue())
  }
  const handleClear = () => fancyInputRef.current.clear()

  return (
    <div>
      <FancyInput ref={fancyInputRef} placeholder="Input avec méthodes exposées" />
      <button onClick={handleFocus}>Focus</button>
      <button onClick={handleGetValue}>Get Value</button>
      <button onClick={handleClear}>Clear</button>
    </div>
  )
}
```

### Gestion de listes avec Refs

```jsx
function ListWithRefs() {
  const [items, setItems] = useState(['Item 1', 'Item 2', 'Item 3'])
  const itemsRef = useRef({})

  const scrollToItem = (index) => {
    itemsRef.current[index]?.scrollIntoView({
      behavior: 'smooth',
      block: 'center'
    })
  }

  const addItem = () => {
    setItems([...items, `Item ${items.length + 1}`])
  }

  return (
    <div>
      <div style={{ height: '200px', overflow: 'auto', border: '1px solid black' }}>
        {items.map((item, index) => (
          <div
            key={index}
            ref={(el) => itemsRef.current[index] = el}
            style={{ height: '50px', padding: '10px', borderBottom: '1px solid #ccc' }}
          >
            {item}
          </div>
        ))}
      </div>

      <div>
        {items.map((_, index) => (
          <button key={index} onClick={() => scrollToItem(index)}>
            Scroll to {index + 1}
          </button>
        ))}
        <button onClick={addItem}>Ajouter Item</button>
      </div>
    </div>
  )
}
```

---

## Exemple Pratique Complet

```jsx
function TodoAppAvecRendu() {
  const [todos, setTodos] = useState([])
  const [filter, setFilter] = useState('all') // all, active, completed
  const inputRef = useRef(null)
  const renderCountRef = useRef(0)

  // Compter les re-rendus
  renderCountRef.current++

  // Filtrer les todos
  const filteredTodos = useMemo(() => {
    console.log('🔄 Filtrage des todos')
    switch (filter) {
      case 'active':
        return todos.filter(todo => !todo.completed)
      case 'completed':
        return todos.filter(todo => todo.completed)
      default:
        return todos
    }
  }, [todos, filter])

  // Ajouter une todo
  const addTodo = useCallback(() => {
    const text = inputRef.current.value.trim()
    if (text) {
      setTodos(prev => [...prev, {
        id: Date.now(),
        text,
        completed: false
      }])
      inputRef.current.value = ''
      inputRef.current.focus()
    }
  }, [])

  // Toggle todo
  const toggleTodo = useCallback((id) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ))
  }, [])

  // Supprimer todo
  const deleteTodo = useCallback((id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id))
  }, [])

  // Stats
  const stats = useMemo(() => ({
    total: todos.length,
    active: todos.filter(t => !t.completed).length,
    completed: todos.filter(t => t.completed).length
  }), [todos])

  console.log(`🔄 TodoApp re-rendu ${renderCountRef.current} fois`)

  return (
    <div style={{ maxWidth: '500px', margin: '0 auto', padding: '20px' }}>
      <h1>Todo App avec Optimisations</h1>

      {/* Statistiques de rendu */}
      <div style={{ background: '#f0f0f0', padding: '10px', marginBottom: '20px' }}>
        <p>🔄 Re-rendus: {renderCountRef.current}</p>
        <p>📊 Total: {stats.total} | Actives: {stats.active} | Terminées: {stats.completed}</p>
      </div>

      {/* Ajout de todo */}
      <div style={{ marginBottom: '20px' }}>
        <input
          ref={inputRef}
          placeholder="Nouvelle tâche..."
          onKeyDown={(e) => e.key === 'Enter' && addTodo()}
          style={{ padding: '10px', marginRight: '10px', width: '70%' }}
        />
        <button onClick={addTodo}>Ajouter</button>
      </div>

      {/* Filtres */}
      <div style={{ marginBottom: '20px' }}>
        {['all', 'active', 'completed'].map(filterType => (
          <button
            key={filterType}
            onClick={() => setFilter(filterType)}
            style={{
              padding: '5px 10px',
              marginRight: '5px',
              backgroundColor: filter === filterType ? '#007bff' : '#f8f9fa',
              color: filter === filterType ? 'white' : 'black',
              border: '1px solid #ddd'
            }}
          >
            {filterType.charAt(0).toUpperCase() + filterType.slice(1)}
          </button>
        ))}
      </div>

      {/* Liste des todos */}
      <ul style={{ listStyle: 'none', padding: 0 }}>
        {filteredTodos.map(todo => (
          <TodoItem
            key={todo.id}
            todo={todo}
            onToggle={toggleTodo}
            onDelete={deleteTodo}
          />
        ))}
      </ul>

      {filteredTodos.length === 0 && (
        <p style={{ textAlign: 'center', color: '#666' }}>
          {filter === 'all' ? 'Aucune tâche' : `Aucune tâche ${filter}`}
        </p>
      )}
    </div>
  )
}

// Composant optimisé avec memo
const TodoItem = memo(function TodoItem({ todo, onToggle, onDelete }) {
  console.log(`🔄 TodoItem ${todo.id} re-rendu`)

  return (
    <li style={{
      display: 'flex',
      alignItems: 'center',
      padding: '10px',
      borderBottom: '1px solid #eee'
    }}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
        style={{ marginRight: '10px' }}
      />
      <span style={{
        flex: 1,
        textDecoration: todo.completed ? 'line-through' : 'none',
        color: todo.completed ? '#666' : 'black'
      }}>
        {todo.text}
      </span>
      <button
        onClick={() => onDelete(todo.id)}
        style={{
          background: '#dc3545',
          color: 'white',
          border: 'none',
          padding: '5px 10px',
          borderRadius: '3px'
        }}
      >
        🗑️
      </button>
    </li>
  )
})
```

---

## Ressources pour aller plus loin

- 📖 [Rendu et Commit](https://react.dev/learn/render-and-commit)
- 🔍 [Pourquoi React re-rend](https://ui.dev/why-react-renders)
- 🎯 [Références avec useRef](https://react.dev/learn/referencing-values-with-refs)
- 🛠️ [Manipuler le DOM avec refs](https://react.dev/learn/manipulating-the-dom-with-refs)
- ⚡ [Répondre aux événements](https://react.dev/learn/responding-to-events)
- 🔗 [Higher-Order Components](https://www.robinwieruch.de/react-higher-order-components/)
