# React - useMemo et useCallback : Optimisation

**useMemo** et **useCallback** = Les hooks de **performance** ! ⚡

Ils évitent les **recalculs inutiles** et les **re-renders** superflus. Mais attention : mal utilisés, ils peuvent **dégrader** les performances !

---

## Comprendre le Problème

### Re-renders et Recalculs Inutiles

```jsx
function SlowComponent({ items, filter }) {
  const [count, setCount] = useState(0)

  // ❌ PROBLÈME - Calcul coûteux à CHAQUE rendu !
  const expensiveValue = items
    .filter(item => item.category === filter)
    .reduce((sum, item) => sum + item.price, 0)
  
  console.log('💰 Calcul coûteux exécuté !') // ← Se déclenche même quand count change !

  // ❌ PROBLÈME - Nouvel objet à chaque rendu !
  const chartConfig = {
    type: 'bar',
    data: expensiveValue,
    options: { responsive: true }
  }

  // ❌ PROBLÈME - Nouvelle fonction à chaque rendu !
  const handleItemClick = (itemId) => {
    console.log('Item clicked:', itemId)
  }

  return (
    <div>
      <h3>Total: {expensiveValue}€</h3>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
      
      <ExpensiveChart config={chartConfig} />
      <ItemsList items={items} onItemClick={handleItemClick} />
    </div>
  )
}

// Ces composants re-render même si leurs props n'ont pas changé !
const ExpensiveChart = memo(function ExpensiveChart({ config }) {
  console.log('📊 ExpensiveChart re-rendu') // ← Toujours appelé !
  return <div>Chart avec config: {JSON.stringify(config)}</div>
})

const ItemsList = memo(function ItemsList({ items, onItemClick }) {
  console.log('📝 ItemsList re-rendu') // ← Toujours appelé !
  return (
    <ul>
      {items.map(item => (
        <li key={item.id} onClick={() => onItemClick(item.id)}>
          {item.name}
        </li>
      ))}
    </ul>
  )
})
```

---

## useMemo pour les Calculs Coûteux

### Syntaxe et Usage Basique

```jsx
import { useMemo } from 'react'

function OptimizedComponent({ items, filter }) {
  const [count, setCount] = useState(0)

  // ✅ SOLUTION - Calcul seulement si items ou filter changent
  const expensiveValue = useMemo(() => {
    console.log('💰 Calcul coûteux exécuté') // ← Seulement si nécessaire !
    
    return items
      .filter(item => item.category === filter)
      .reduce((sum, item) => sum + item.price, 0)
  }, [items, filter]) // ← Dépendances

  // ✅ Objet complexe mémorisé
  const chartConfig = useMemo(() => {
    console.log('📊 Configuration chart générée')
    
    return {
      type: 'bar',
      data: expensiveValue,
      options: { responsive: true },
      theme: 'modern'
    }
  }, [expensiveValue])

  // ✅ Données filtrées mémorisées
  const filteredItems = useMemo(() => {
    console.log('🔍 Filtrage des items')
    
    return items
      .filter(item => item.category === filter)
      .sort((a, b) => b.price - a.price) // Tri par prix décroissant
  }, [items, filter])

  return (
    <div>
      <h3>Total: {expensiveValue}€</h3>
      <p>Count: {count} (ne déclenche plus le calcul !)</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
      
      <ExpensiveChart config={chartConfig} />
      <FilteredItemsList items={filteredItems} />
    </div>
  )
}

const FilteredItemsList = memo(function FilteredItemsList({ items }) {
  console.log('📝 FilteredItemsList re-rendu')
  
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>
          {item.name} - {item.price}€
        </li>
      ))}
    </ul>
  )
})
```

### Exemples Pratiques avec useMemo

```jsx
function UseMemoExamples() {
  const [users, setUsers] = useState([
    { id: 1, name: 'Andy', age: 25, department: 'IT', salary: 50000 },
    { id: 2, name: 'Marie', age: 30, department: 'HR', salary: 45000 },
    { id: 3, name: 'Paul', age: 35, department: 'IT', salary: 60000 },
    { id: 4, name: 'Sophie', age: 28, department: 'Marketing', salary: 48000 }
  ])
  const [searchTerm, setSearchTerm] = useState('')
  const [department, setDepartment] = useState('all')
  const [sortBy, setSortBy] = useState('name')

  // ✅ Filtrage et recherche mémorisés
  const filteredUsers = useMemo(() => {
    console.log('🔍 Filtrage users')
    
    return users.filter(user => {
      const matchesSearch = user.name.toLowerCase().includes(searchTerm.toLowerCase())
      const matchesDepartment = department === 'all' || user.department === department
      return matchesSearch && matchesDepartment
    })
  }, [users, searchTerm, department])

  // ✅ Tri mémorisé
  const sortedUsers = useMemo(() => {
    console.log('📊 Tri users')
    
    return [...filteredUsers].sort((a, b) => {
      switch (sortBy) {
        case 'name':
          return a.name.localeCompare(b.name)
        case 'age':
          return a.age - b.age
        case 'salary':
          return b.salary - a.salary // Décroissant
        default:
          return 0
      }
    })
  }, [filteredUsers, sortBy])

  // ✅ Statistiques mémorisées
  const stats = useMemo(() => {
    console.log('📈 Calcul statistiques')
    
    if (sortedUsers.length === 0) {
      return { total: 0, avgAge: 0, avgSalary: 0, departments: [] }
    }

    const totalSalary = sortedUsers.reduce((sum, user) => sum + user.salary, 0)
    const totalAge = sortedUsers.reduce((sum, user) => sum + user.age, 0)
    const departments = [...new Set(sortedUsers.map(user => user.department))]

    return {
      total: sortedUsers.length,
      avgAge: Math.round(totalAge / sortedUsers.length),
      avgSalary: Math.round(totalSalary / sortedUsers.length),
      departments: departments
    }
  }, [sortedUsers])

  const departments = useMemo(() => {
    return [...new Set(users.map(user => user.department))]
  }, [users])

  return (
    <div>
      <h3>Gestion Utilisateurs Optimisée</h3>
      
      {/* Contrôles */}
      <div style={{ marginBottom: '20px' }}>
        <input
          value={searchTerm}
          onChange={e => setSearchTerm(e.target.value)}
          placeholder="Rechercher par nom..."
          style={{ marginRight: '10px', padding: '5px' }}
        />
        
        <select
          value={department}
          onChange={e => setDepartment(e.target.value)}
          style={{ marginRight: '10px', padding: '5px' }}
        >
          <option value="all">Tous les départements</option>
          {departments.map(dept => (
            <option key={dept} value={dept}>{dept}</option>
          ))}
        </select>
        
        <select
          value={sortBy}
          onChange={e => setSortBy(e.target.value)}
          style={{ padding: '5px' }}
        >
          <option value="name">Trier par nom</option>
          <option value="age">Trier par âge</option>
          <option value="salary">Trier par salaire</option>
        </select>
      </div>

      {/* Statistiques */}
      <div style={{ background: '#f8f9fa', padding: '15px', marginBottom: '20px' }}>
        <h4>Statistiques</h4>
        <p>Total: {stats.total} utilisateurs</p>
        <p>Âge moyen: {stats.avgAge} ans</p>
        <p>Salaire moyen: {stats.avgSalary.toLocaleString()}€</p>
        <p>Départements: {stats.departments.join(', ')}</p>
      </div>

      {/* Liste */}
      <UsersList users={sortedUsers} />
    </div>
  )
}

const UsersList = memo(function UsersList({ users }) {
  console.log('👥 UsersList re-rendu')
  
  return (
    <div>
      <h4>Utilisateurs ({users.length})</h4>
      <ul>
        {users.map(user => (
          <li key={user.id} style={{ marginBottom: '5px' }}>
            <strong>{user.name}</strong> ({user.age} ans) - {user.department} - {user.salary.toLocaleString()}€
          </li>
        ))}
      </ul>
    </div>
  )
})
```

---

## useCallback pour les Fonctions

### Syntaxe et Usage Basique

```jsx
import { useCallback } from 'react'

function CallbackExample() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')
  const [todos, setTodos] = useState([])

  // ❌ MAUVAIS - Nouvelle fonction à chaque rendu
  const addTodoBad = (text) => {
    setTodos(prev => [...prev, { id: Date.now(), text }])
  }

  // ✅ BON - Fonction mémorisée
  const addTodoGood = useCallback((text) => {
    setTodos(prev => [...prev, { id: Date.now(), text, completed: false }])
  }, []) // ← Pas de dépendances = fonction stable

  // ✅ Fonction avec dépendances
  const addTodoWithPrefix = useCallback((text) => {
    const prefix = name ? `[${name}] ` : ''
    setTodos(prev => [...prev, { 
      id: Date.now(), 
      text: prefix + text,
      completed: false 
    }])
  }, [name]) // ← Se recrée seulement si name change

  // ✅ Event handlers optimisés
  const handleCountChange = useCallback((increment) => {
    setCount(prev => prev + increment)
  }, [])

  const toggleTodo = useCallback((id) => {
    setTodos(prev => 
      prev.map(todo =>
        todo.id === id 
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    )
  }, [])

  const deleteTodo = useCallback((id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id))
  }, [])

  return (
    <div>
      <h3>useCallback Example</h3>

      <div>
        <p>Count: {count}</p>
        <OptimizedButton onClick={handleCountChange} increment={1}>
          +1
        </OptimizedButton>
        <OptimizedButton onClick={handleCountChange} increment={5}>
          +5
        </OptimizedButton>
      </div>

      <div>
        <input
          value={name}
          onChange={e => setName(e.target.value)}
          placeholder="Préfixe pour les todos..."
        />
      </div>

      <TodoForm
        onAddTodo={addTodoGood}
        onAddTodoWithPrefix={addTodoWithPrefix}
      />

      <TodoList 
        todos={todos}
        onToggle={toggleTodo}
        onDelete={deleteTodo}
      />
    </div>
  )
}

// Composants optimisés qui bénéficient de useCallback
const OptimizedButton = memo(function OptimizedButton({ onClick, increment, children }) {
  console.log(`🔄 OptimizedButton (+${increment}) re-rendu`)

  return (
    <button onClick={() => onClick(increment)} style={{ margin: '5px' }}>
      {children}
    </button>
  )
})

const TodoForm = memo(function TodoForm({ onAddTodo, onAddTodoWithPrefix }) {
  console.log('🔄 TodoForm re-rendu')
  const [input, setInput] = useState('')

  const handleSubmit = (e) => {
    e.preventDefault()
    if (input.trim()) {
      onAddTodo(input.trim())
      setInput('')
    }
  }

  const handleSubmitWithPrefix = (e) => {
    e.preventDefault()
    if (input.trim()) {
      onAddTodoWithPrefix(input.trim())
      setInput('')
    }
  }

  return (
    <form>
      <input
        value={input}
        onChange={e => setInput(e.target.value)}
        placeholder="Nouvelle tâche..."
        style={{ padding: '5px', marginRight: '10px' }}
      />
      <button type="submit" onClick={handleSubmit}>Ajouter</button>
      <button type="button" onClick={handleSubmitWithPrefix}>
        Ajouter avec préfixe
      </button>
    </form>
  )
})

const TodoList = memo(function TodoList({ todos, onToggle, onDelete }) {
  console.log('🔄 TodoList re-rendu')

  return (
    <ul>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={() => onToggle(todo.id)}
          onDelete={() => onDelete(todo.id)}
        />
      ))}
    </ul>
  )
})

const TodoItem = memo(function TodoItem({ todo, onToggle, onDelete }) {
  return (
    <li style={{
      display: 'flex',
      alignItems: 'center',
      padding: '5px',
      backgroundColor: todo.completed ? '#f8f9fa' : 'white'
    }}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={onToggle}
        style={{ marginRight: '10px' }}
      />
      <span style={{
        flex: 1,
        textDecoration: todo.completed ? 'line-through' : 'none'
      }}>
        {todo.text}
      </span>
      <button onClick={onDelete} style={{ background: 'red', color: 'white' }}>
        ❌
      </button>
    </li>
  )
})
```

---

## Patterns Avancés

### Custom Hooks avec Mémorisation

```jsx
// Hook custom optimisé
function useOptimizedApi(url, options = {}) {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)

  // Mémoriser les options pour éviter les re-fetch inutiles
  const memoizedOptions = useMemo(() => options, [
    options.method,
    options.headers,
    // ← Seulement les props importantes, pas l'objet entier
  ])

  // Fonction de fetch mémorisée
  const fetchData = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)

      const response = await fetch(url, {
        headers: { 'Content-Type': 'application/json' },
        ...memoizedOptions
      })

      if (!response.ok) throw new Error(`HTTP ${response.status}`)

      const result = await response.json()
      setData(result)
    } catch (err) {
      setError(err.message)
    } finally {
      setLoading(false)
    }
  }, [url, memoizedOptions])

  // Refetch mémorisé
  const refetch = useCallback(() => {
    fetchData()
  }, [fetchData])

  useEffect(() => {
    fetchData()
  }, [fetchData])

  // Retourner un objet mémorisé
  return useMemo(() => ({
    data,
    loading,
    error,
    refetch
  }), [data, loading, error, refetch])
}

// Utilisation du hook optimisé
function ApiExample() {
  const [userId, setUserId] = useState(1)
  
  const apiOptions = useMemo(() => ({
    method: 'GET',
    headers: { 'Authorization': 'Bearer token123' }
  }), [])

  const { data: user, loading, error, refetch } = useOptimizedApi(
    `/api/users/${userId}`,
    apiOptions
  )

  const handleUserChange = useCallback((newUserId) => {
    setUserId(newUserId)
  }, [])

  if (loading) return <div>Chargement...</div>
  if (error) return <div>Erreur: {error}</div>

  return (
    <div>
      <h3>Utilisateur {userId}</h3>
      {user && (
        <div>
          <p>Nom: {user.name}</p>
          <p>Email: {user.email}</p>
        </div>
      )}
      
      <div>
        <button onClick={() => handleUserChange(1)}>User 1</button>
        <button onClick={() => handleUserChange(2)}>User 2</button>
        <button onClick={() => handleUserChange(3)}>User 3</button>
        <button onClick={refetch}>🔄 Rafraîchir</button>
      </div>
    </div>
  )
}
```

### Mémorisation Conditionnelle

```jsx
function ConditionalMemoization({ items, mode }) {
  const [isExpensive, setIsExpensive] = useState(true)

  // Mémorisation seulement si le mode est "expensive"
  const processedItems = useMemo(() => {
    if (!isExpensive) {
      // Pas de mémorisation pour les calculs simples
      return items.map(item => ({ ...item, processed: true }))
    }

    console.log('💰 Calcul coûteux avec mémorisation')
    
    // Simulation d'un calcul très coûteux
    return items.map(item => ({
      ...item,
      processed: true,
      score: item.value * Math.random() * 1000,
      category: item.value > 50 ? 'premium' : 'standard',
      // Calcul complexe fictif
      complexity: Array.from({ length: 1000 }, () => Math.random()).reduce((a, b) => a + b)
    }))
  }, isExpensive ? [items] : null) // ← Mémorisation conditionnelle !

  // Callback conditionnel
  const handleItemClick = useCallback((itemId) => {
    console.log('Item clicked:', itemId)
    // Logique complexe seulement si nécessaire
    if (mode === 'advanced') {
      // Calculs avancés...
    }
  }, mode === 'advanced' ? [mode] : [])

  return (
    <div>
      <h3>Mémorisation Conditionnelle</h3>
      
      <div>
        <label>
          <input
            type="checkbox"
            checked={isExpensive}
            onChange={e => setIsExpensive(e.target.checked)}
          />
          Mode calcul coûteux
        </label>
      </div>

      <ul>
        {processedItems.map(item => (
          <li key={item.id} onClick={() => handleItemClick(item.id)}>
            {item.name} - Score: {item.score?.toFixed(2) || 'N/A'}
          </li>
        ))}
      </ul>
    </div>
  )
}
```

---

## Profiling et Debugging

### Outils de Mesure Performance

```jsx
function PerformanceExample() {
  const [items, setItems] = useState(Array.from({ length: 1000 }, (_, i) => ({
    id: i,
    name: `Item ${i}`,
    value: Math.random() * 100
  })))
  const [filter, setFilter] = useState('')

  // Version NON optimisée
  const expensiveCalculationNoMemo = items
    .filter(item => item.name.includes(filter))
    .map(item => ({ ...item, doubled: item.value * 2 }))
    .reduce((sum, item) => sum + item.doubled, 0)

  // Version optimisée
  const expensiveCalculationWithMemo = useMemo(() => {
    console.time('🔄 Calcul avec useMemo')
    
    const result = items
      .filter(item => item.name.includes(filter))
      .map(item => ({ ...item, doubled: item.value * 2 }))
      .reduce((sum, item) => sum + item.doubled, 0)
    
    console.timeEnd('🔄 Calcul avec useMemo')
    return result
  }, [items, filter])

  // Profiler component re-renders
  const renderCount = useRef(0)
  renderCount.current++

  console.log(`🎯 Component rendered ${renderCount.current} times`)

  const addRandomItem = useCallback(() => {
    setItems(prev => [...prev, {
      id: prev.length,
      name: `Item ${prev.length}`,
      value: Math.random() * 100
    }])
  }, [])

  return (
    <div>
      <h3>Performance Profiling</h3>
      <p>Renders: {renderCount.current}</p>
      
      <div>
        <input
          value={filter}
          onChange={e => setFilter(e.target.value)}
          placeholder="Filter items..."
        />
        <button onClick={addRandomItem}>Add Item</button>
      </div>

      <div>
        <p>Sans memo: {expensiveCalculationNoMemo.toFixed(2)}</p>
        <p>Avec memo: {expensiveCalculationWithMemo.toFixed(2)}</p>
        <p>Items count: {items.length}</p>
      </div>
    </div>
  )
}

// Wrapper pour mesurer les re-renders
function withRenderProfiler(WrappedComponent, name) {
  return memo(function ProfiledComponent(props) {
    const renderCount = useRef(0)
    renderCount.current++
    
    console.log(`📊 ${name} rendered ${renderCount.current} times`)
    
    return <WrappedComponent {...props} />
  })
}

// Usage
const ProfiledExpensiveComponent = withRenderProfiler(ExpensiveComponent, 'ExpensiveComponent')
```

---

## Bonnes Pratiques

### Quand Utiliser (et Ne Pas Utiliser)

```jsx
function BestPracticesExamples() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')

  // ✅ BON - Calcul vraiment coûteux
  const expensiveComputation = useMemo(() => {
    // Simulation d'un calcul complexe
    let result = 0
    for (let i = 0; i < 1000000; i++) {
      result += Math.sqrt(i)
    }
    return result
  }, []) // Une seule fois

  // ❌ MAUVAIS - Mémoriser des valeurs primitives simples
  const badUseMemo = useMemo(() => count * 2, [count]) // ❌ Inutile !
  const goodDirectCalc = count * 2 // ✅ Direct

  // ✅ BON - Mémoriser des objets/arrays complexes
  const userConfig = useMemo(() => ({
    theme: 'dark',
    permissions: ['read', 'write'],
    settings: { notifications: true }
  }), [])

  // ❌ MAUVAIS - useCallback sans composant memo enfant
  const badCallback = useCallback(() => {
    console.log('Bad callback')
  }, [])

  // ✅ BON - useCallback avec composant memo enfant
  const goodCallback = useCallback(() => {
    console.log('Good callback')
  }, [])

  return (
    <div>
      <h3>Bonnes vs Mauvaises Pratiques</h3>
      
      <p>Count: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>+1</button>
      
      <p>Expensive: {expensiveComputation.toFixed(2)}</p>
      <p>Bad memo: {badUseMemo}</p>
      <p>Direct calc: {goodDirectCalc}</p>
      
      {/* Ce composant ne bénéficie PAS de badCallback */}
      <RegularComponent onClick={badCallback} />
      
      {/* Ce composant bénéficie de goodCallback */}
      <MemoizedComponent onClick={goodCallback} />
    </div>
  )
}

function RegularComponent({ onClick }) {
  console.log('RegularComponent re-render') // ← Toujours appelé
  return <button onClick={onClick}>Regular Button</button>
}

const MemoizedComponent = memo(function MemoizedComponent({ onClick }) {
  console.log('MemoizedComponent re-render') // ← Seulement si onClick change
  return <button onClick={onClick}>Memoized Button</button>
})
```

### Éviter les Dépendances Instables

```jsx
function StableDependencies() {
  const [user, setUser] = useState({ name: 'Andy', age: 25 })
  const [settings, setSettings] = useState({ theme: 'light' })

  // ❌ MAUVAIS - Objet dans les dépendances
  const badMemo = useMemo(() => {
    return `${user.name} (${user.age}) - Theme: ${settings.theme}`
  }, [user, settings]) // ← Objects changent à chaque setState !

  // ✅ BON - Propriétés primitives dans les dépendances
  const goodMemo = useMemo(() => {
    return `${user.name} (${user.age}) - Theme: ${settings.theme}`
  }, [user.name, user.age, settings.theme]) // ← Seulement les valeurs nécessaires

  // ❌ MAUVAIS - Fonction inline dans les dépendances
  const badCallback = useCallback((id) => {
    const processor = (item) => item.id === id // ← Nouvelle fonction !
    return user.items?.find(processor)
  }, [user.items, (item) => item.id]) // ❌ Fonction anonyme !

  // ✅ BON - Fonction stable ou pas de fonction inline
  const goodCallback = useCallback((id) => {
    return user.items?.find(item => item.id === id)
  }, [user.items])

  const updateUserName = useCallback((newName) => {
    setUser(prev => ({ ...prev, name: newName }))
  }, [])

  return (
    <div>
      <h3>Dépendances Stables</h3>
      <p>Bad memo: {badMemo}</p>
      <p>Good memo: {goodMemo}</p>
      
      <input
        onChange={e => updateUserName(e.target.value)}
        placeholder="Nouveau nom"
      />
    </div>
  )
}
```

---

## Points Clés à Retenir

1. **useMemo** = mémorise les **résultats** de calculs
2. **useCallback** = mémorise les **fonctions**
3. **Dépendances** = array des valeurs utilisées dans le hook
4. **Performance** = ne pas abuser, mesurer l'impact réel
5. **memo()** = wrapper pour éviter les re-renders inutiles
6. **Primitives** = préférer dans les dépendances vs objets/arrays
7. **Profiling** = utiliser React DevTools Profiler

---

## Erreurs Communes

### 1. Mémoriser des Valeurs Simples

```jsx
// ❌ MAUVAIS - Overhead inutile
const simpleValue = useMemo(() => count * 2, [count])

// ✅ BON - Calcul direct
const simpleValue = count * 2
```

### 2. Oublier les Dépendances

```jsx
// ❌ MAUVAIS - Dépendances manquantes
const memoValue = useMemo(() => {
  return items.filter(item => item.name.includes(filter)) // filter utilisé !
}, [items]) // ❌ filter manquant !

// ✅ BON - Toutes les dépendances
const memoValue = useMemo(() => {
  return items.filter(item => item.name.includes(filter))
}, [items, filter])
```

### 3. useCallback sans memo

```jsx
// ❌ INUTILE - Pas de composant memo enfant
const callback = useCallback(() => {
  console.log('Hello')
}, [])

return <RegularComponent onClick={callback} /> // ❌ Re-render quand même !

// ✅ UTILE - Avec composant memo
return <MemoComponent onClick={callback} /> // ✅ Évite les re-renders !
```

---

## Ressources Pour Aller Plus Loin

- 📚 [useMemo Documentation](https://react.dev/reference/react/useMemo)
- 🎯 [useCallback Documentation](https://react.dev/reference/react/useCallback)
- 💡 [When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)
- ⚡ [React Performance](https://react.dev/learn/render-and-commit)
- 🔧 [React DevTools Profiler](https://react.dev/blog/2018/09/10/introducing-the-react-profiler)

---

**Prochaine étape :** La gestion d'état complexe avec `useReducer` dans `15.0.4.4-useReducer.md` ! 🔄
