# React - Custom Hooks : R√©utilisabilit√©

Les hooks personnalis√©s te permettent d'extraire la logique des composants et de la **r√©utiliser** partout. C'est l'un des trucs les plus puissants de React !
Attention ceci dit, c'est utile dans le cas ou on veux extraire la logique d'un endroit qui est utilis√© √† plusieurs endroits !

---

## Qu'est-ce qu'un Custom Hook ?

### D√©finition

Un custom hook est une **fonction JavaScript** qui :

1. **Commence par "use"** (convention obligatoire)
2. **Peut utiliser d'autres hooks** (useState, useEffect, etc.)
3. **Retourne de la logique r√©utilisable**
4. **Suit les r√®gles des hooks**

```jsx
// ‚úÖ Custom Hook basique
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue)

  const increment = useCallback(() => setCount(c => c + 1), [])
  const decrement = useCallback(() => setCount(c => c - 1), [])
  const reset = useCallback(() => setCount(initialValue), [initialValue])

  return { count, increment, decrement, reset }
}

// Utilisation
function Counter() {
  const { count, increment, decrement, reset } = useCounter(10)

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+1</button>
      <button onClick={decrement}>-1</button>
      <button onClick={reset}>Reset</button>
    </div>
  )
}
```

---

## Hooks Utilitaires Simples

### useToggle - Basculer un Bool√©en

```jsx
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue)

  const toggle = useCallback(() => setValue(v => !v), [])
  const setTrue = useCallback(() => setValue(true), [])
  const setFalse = useCallback(() => setValue(false), [])

  return [
    value,
    {
      toggle,
      setTrue,
      setFalse,
      setValue
    }
  ]
}

// Utilisation
function ToggleDemo() {
  const [isVisible, visibility] = useToggle(false)
  const [isLoading, loading] = useToggle(false)
  const [isDarkMode, darkMode] = useToggle(true)

  const simulateLoading = async () => {
    loading.setTrue()
    await new Promise(resolve => setTimeout(resolve, 2000))
    loading.setFalse()
  }

  return (
    <div style={{
      backgroundColor: isDarkMode ? '#333' : '#fff',
      color: isDarkMode ? '#fff' : '#333',
      padding: '20px',
      minHeight: '200px'
    }}>
      <h3>useToggle Demo</h3>
      
      <div>
        <button onClick={visibility.toggle}>
          {isVisible ? 'Masquer' : 'Afficher'} le contenu
        </button>
        {isVisible && <p>üéâ Contenu visible !</p>}
      </div>

      <div>
        <button onClick={simulateLoading} disabled={isLoading}>
          {isLoading ? 'Chargement...' : 'Simuler chargement'}
        </button>
      </div>

      <div>
        <button onClick={darkMode.toggle}>
          {isDarkMode ? '‚òÄÔ∏è Mode clair' : 'üåô Mode sombre'}
        </button>
      </div>
    </div>
  )
}
```

### useLocalStorage - Persistance Automatique

```jsx
function useLocalStorage(key, initialValue) {
  // R√©cup√©rer la valeur initiale depuis localStorage
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      console.error(`Erreur localStorage pour "${key}":`, error)
      return initialValue
    }
  })

  // Fonction pour sauvegarder dans localStorage
  const setValue = useCallback((value) => {
    try {
      // Permettre √† value d'√™tre une fonction
      const valueToStore = value instanceof Function ? value(storedValue) : value
      
      setStoredValue(valueToStore)
      
      if (valueToStore === undefined) {
        window.localStorage.removeItem(key)
      } else {
        window.localStorage.setItem(key, JSON.stringify(valueToStore))
      }
    } catch (error) {
      console.error(`Erreur sauvegarde localStorage pour "${key}":`, error)
    }
  }, [key, storedValue])

  // Fonction pour supprimer
  const removeValue = useCallback(() => {
    try {
      window.localStorage.removeItem(key)
      setStoredValue(initialValue)
    } catch (error) {
      console.error(`Erreur suppression localStorage pour "${key}":`, error)
    }
  }, [key, initialValue])

  return [storedValue, setValue, removeValue]
}

// Utilisation
function UserPreferences() {
  const [name, setName, removeName] = useLocalStorage('user-name', '')
  const [theme, setTheme] = useLocalStorage('user-theme', 'light')
  const [settings, setSettings] = useLocalStorage('user-settings', {
    notifications: true,
    language: 'fr'
  })

  const updateSetting = (key, value) => {
    setSettings(prev => ({ ...prev, [key]: value }))
  }

  return (
    <div>
      <h3>Pr√©f√©rences Utilisateur (persistantes)</h3>
      
      <div>
        <label>
          Nom:
          <input
            value={name}
            onChange={e => setName(e.target.value)}
            placeholder="Votre nom..."
          />
        </label>
        <button onClick={removeName}>Supprimer nom</button>
      </div>

      <div>
        <label>
          <input
            type="checkbox"
            checked={theme === 'dark'}
            onChange={e => setTheme(e.target.checked ? 'dark' : 'light')}
          />
          Mode sombre
        </label>
      </div>

      <div>
        <label>
          <input
            type="checkbox"
            checked={settings.notifications}
            onChange={e => updateSetting('notifications', e.target.checked)}
          />
          Notifications
        </label>
      </div>

      <div>
        <label>
          Langue:
          <select
            value={settings.language}
            onChange={e => updateSetting('language', e.target.value)}
          >
            <option value="fr">Fran√ßais</option>
            <option value="en">English</option>
          </select>
        </label>
      </div>

      <div style={{ marginTop: '20px', fontSize: '12px', color: '#666' }}>
        <p>‚úÖ Toutes les donn√©es sont sauvegard√©es automatiquement !</p>
        <p>Nom: {name || 'Non d√©fini'}</p>
        <p>Th√®me: {theme}</p>
        <p>Param√®tres: {JSON.stringify(settings)}</p>
      </div>
    </div>
  )
}
```

### usePrevious - Valeur Pr√©c√©dente

```jsx
function usePrevious(value) {
  const ref = useRef()
  
  useEffect(() => {
    ref.current = value
  })
  
  return ref.current
}

// Utilisation
function PreviousDemo() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('')
  
  const previousCount = usePrevious(count)
  const previousName = usePrevious(name)

  return (
    <div>
      <h3>usePrevious Demo</h3>
      
      <div>
        <p>Count actuel: {count}</p>
        <p>Count pr√©c√©dent: {previousCount}</p>
        <p>Diff√©rence: {count - (previousCount || 0)}</p>
        <button onClick={() => setCount(c => c + 1)}>+1</button>
        <button onClick={() => setCount(c => c - 1)}>-1</button>
      </div>

      <div style={{ marginTop: '20px' }}>
        <input
          value={name}
          onChange={e => setName(e.target.value)}
          placeholder="Tapez quelque chose..."
        />
        <p>Nom actuel: "{name}"</p>
        <p>Nom pr√©c√©dent: "{previousName || 'N/A'}"</p>
      </div>
    </div>
  )
}
```

---

## Hooks de Donn√©es et API

### useFetch - Appels API Simplifi√©s

```jsx
function useFetch(url, options = {}) {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  const fetchData = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)

      const response = await fetch(url, {
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        },
        ...options
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const result = await response.json()
      setData(result)
    } catch (err) {
      setError(err.message)
    } finally {
      setLoading(false)
    }
  }, [url, JSON.stringify(options)])

  const refetch = useCallback(() => {
    fetchData()
  }, [fetchData])

  useEffect(() => {
    fetchData()
  }, [fetchData])

  return { data, loading, error, refetch }
}

// Hook plus avanc√© avec cache
function useApi(baseUrl) {
  const [cache, setCache] = useState(new Map())

  const get = useCallback(async (endpoint, useCache = true) => {
    const fullUrl = `${baseUrl}${endpoint}`
    
    // V√©rifier le cache
    if (useCache && cache.has(fullUrl)) {
      console.log('üì¶ Donn√©es depuis le cache:', fullUrl)
      return cache.get(fullUrl)
    }

    console.log('üåê Fetch API:', fullUrl)
    const response = await fetch(fullUrl)
    if (!response.ok) throw new Error(`HTTP ${response.status}`)
    
    const data = await response.json()
    
    // Sauvegarder dans le cache
    if (useCache) {
      setCache(prev => new Map(prev).set(fullUrl, data))
    }
    
    return data
  }, [baseUrl, cache])

  const post = useCallback(async (endpoint, body) => {
    const response = await fetch(`${baseUrl}${endpoint}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    })
    if (!response.ok) throw new Error(`HTTP ${response.status}`)
    return response.json()
  }, [baseUrl])

  const clearCache = useCallback(() => {
    setCache(new Map())
  }, [])

  return { get, post, clearCache, cacheSize: cache.size }
}

// Utilisation des hooks d'API
function ApiDemo() {
  const { data: users, loading, error, refetch } = useFetch(
    'https://jsonplaceholder.typicode.com/users'
  )
  
  const api = useApi('https://jsonplaceholder.typicode.com')
  const [posts, setPosts] = useState(null)
  const [postsLoading, setPostsLoading] = useState(false)

  const loadPosts = async () => {
    setPostsLoading(true)
    try {
      const data = await api.get('/posts?_limit=5')
      setPosts(data)
    } catch (error) {
      console.error('Erreur posts:', error)
    } finally {
      setPostsLoading(false)
    }
  }

  return (
    <div>
      <h3>API Hooks Demo</h3>
      
      <div>
        <h4>useFetch - Utilisateurs</h4>
        {loading && <p>Chargement users...</p>}
        {error && <p>Erreur: {error}</p>}
        {users && (
          <div>
            <p>{users.length} utilisateurs charg√©s</p>
            <button onClick={refetch}>üîÑ Rafra√Æchir</button>
          </div>
        )}
      </div>

      <div style={{ marginTop: '20px' }}>
        <h4>useApi - Posts (avec cache)</h4>
        <p>Taille du cache: {api.cacheSize} entr√©es</p>
        <button onClick={loadPosts} disabled={postsLoading}>
          {postsLoading ? 'Chargement...' : 'Charger Posts'}
        </button>
        <button onClick={api.clearCache}>üóëÔ∏è Vider cache</button>
        
        {posts && (
          <ul>
            {posts.slice(0, 3).map(post => (
              <li key={post.id}>{post.title}</li>
            ))}
          </ul>
        )}
      </div>
    </div>
  )
}
```

### useAsync - Actions Asynchrones

```jsx
function useAsync(asyncFunction, dependencies = []) {
  const [state, setState] = useState({
    data: null,
    loading: false,
    error: null
  })

  const execute = useCallback(async (...args) => {
    setState(prev => ({ ...prev, loading: true, error: null }))

    try {
      const data = await asyncFunction(...args)
      setState({ data, loading: false, error: null })
      return data
    } catch (error) {
      setState({ data: null, loading: false, error })
      throw error
    }
  }, dependencies)

  const reset = useCallback(() => {
    setState({ data: null, loading: false, error: null })
  }, [])

  return {
    ...state,
    execute,
    reset
  }
}

// Hook pour les formulaires
function useAsyncForm(submitFunction) {
  const [formState, setFormState] = useState({
    values: {},
    errors: {},
    touched: {},
    isSubmitting: false,
    isValid: true
  })

  const setFieldValue = useCallback((name, value) => {
    setFormState(prev => ({
      ...prev,
      values: { ...prev.values, [name]: value },
      errors: { ...prev.errors, [name]: null }
    }))
  }, [])

  const setFieldTouched = useCallback((name, touched = true) => {
    setFormState(prev => ({
      ...prev,
      touched: { ...prev.touched, [name]: touched }
    }))
  }, [])

  const setFieldError = useCallback((name, error) => {
    setFormState(prev => ({
      ...prev,
      errors: { ...prev.errors, [name]: error }
    }))
  }, [])

  const handleSubmit = useCallback(async (event) => {
    event?.preventDefault()

    setFormState(prev => ({ ...prev, isSubmitting: true }))

    try {
      const result = await submitFunction(formState.values)
      setFormState(prev => ({ ...prev, isSubmitting: false }))
      return result
    } catch (error) {
      setFormState(prev => ({ 
        ...prev, 
        isSubmitting: false,
        errors: { ...prev.errors, _form: error.message }
      }))
      throw error
    }
  }, [submitFunction, formState.values])

  const reset = useCallback(() => {
    setFormState({
      values: {},
      errors: {},
      touched: {},
      isSubmitting: false,
      isValid: true
    })
  }, [])

  return {
    values: formState.values,
    errors: formState.errors,
    touched: formState.touched,
    isSubmitting: formState.isSubmitting,
    isValid: formState.isValid,
    setFieldValue,
    setFieldTouched,
    setFieldError,
    handleSubmit,
    reset
  }
}

// Utilisation
function AsyncDemo() {
  // useAsync pour une fonction simple
  const {
    data: randomJoke,
    loading: jokeLoading,
    error: jokeError,
    execute: fetchJoke
  } = useAsync(async () => {
    const response = await fetch('https://api.chucknorris.io/jokes/random')
    return response.json()
  })

  // useAsyncForm pour un formulaire
  const form = useAsyncForm(async (values) => {
    // Simulation d'une soumission de formulaire
    await new Promise(resolve => setTimeout(resolve, 2000))
    console.log('Formulaire soumis:', values)
    return { success: true, message: 'Donn√©es sauvegard√©es !' }
  })

  return (
    <div>
      <h3>useAsync Demo</h3>
      
      <div>
        <h4>Chuck Norris Jokes</h4>
        <button onClick={fetchJoke} disabled={jokeLoading}>
          {jokeLoading ? 'Chargement...' : 'Nouvelle blague'}
        </button>
        
        {jokeError && <p style={{ color: 'red' }}>Erreur: {jokeError.message}</p>}
        {randomJoke && (
          <p style={{ 
            background: '#f0f0f0', 
            padding: '10px', 
            borderRadius: '4px',
            marginTop: '10px'
          }}>
            {randomJoke.value}
          </p>
        )}
      </div>

      <div style={{ marginTop: '30px' }}>
        <h4>Formulaire Async</h4>
        <form onSubmit={form.handleSubmit}>
          <div>
            <input
              type="text"
              value={form.values.name || ''}
              onChange={e => form.setFieldValue('name', e.target.value)}
              onBlur={() => form.setFieldTouched('name')}
              placeholder="Votre nom..."
            />
            {form.errors.name && <span style={{ color: 'red' }}>{form.errors.name}</span>}
          </div>

          <div>
            <input
              type="email"
              value={form.values.email || ''}
              onChange={e => form.setFieldValue('email', e.target.value)}
              onBlur={() => form.setFieldTouched('email')}
              placeholder="Votre email..."
            />
            {form.errors.email && <span style={{ color: 'red' }}>{form.errors.email}</span>}
          </div>

          <button type="submit" disabled={form.isSubmitting}>
            {form.isSubmitting ? 'Envoi...' : 'Envoyer'}
          </button>

          {form.errors._form && (
            <p style={{ color: 'red' }}>Erreur: {form.errors._form}</p>
          )}
        </form>
      </div>
    </div>
  )
}
```

---

## Hooks d'Interface Utilisateur

### useWindowSize - Taille de Fen√™tre

```jsx
function useWindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: undefined,
    height: undefined
  })

  useEffect(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      })
    }

    window.addEventListener('resize', handleResize)
    handleResize() // Appel initial

    return () => window.removeEventListener('resize', handleResize)
  }, [])

  return windowSize
}

// Hook pour les breakpoints responsive
function useBreakpoint() {
  const { width } = useWindowSize()

  const breakpoint = useMemo(() => {
    if (width >= 1200) return 'xl'
    if (width >= 992) return 'lg' 
    if (width >= 768) return 'md'
    if (width >= 576) return 'sm'
    return 'xs'
  }, [width])

  return {
    breakpoint,
    isXs: breakpoint === 'xs',
    isSm: breakpoint === 'sm',
    isMd: breakpoint === 'md',
    isLg: breakpoint === 'lg',
    isXl: breakpoint === 'xl',
    isMobile: breakpoint === 'xs' || breakpoint === 'sm',
    isDesktop: breakpoint === 'lg' || breakpoint === 'xl'
  }
}

function ResponsiveDemo() {
  const windowSize = useWindowSize()
  const breakpoint = useBreakpoint()

  return (
    <div>
      <h3>Responsive Hooks Demo</h3>
      
      <div style={{ 
        padding: '20px', 
        backgroundColor: breakpoint.isMobile ? '#ffebee' : '#e8f5e8',
        borderRadius: '8px'
      }}>
        <p>Taille fen√™tre: {windowSize.width}x{windowSize.height}</p>
        <p>Breakpoint: <strong>{breakpoint.breakpoint}</strong></p>
        <p>Device: {breakpoint.isMobile ? 'üì± Mobile' : 'üñ•Ô∏è Desktop'}</p>
        
        {breakpoint.isXs && <p>üì± Tr√®s petit √©cran</p>}
        {breakpoint.isSm && <p>üì± Petit √©cran</p>}
        {breakpoint.isMd && <p>üíª √âcran moyen</p>}
        {breakpoint.isLg && <p>üñ•Ô∏è Grand √©cran</p>}
        {breakpoint.isXl && <p>üñ•Ô∏è Tr√®s grand √©cran</p>}
      </div>
    </div>
  )
}
```

### useClickOutside - Clic en Dehors

```jsx
function useClickOutside(handler) {
  const ref = useRef()

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (ref.current && !ref.current.contains(event.target)) {
        handler(event)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [handler])

  return ref
}

// Hook pour les modales
function useModal() {
  const [isOpen, setIsOpen] = useState(false)

  const open = useCallback(() => setIsOpen(true), [])
  const close = useCallback(() => setIsOpen(false), [])
  const toggle = useCallback(() => setIsOpen(prev => !prev), [])

  // Fermer avec Escape
  useEffect(() => {
    const handleEscape = (event) => {
      if (event.key === 'Escape') {
        close()
      }
    }

    if (isOpen) {
      document.addEventListener('keydown', handleEscape)
      return () => document.removeEventListener('keydown', handleEscape)
    }
  }, [isOpen, close])

  return { isOpen, open, close, toggle }
}

function ModalDemo() {
  const modal = useModal()
  const modalRef = useClickOutside(modal.close)

  const [dropdownOpen, setDropdownOpen] = useState(false)
  const dropdownRef = useClickOutside(() => setDropdownOpen(false))

  return (
    <div>
      <h3>useClickOutside & useModal Demo</h3>
      
      <div>
        <button onClick={modal.open}>Ouvrir Modal</button>
        
        {modal.isOpen && (
          <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: 'rgba(0,0,0,0.5)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000
          }}>
            <div
              ref={modalRef}
              style={{
                backgroundColor: 'white',
                padding: '30px',
                borderRadius: '8px',
                minWidth: '300px'
              }}
            >
              <h4>Modal Example</h4>
              <p>Clique en dehors ou appuie sur Escape pour fermer</p>
              <button onClick={modal.close}>Fermer</button>
            </div>
          </div>
        )}
      </div>

      <div style={{ marginTop: '20px', position: 'relative' }}>
        <button onClick={() => setDropdownOpen(!dropdownOpen)}>
          Dropdown {dropdownOpen ? '‚ñ≤' : '‚ñº'}
        </button>
        
        {dropdownOpen && (
          <div
            ref={dropdownRef}
            style={{
              position: 'absolute',
              top: '100%',
              left: 0,
              backgroundColor: 'white',
              border: '1px solid #ccc',
              borderRadius: '4px',
              padding: '10px',
              boxShadow: '0 2px 10px rgba(0,0,0,0.1)',
              zIndex: 100
            }}
          >
            <div>Option 1</div>
            <div>Option 2</div>
            <div>Option 3</div>
          </div>
        )}
      </div>
    </div>
  )
}
```

---

## Hooks de Performance et Timing

### useDebounce - Retarder les Appels

```jsx
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value)

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    return () => {
      clearTimeout(handler)
    }
  }, [value, delay])

  return debouncedValue
}

// Hook pour debouncer les callbacks
function useDebouncedCallback(callback, delay, dependencies = []) {
  const timeoutRef = useRef()

  return useCallback((...args) => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current)
    }

    timeoutRef.current = setTimeout(() => {
      callback(...args)
    }, delay)
  }, [callback, delay, ...dependencies])
}

function DebounceDemo() {
  const [searchTerm, setSearchTerm] = useState('')
  const [results, setResults] = useState([])
  const [isSearching, setIsSearching] = useState(false)
  
  const debouncedSearchTerm = useDebounce(searchTerm, 500)

  // Simulation de recherche
  useEffect(() => {
    if (debouncedSearchTerm) {
      setIsSearching(true)
      
      // Simuler un appel API
      setTimeout(() => {
        const mockResults = [
          `R√©sultat 1 pour "${debouncedSearchTerm}"`,
          `R√©sultat 2 pour "${debouncedSearchTerm}"`,
          `R√©sultat 3 pour "${debouncedSearchTerm}"`
        ]
        setResults(mockResults)
        setIsSearching(false)
      }, 1000)
    } else {
      setResults([])
      setIsSearching(false)
    }
  }, [debouncedSearchTerm])

  // Debounced callback pour les saves
  const [saveStatus, setSaveStatus] = useState('')
  const debouncedSave = useDebouncedCallback(() => {
    setSaveStatus('Sauvegard√© ‚úÖ')
    setTimeout(() => setSaveStatus(''), 2000)
  }, 1000)

  return (
    <div>
      <h3>useDebounce Demo</h3>
      
      <div>
        <input
          value={searchTerm}
          onChange={e => setSearchTerm(e.target.value)}
          placeholder="Rechercher (debounced 500ms)..."
          style={{ width: '300px', padding: '8px' }}
        />
        
        <div style={{ marginTop: '10px' }}>
          <p>Terme actuel: "{searchTerm}"</p>
          <p>Terme debounced: "{debouncedSearchTerm}"</p>
          
          {isSearching && <p>üîç Recherche...</p>}
          
          {results.length > 0 && (
            <ul>
              {results.map((result, index) => (
                <li key={index}>{result}</li>
              ))}
            </ul>
          )}
        </div>
      </div>

      <div style={{ marginTop: '30px' }}>
        <h4>Auto-save avec debounce</h4>
        <textarea
          onChange={debouncedSave}
          placeholder="√âcris quelque chose... sauvegarde automatique apr√®s 1s"
          rows={4}
          style={{ width: '100%' }}
        />
        <p>{saveStatus}</p>
      </div>
    </div>
  )
}
```

### useInterval - Timer Contr√¥l√©

```jsx
function useInterval(callback, delay) {
  const savedCallback = useRef()

  // Se souvenir du callback le plus r√©cent
  useEffect(() => {
    savedCallback.current = callback
  }, [callback])

  // Configurer l'interval
  useEffect(() => {
    if (delay !== null) {
      const interval = setInterval(() => savedCallback.current(), delay)
      return () => clearInterval(interval)
    }
  }, [delay])
}

// Hook pour un timer avec pause/resume
function useTimer(initialTime = 0) {
  const [time, setTime] = useState(initialTime)
  const [isRunning, setIsRunning] = useState(false)

  useInterval(
    () => setTime(time => time + 1),
    isRunning ? 1000 : null
  )

  const start = useCallback(() => setIsRunning(true), [])
  const pause = useCallback(() => setIsRunning(false), [])
  const reset = useCallback(() => {
    setTime(initialTime)
    setIsRunning(false)
  }, [initialTime])

  const formatTime = useCallback((seconds) => {
    const mins = Math.floor(seconds / 60)
    const secs = seconds % 60
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
  }, [])

  return {
    time,
    formattedTime: formatTime(time),
    isRunning,
    start,
    pause,
    reset
  }
}

function TimerDemo() {
  const timer = useTimer(0)
  const countdown = useTimer(60) // D√©marre √† 60 secondes
  
  // Pour le countdown, on d√©cr√©mente
  useInterval(
    () => {
      if (countdown.time > 0) {
        countdown.setTime(t => t - 1)
      } else {
        countdown.pause()
        alert('‚è∞ Temps √©coul√© !')
      }
    },
    countdown.isRunning && countdown.time > 0 ? 1000 : null
  )

  const [notifications, setNotifications] = useState([])

  // Notification p√©riodique
  useInterval(() => {
    const newNotification = `Notification ${Date.now()}`
    setNotifications(prev => [...prev.slice(-4), newNotification])
  }, 10000) // Toutes les 10 secondes

  return (
    <div>
      <h3>useInterval & useTimer Demo</h3>
      
      <div style={{ display: 'flex', gap: '30px' }}>
        <div>
          <h4>Chronom√®tre</h4>
          <p style={{ fontSize: '24px', fontWeight: 'bold' }}>
            {timer.formattedTime}
          </p>
          <div>
            <button onClick={timer.start} disabled={timer.isRunning}>
              ‚ñ∂Ô∏è Start
            </button>
            <button onClick={timer.pause} disabled={!timer.isRunning}>
              ‚è∏Ô∏è Pause
            </button>
            <button onClick={timer.reset}>
              üîÑ Reset
            </button>
          </div>
        </div>

        <div>
          <h4>Countdown</h4>
          <p style={{ 
            fontSize: '24px', 
            fontWeight: 'bold',
            color: countdown.time < 10 ? 'red' : 'black'
          }}>
            {countdown.formattedTime}
          </p>
          <div>
            <button onClick={countdown.start} disabled={countdown.isRunning || countdown.time === 0}>
              ‚ñ∂Ô∏è Start
            </button>
            <button onClick={countdown.pause} disabled={!countdown.isRunning}>
              ‚è∏Ô∏è Pause
            </button>
            <button onClick={() => countdown.reset()}>
              üîÑ Reset (60s)
            </button>
          </div>
        </div>
      </div>

      <div style={{ marginTop: '30px' }}>
        <h4>Notifications P√©riodiques (toutes les 10s)</h4>
        <ul>
          {notifications.map((notification, index) => (
            <li key={index}>{notification}</li>
          ))}
        </ul>
      </div>
    </div>
  )
}
```

---

## Composition de Hooks

### Hook Complexe : useShoppingCart

```jsx
function useShoppingCart() {
  const [items, setItems] = useLocalStorage('cart-items', [])
  const [isOpen, setIsOpen] = useState(false)

  const addItem = useCallback((product) => {
    setItems(prev => {
      const existingItem = prev.find(item => item.id === product.id)
      
      if (existingItem) {
        return prev.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        )
      }
      
      return [...prev, { ...product, quantity: 1 }]
    })
  }, [setItems])

  const removeItem = useCallback((productId) => {
    setItems(prev => prev.filter(item => item.id !== productId))
  }, [setItems])

  const updateQuantity = useCallback((productId, quantity) => {
    if (quantity <= 0) {
      removeItem(productId)
      return
    }

    setItems(prev =>
      prev.map(item =>
        item.id === productId ? { ...item, quantity } : item
      )
    )
  }, [setItems, removeItem])

  const clearCart = useCallback(() => {
    setItems([])
  }, [setItems])

  // Computed values
  const total = useMemo(() => {
    return items.reduce((sum, item) => sum + (item.price * item.quantity), 0)
  }, [items])

  const itemCount = useMemo(() => {
    return items.reduce((sum, item) => sum + item.quantity, 0)
  }, [items])

  const isEmpty = items.length === 0

  return {
    items,
    isOpen,
    setIsOpen,
    addItem,
    removeItem,
    updateQuantity,
    clearCart,
    total,
    itemCount,
    isEmpty
  }
}

// Hook pour la gestion des produits
function useProducts() {
  const [products] = useState([
    { id: 1, name: 'MacBook Pro', price: 2499, image: 'üíª' },
    { id: 2, name: 'iPhone', price: 999, image: 'üì±' },
    { id: 3, name: 'AirPods', price: 199, image: 'üéß' },
    { id: 4, name: 'iPad', price: 599, image: 'üì±' },
    { id: 5, name: 'Apple Watch', price: 399, image: '‚åö' }
  ])

  const [filter, setFilter] = useState('')
  const [sortBy, setSortBy] = useState('name')

  const filteredProducts = useMemo(() => {
    let filtered = products
    
    if (filter) {
      filtered = filtered.filter(product =>
        product.name.toLowerCase().includes(filter.toLowerCase())
      )
    }

    return filtered.sort((a, b) => {
      switch (sortBy) {
        case 'name':
          return a.name.localeCompare(b.name)
        case 'price':
          return a.price - b.price
        case 'priceDesc':
          return b.price - a.price
        default:
          return 0
      }
    })
  }, [products, filter, sortBy])

  return {
    products,
    filteredProducts,
    filter,
    setFilter,
    sortBy,
    setSortBy
  }
}

// D√©monstration de la composition
function ECommerceDemo() {
  const cart = useShoppingCart()
  const { filteredProducts, filter, setFilter, sortBy, setSortBy } = useProducts()

  return (
    <div style={{ maxWidth: '1200px', margin: '0 auto', padding: '20px' }}>
      <header style={{ 
        display: 'flex', 
        justifyContent: 'space-between', 
        alignItems: 'center',
        marginBottom: '30px',
        borderBottom: '2px solid #eee',
        paddingBottom: '20px'
      }}>
        <h1>üõçÔ∏è E-Commerce Demo</h1>
        
        <button
          onClick={() => cart.setIsOpen(true)}
          style={{
            position: 'relative',
            padding: '10px 20px',
            backgroundColor: '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: '8px',
            cursor: 'pointer'
          }}
        >
          üõí Panier ({cart.itemCount})
          {cart.itemCount > 0 && (
            <span style={{
              position: 'absolute',
              top: '-8px',
              right: '-8px',
              backgroundColor: '#dc3545',
              color: 'white',
              borderRadius: '50%',
              width: '24px',
              height: '24px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: '12px'
            }}>
              {cart.itemCount}
            </span>
          )}
        </button>
      </header>

      <div style={{ marginBottom: '20px', display: 'flex', gap: '15px' }}>
        <input
          value={filter}
          onChange={e => setFilter(e.target.value)}
          placeholder="Rechercher des produits..."
          style={{ padding: '8px', flex: 1 }}
        />
        
        <select value={sortBy} onChange={e => setSortBy(e.target.value)}>
          <option value="name">Nom</option>
          <option value="price">Prix croissant</option>
          <option value="priceDesc">Prix d√©croissant</option>
        </select>
      </div>

      <div style={{ 
        display: 'grid', 
        gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))', 
        gap: '20px',
        marginBottom: '30px'
      }}>
        {filteredProducts.map(product => (
          <div key={product.id} style={{
            border: '1px solid #ddd',
            borderRadius: '8px',
            padding: '20px',
            textAlign: 'center',
            backgroundColor: 'white'
          }}>
            <div style={{ fontSize: '48px', marginBottom: '10px' }}>
              {product.image}
            </div>
            <h3>{product.name}</h3>
            <p style={{ fontSize: '20px', fontWeight: 'bold', color: '#007bff' }}>
              {product.price}‚Ç¨
            </p>
            <button
              onClick={() => cart.addItem(product)}
              style={{
                backgroundColor: '#28a745',
                color: 'white',
                border: 'none',
                padding: '10px 20px',
                borderRadius: '4px',
                cursor: 'pointer'
              }}
            >
              Ajouter au panier
            </button>
          </div>
        ))}
      </div>

      {/* Modal Panier */}
      {cart.isOpen && (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundColor: 'rgba(0,0,0,0.5)',
          display: 'flex',
          justifyContent: 'flex-end',
          zIndex: 1000
        }}>
          <div style={{
            width: '400px',
            backgroundColor: 'white',
            height: '100%',
            padding: '20px',
            overflowY: 'auto'
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '20px' }}>
              <h2>Panier</h2>
              <button onClick={() => cart.setIsOpen(false)}>‚ùå</button>
            </div>

            {cart.isEmpty ? (
              <p>Votre panier est vide</p>
            ) : (
              <>
                {cart.items.map(item => (
                  <div key={item.id} style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    padding: '10px 0',
                    borderBottom: '1px solid #eee'
                  }}>
                    <div>
                      <h4>{item.name}</h4>
                      <p>{item.price}‚Ç¨</p>
                    </div>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                      <button onClick={() => cart.updateQuantity(item.id, item.quantity - 1)}>
                        -
                      </button>
                      <span>{item.quantity}</span>
                      <button onClick={() => cart.updateQuantity(item.id, item.quantity + 1)}>
                        +
                      </button>
                      <button onClick={() => cart.removeItem(item.id)}>üóëÔ∏è</button>
                    </div>
                  </div>
                ))}

                <div style={{ marginTop: '20px', paddingTop: '20px', borderTop: '2px solid #eee' }}>
                  <h3>Total: {cart.total.toFixed(2)}‚Ç¨</h3>
                  <button style={{
                    width: '100%',
                    padding: '15px',
                    backgroundColor: '#007bff',
                    color: 'white',
                    border: 'none',
                    borderRadius: '8px',
                    marginBottom: '10px'
                  }}>
                    Commander
                  </button>
                  <button onClick={cart.clearCart} style={{
                    width: '100%',
                    padding: '10px',
                    backgroundColor: '#6c757d',
                    color: 'white',
                    border: 'none',
                    borderRadius: '8px'
                  }}>
                    Vider le panier
                  </button>
                </div>
              </>
            )}
          </div>
        </div>
      )}
    </div>
  )
}
```

---

## Points Cl√©s √† Retenir

1. **Custom Hooks** = fonctions qui commencent par "use"
2. **R√©utilisabilit√©** = extraire la logique commune
3. **Composition** = combiner plusieurs hooks simples
4. **R√®gles des hooks** = respecter les m√™mes r√®gles que les hooks natifs
5. **Naming** = noms explicites et descriptifs
6. **API design** = retourner objets ou arrays selon le cas
7. **Testing** = tester les hooks comme des fonctions pures

---

## Bonnes Pratiques

### Structure des Retours

```jsx
// ‚úÖ BON - Retourner un objet avec noms explicites
function useCounter(initial = 0) {
  const [count, setCount] = useState(initial)
  
  return {
    count,
    increment: () => setCount(c => c + 1),
    decrement: () => setCount(c => c - 1),
    reset: () => setCount(initial)
  }
}

// ‚úÖ BON - Retourner un array pour les cas simples (comme useState)
function useToggle(initial = false) {
  const [value, setValue] = useState(initial)
  
  return [value, () => setValue(v => !v)]
}

// ‚ùå √âVITER - M√©langer objets et arrays
function useConfusing() {
  return [{ data: 'something' }, () => {}] // Confus !
}
```

### Gestion des Erreurs

```jsx
function useApiWithError(url) {
  const [state, setState] = useState({
    data: null,
    loading: false,
    error: null
  })

  const fetchData = useCallback(async () => {
    setState(prev => ({ ...prev, loading: true, error: null }))

    try {
      const response = await fetch(url)
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      const data = await response.json()
      setState({ data, loading: false, error: null })
    } catch (error) {
      setState({ data: null, loading: false, error })
    }
  }, [url])

  useEffect(() => {
    fetchData()
  }, [fetchData])

  return { ...state, retry: fetchData }
}
```

---

## Ressources Pour Aller Plus Loin

- üìö [Building Your Own Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)
- üéØ [Custom Hook Patterns](https://usehooks.com/)
- üí° [useHooks.ts](https://usehooks-ts.com/)
- üîÑ [React Hook Libraries](https://github.com/rehooks/awesome-react-hooks)

