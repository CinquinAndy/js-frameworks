# React - useMemo : Optimisation des Calculs

Quand ton composant fait des calculs co√ªteux √† chaque rendu, useMemo va **m√©moriser** le r√©sultat et ne le recalculer que si les d√©pendances changent.

---

## Le Probl√®me des Recalculs Inutiles

### Calculs Co√ªteux √† Chaque Rendu

```jsx
function SlowComponent({ items, filter }) {
  const [count, setCount] = useState(0)

  // ‚ùå PROBL√àME - Calcul co√ªteux √† CHAQUE rendu !
  const expensiveValue = items
    .filter(item => item.category === filter)
    .reduce((sum, item) => sum + item.price, 0)
  
  console.log('üí∞ Calcul co√ªteux ex√©cut√© !') // ‚Üê Se d√©clenche m√™me quand count change !

  // ‚ùå PROBL√àME - Nouvel objet √† chaque rendu !
  const chartConfig = {
    type: 'bar',
    data: expensiveValue,
    options: { responsive: true }
  }

  // ‚ùå PROBL√àME - Tableau recalcul√© √† chaque rendu !
  const sortedItems = items
    .filter(item => item.category === filter)
    .sort((a, b) => b.price - a.price)

  return (
    <div>
      <h3>Total: {expensiveValue}‚Ç¨</h3>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
      
      <ExpensiveChart config={chartConfig} />
      <ItemsList items={sortedItems} />
    </div>
  )
}

// Ces composants re-render m√™me si leurs props n'ont pas vraiment chang√© !
const ExpensiveChart = memo(function ExpensiveChart({ config }) {
  console.log('üìä ExpensiveChart re-rendu') // ‚Üê Toujours appel√© car config est toujours un nouvel objet !
  return <div>Chart avec config: {JSON.stringify(config)}</div>
})

const ItemsList = memo(function ItemsList({ items }) {
  console.log('üìù ItemsList re-rendu') // ‚Üê Toujours appel√© car items est toujours un nouveau tableau !
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.name} - {item.price}‚Ç¨</li>
      ))}
    </ul>
  )
})
```

---

## useMemo √† la Rescousse

### Syntaxe et Usage Basique

```jsx
import { useMemo } from 'react'

function OptimizedComponent({ items, filter }) {
  const [count, setCount] = useState(0)

  // ‚úÖ SOLUTION - Calcul seulement si items ou filter changent
  const expensiveValue = useMemo(() => {
    console.log('üí∞ Calcul co√ªteux ex√©cut√©') // ‚Üê Seulement si n√©cessaire !
    
    return items
      .filter(item => item.category === filter)
      .reduce((sum, item) => sum + item.price, 0)
  }, [items, filter]) // ‚Üê D√©pendances

  // ‚úÖ Objet complexe m√©moris√©
  const chartConfig = useMemo(() => {
    console.log('üìä Configuration chart g√©n√©r√©e')
    
    return {
      type: 'bar',
      data: expensiveValue,
      options: { responsive: true },
      theme: 'modern'
    }
  }, [expensiveValue])

  // ‚úÖ Donn√©es filtr√©es et tri√©es m√©moris√©es
  const sortedItems = useMemo(() => {
    console.log('üîç Filtrage et tri des items')
    
    return items
      .filter(item => item.category === filter)
      .sort((a, b) => b.price - a.price) // Tri par prix d√©croissant
  }, [items, filter])

  return (
    <div>
      <h3>Total: {expensiveValue}‚Ç¨</h3>
      <p>Count: {count} (ne d√©clenche plus le calcul !)</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
      
      <ExpensiveChart config={chartConfig} />
      <ItemsList items={sortedItems} />
    </div>
  )
}

// Maintenant ces composants ne re-render que si leurs props changent vraiment !
const ExpensiveChart = memo(function ExpensiveChart({ config }) {
  console.log('üìä ExpensiveChart re-rendu') // ‚Üê Seulement si config change vraiment
  return <div>Chart avec config: {JSON.stringify(config)}</div>
})

const ItemsList = memo(function ItemsList({ items }) {
  console.log('üìù ItemsList re-rendu') // ‚Üê Seulement si items change vraiment
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.name} - {item.price}‚Ç¨</li>
      ))}
    </ul>
  )
})
```

### R√®gle d'Or de useMemo

```jsx
// ‚úÖ UTILISE useMemo pour :
// 1. Calculs co√ªteux (boucles, maths complexes)
// 2. Objets/arrays pass√©s √† des composants memo()
// 3. Transformations de donn√©es lourdes

// ‚ùå N'utilise PAS useMemo pour :
// 1. Calculs simples (addition, multiplication)
// 2. Valeurs primitives
// 3. Objets qui ne sont pas pass√©s en props
```

---

## Exemples Pratiques

### Gestion d'Utilisateurs Optimis√©e

```jsx
function UserManager() {
  const [users, setUsers] = useState([
    { id: 1, name: 'Andy', age: 25, department: 'IT', salary: 50000 },
    { id: 2, name: 'Marie', age: 30, department: 'HR', salary: 45000 },
    { id: 3, name: 'Paul', age: 35, department: 'IT', salary: 60000 },
    { id: 4, name: 'Sophie', age: 28, department: 'Marketing', salary: 48000 }
  ])
  const [searchTerm, setSearchTerm] = useState('')
  const [department, setDepartment] = useState('all')
  const [sortBy, setSortBy] = useState('name')

  // ‚úÖ Filtrage m√©moris√© - ne se recalcule que si les crit√®res changent
  const filteredUsers = useMemo(() => {
    console.log('üîç Filtrage users')
    
    return users.filter(user => {
      const matchesSearch = user.name.toLowerCase().includes(searchTerm.toLowerCase())
      const matchesDepartment = department === 'all' || user.department === department
      return matchesSearch && matchesDepartment
    })
  }, [users, searchTerm, department])

  // ‚úÖ Tri m√©moris√© - ne se recalcule que si les donn√©es ou le tri changent
  const sortedUsers = useMemo(() => {
    console.log('üìä Tri users')
    
    return [...filteredUsers].sort((a, b) => {
      switch (sortBy) {
        case 'name':
          return a.name.localeCompare(b.name)
        case 'age':
          return a.age - b.age
        case 'salary':
          return b.salary - a.salary // D√©croissant
        default:
          return 0
      }
    })
  }, [filteredUsers, sortBy])

  // ‚úÖ Statistiques m√©moris√©es - calcul co√ªteux uniquement si n√©cessaire
  const stats = useMemo(() => {
    console.log('üìà Calcul statistiques')
    
    if (sortedUsers.length === 0) {
      return { total: 0, avgAge: 0, avgSalary: 0, departments: [] }
    }

    const totalSalary = sortedUsers.reduce((sum, user) => sum + user.salary, 0)
    const totalAge = sortedUsers.reduce((sum, user) => sum + user.age, 0)
    const departments = [...new Set(sortedUsers.map(user => user.department))]

    return {
      total: sortedUsers.length,
      avgAge: Math.round(totalAge / sortedUsers.length),
      avgSalary: Math.round(totalSalary / sortedUsers.length),
      departments: departments
    }
  }, [sortedUsers])

  // ‚úÖ Liste des d√©partements m√©moris√©e - ne change que si users change
  const availableDepartments = useMemo(() => {
    return [...new Set(users.map(user => user.department))]
  }, [users])

  return (
    <div>
      <h3>Gestion Utilisateurs Optimis√©e</h3>
      
      {/* Contr√¥les */}
      <div style={{ marginBottom: '20px' }}>
        <input
          value={searchTerm}
          onChange={e => setSearchTerm(e.target.value)}
          placeholder="Rechercher par nom..."
          style={{ marginRight: '10px', padding: '5px' }}
        />
        
        <select
          value={department}
          onChange={e => setDepartment(e.target.value)}
          style={{ marginRight: '10px', padding: '5px' }}
        >
          <option value="all">Tous les d√©partements</option>
          {availableDepartments.map(dept => (
            <option key={dept} value={dept}>{dept}</option>
          ))}
        </select>
        
        <select
          value={sortBy}
          onChange={e => setSortBy(e.target.value)}
          style={{ padding: '5px' }}
        >
          <option value="name">Trier par nom</option>
          <option value="age">Trier par √¢ge</option>
          <option value="salary">Trier par salaire</option>
        </select>
      </div>

      {/* Statistiques */}
      <StatsDisplay stats={stats} />

      {/* Liste */}
      <UsersList users={sortedUsers} />
    </div>
  )
}

const StatsDisplay = memo(function StatsDisplay({ stats }) {
  console.log('üìä StatsDisplay re-rendu')
  
  return (
    <div style={{ background: '#f8f9fa', padding: '15px', marginBottom: '20px' }}>
      <h4>Statistiques</h4>
      <p>Total: {stats.total} utilisateurs</p>
      <p>√Çge moyen: {stats.avgAge} ans</p>
      <p>Salaire moyen: {stats.avgSalary.toLocaleString()}‚Ç¨</p>
      <p>D√©partements: {stats.departments.join(', ')}</p>
    </div>
  )
})

const UsersList = memo(function UsersList({ users }) {
  console.log('üë• UsersList re-rendu')
  
  return (
    <div>
      <h4>Utilisateurs ({users.length})</h4>
      <ul>
        {users.map(user => (
          <li key={user.id} style={{ marginBottom: '5px' }}>
            <strong>{user.name}</strong> ({user.age} ans) - {user.department} - {user.salary.toLocaleString()}‚Ç¨
          </li>
        ))}
      </ul>
    </div>
  )
})
```

### Dashboard avec M√©triques Complexes

```jsx
function AnalyticsDashboard({ data }) {
  const [timeRange, setTimeRange] = useState('7d')
  const [metric, setMetric] = useState('revenue')

  // ‚úÖ Donn√©es filtr√©es par p√©riode
  const filteredData = useMemo(() => {
    console.log('üìÖ Filtrage par p√©riode:', timeRange)
    
    const now = new Date()
    const days = timeRange === '7d' ? 7 : timeRange === '30d' ? 30 : 90
    const cutoff = new Date(now.getTime() - days * 24 * 60 * 60 * 1000)
    
    return data.filter(item => new Date(item.date) >= cutoff)
  }, [data, timeRange])

  // ‚úÖ Calculs de m√©triques co√ªteuses
  const metrics = useMemo(() => {
    console.log('üî¢ Calcul m√©triques pour:', metric)
    
    if (filteredData.length === 0) {
      return { total: 0, average: 0, growth: 0, trend: [] }
    }

    const values = filteredData.map(item => item[metric])
    const total = values.reduce((sum, val) => sum + val, 0)
    const average = total / values.length
    
    // Calcul de la croissance (comparaison premi√®re vs derni√®re moiti√©)
    const midPoint = Math.floor(values.length / 2)
    const firstHalf = values.slice(0, midPoint).reduce((sum, val) => sum + val, 0) / midPoint
    const secondHalf = values.slice(midPoint).reduce((sum, val) => sum + val, 0) / (values.length - midPoint)
    const growth = firstHalf > 0 ? ((secondHalf - firstHalf) / firstHalf) * 100 : 0
    
    // Calcul de la tendance (moyennes mobiles)
    const trend = []
    const windowSize = 3
    for (let i = windowSize - 1; i < values.length; i++) {
      const window = values.slice(i - windowSize + 1, i + 1)
      const avg = window.reduce((sum, val) => sum + val, 0) / windowSize
      trend.push(avg)
    }

    return { total, average, growth, trend }
  }, [filteredData, metric])

  // ‚úÖ Configuration du graphique m√©moris√©e
  const chartConfig = useMemo(() => {
    console.log('üìà Configuration graphique')
    
    return {
      data: {
        labels: filteredData.map(item => item.date),
        datasets: [{
          label: metric,
          data: filteredData.map(item => item[metric]),
          borderColor: '#007bff',
          backgroundColor: 'rgba(0, 123, 255, 0.1)'
        }, {
          label: 'Tendance',
          data: metrics.trend,
          borderColor: '#28a745',
          borderDash: [5, 5]
        }]
      },
      options: {
        responsive: true,
        animation: { duration: 500 },
        scales: {
          y: { beginAtZero: true }
        }
      }
    }
  }, [filteredData, metric, metrics.trend])

  // ‚úÖ Insights automatiques
  const insights = useMemo(() => {
    console.log('üí° G√©n√©ration insights')
    
    const insights = []
    
    if (metrics.growth > 10) {
      insights.push({ type: 'positive', text: `Excellente croissance de ${metrics.growth.toFixed(1)}%` })
    } else if (metrics.growth < -10) {
      insights.push({ type: 'negative', text: `Baisse pr√©occupante de ${Math.abs(metrics.growth).toFixed(1)}%` })
    }
    
    if (metrics.average > 1000) {
      insights.push({ type: 'info', text: `Moyenne √©lev√©e de ${metrics.average.toFixed(0)}` })
    }
    
    const lastTrend = metrics.trend.slice(-3)
    if (lastTrend.length >= 3 && lastTrend[2] > lastTrend[1] && lastTrend[1] > lastTrend[0]) {
      insights.push({ type: 'positive', text: 'Tendance √† la hausse r√©cente' })
    }

    return insights
  }, [metrics])

  return (
    <div>
      <h3>Analytics Dashboard</h3>
      
      <div style={{ display: 'flex', gap: '10px', marginBottom: '20px' }}>
        <select value={timeRange} onChange={e => setTimeRange(e.target.value)}>
          <option value="7d">7 derniers jours</option>
          <option value="30d">30 derniers jours</option>
          <option value="90d">90 derniers jours</option>
        </select>
        
        <select value={metric} onChange={e => setMetric(e.target.value)}>
          <option value="revenue">Revenus</option>
          <option value="users">Utilisateurs</option>
          <option value="orders">Commandes</option>
        </select>
      </div>

      <MetricsCard metrics={metrics} metric={metric} />
      <ChartComponent config={chartConfig} />
      <InsightsList insights={insights} />
    </div>
  )
}

const MetricsCard = memo(function MetricsCard({ metrics, metric }) {
  return (
    <div style={{ 
      display: 'grid', 
      gridTemplateColumns: 'repeat(3, 1fr)', 
      gap: '15px', 
      marginBottom: '20px' 
    }}>
      <div style={{ padding: '15px', background: '#f8f9fa', borderRadius: '8px' }}>
        <h4>Total</h4>
        <p style={{ fontSize: '24px', fontWeight: 'bold' }}>
          {metrics.total.toLocaleString()}
        </p>
      </div>
      <div style={{ padding: '15px', background: '#f8f9fa', borderRadius: '8px' }}>
        <h4>Moyenne</h4>
        <p style={{ fontSize: '24px', fontWeight: 'bold' }}>
          {metrics.average.toFixed(1)}
        </p>
      </div>
      <div style={{ padding: '15px', background: '#f8f9fa', borderRadius: '8px' }}>
        <h4>Croissance</h4>
        <p style={{ 
          fontSize: '24px', 
          fontWeight: 'bold',
          color: metrics.growth >= 0 ? 'green' : 'red'
        }}>
          {metrics.growth > 0 ? '+' : ''}{metrics.growth.toFixed(1)}%
        </p>
      </div>
    </div>
  )
})

const ChartComponent = memo(function ChartComponent({ config }) {
  console.log('üìä ChartComponent re-rendu')
  
  return (
    <div style={{ 
      border: '1px solid #ddd', 
      padding: '20px', 
      marginBottom: '20px',
      background: 'white'
    }}>
      <h4>Graphique</h4>
      <div style={{ height: '200px', background: '#f8f9fa', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
        Chart avec {config.data.datasets.length} datasets
      </div>
    </div>
  )
})

const InsightsList = memo(function InsightsList({ insights }) {
  return (
    <div>
      <h4>Insights</h4>
      <ul>
        {insights.map((insight, index) => (
          <li key={index} style={{
            padding: '10px',
            marginBottom: '5px',
            borderRadius: '4px',
            backgroundColor: 
              insight.type === 'positive' ? '#d4edda' :
              insight.type === 'negative' ? '#f8d7da' : '#d1ecf1'
          }}>
            {insight.text}
          </li>
        ))}
      </ul>
    </div>
  )
})
```

---

## Patterns Avanc√©s

### M√©morisation Conditionnelle

```jsx
function ConditionalMemoization({ items, mode }) {
  const [isExpensiveMode, setIsExpensiveMode] = useState(true)

  // ‚úÖ M√©morisation seulement si n√©cessaire
  const processedItems = useMemo(() => {
    if (!isExpensiveMode) {
      // Calcul simple, pas besoin de m√©morisation
      return items.map(item => ({ ...item, processed: true }))
    }

    console.log('üí∞ Calcul co√ªteux avec m√©morisation')
    
    // Simulation d'un calcul tr√®s co√ªteux
    return items.map(item => ({
      ...item,
      processed: true,
      score: calculateComplexScore(item), // Fonction co√ªteuse
      category: determineCategory(item),   // Autre fonction co√ªteuse
      metrics: generateMetrics(item)       // Encore une fonction co√ªteuse
    }))
  }, isExpensiveMode ? [items] : null) // ‚Üê D√©pendances conditionnelles

  return (
    <div>
      <h3>M√©morisation Conditionnelle</h3>
      
      <label>
        <input
          type="checkbox"
          checked={isExpensiveMode}
          onChange={e => setIsExpensiveMode(e.target.checked)}
        />
        Mode calcul co√ªteux
      </label>

      <div style={{ marginTop: '20px' }}>
        <p>√âl√©ments trait√©s: {processedItems.length}</p>
        <p>Mode: {isExpensiveMode ? 'Co√ªteux (avec memo)' : 'Simple (sans memo)'}</p>
      </div>

      <ul>
        {processedItems.slice(0, 10).map(item => (
          <li key={item.id}>
            {item.name} - Score: {item.score?.toFixed(2) || 'N/A'}
          </li>
        ))}
      </ul>
    </div>
  )
}

// Fonctions co√ªteuses fictives
function calculateComplexScore(item) {
  let score = 0
  for (let i = 0; i < 10000; i++) {
    score += Math.sqrt(item.value * i)
  }
  return score
}

function determineCategory(item) {
  // Simulation de logique complexe
  const factors = [item.value, item.popularity, item.rating]
  return factors.reduce((acc, val) => acc + val, 0) > 50 ? 'premium' : 'standard'
}

function generateMetrics(item) {
  // Plus de calculs co√ªteux
  return {
    efficiency: item.value / Math.max(item.cost, 1),
    popularity: Math.log(item.views + 1),
    trend: Array.from({length: 7}, () => Math.random()).reduce((a, b) => a + b) / 7
  }
}
```

### useMemo pour les Objets de Configuration

```jsx
function ConfigurationMemo({ settings, theme, locale }) {
  // ‚úÖ Configuration API m√©moris√©e
  const apiConfig = useMemo(() => {
    console.log('üîß Configuration API')
    
    return {
      baseURL: process.env.REACT_APP_API_URL,
      timeout: settings.timeout || 5000,
      headers: {
        'Content-Type': 'application/json',
        'Accept-Language': locale,
        'X-Theme': theme,
        'Authorization': `Bearer ${settings.token}`
      },
      retries: settings.retries || 3,
      interceptors: {
        request: (config) => {
          console.log('API Request:', config)
          return config
        },
        response: (response) => {
          console.log('API Response:', response)
          return response
        }
      }
    }
  }, [settings.timeout, settings.token, settings.retries, theme, locale])

  // ‚úÖ Configuration de style m√©moris√©e
  const styleConfig = useMemo(() => {
    console.log('üé® Configuration styles')
    
    const baseStyles = {
      colors: {
        primary: theme === 'dark' ? '#007bff' : '#0056b3',
        secondary: theme === 'dark' ? '#6c757d' : '#545b62',
        background: theme === 'dark' ? '#343a40' : '#ffffff',
        text: theme === 'dark' ? '#ffffff' : '#212529'
      },
      spacing: {
        xs: '4px',
        sm: '8px',
        md: '16px',
        lg: '24px',
        xl: '32px'
      }
    }

    return {
      ...baseStyles,
      computed: {
        containerStyle: {
          backgroundColor: baseStyles.colors.background,
          color: baseStyles.colors.text,
          padding: baseStyles.spacing.lg
        },
        buttonStyle: {
          backgroundColor: baseStyles.colors.primary,
          color: baseStyles.colors.background,
          padding: `${baseStyles.spacing.sm} ${baseStyles.spacing.md}`,
          borderRadius: '4px',
          border: 'none'
        }
      }
    }
  }, [theme])

  // ‚úÖ Configuration de forme m√©moris√©e
  const formConfig = useMemo(() => {
    console.log('üìù Configuration formulaire')
    
    return {
      validation: {
        email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
        phone: locale === 'fr' ? /^[0-9]{10}$/ : /^[0-9]{3}-[0-9]{3}-[0-9]{4}$/,
        required: (value) => value && value.trim().length > 0
      },
      formatting: {
        currency: new Intl.NumberFormat(locale, { 
          style: 'currency', 
          currency: locale === 'fr' ? 'EUR' : 'USD' 
        }),
        date: new Intl.DateTimeFormat(locale, {
          year: 'numeric',
          month: 'long', 
          day: 'numeric'
        })
      },
      placeholders: {
        email: locale === 'fr' ? 'votre@email.fr' : 'your@email.com',
        phone: locale === 'fr' ? '0123456789' : '123-456-7890'
      }
    }
  }, [locale])

  return (
    <div style={styleConfig.computed.containerStyle}>
      <h3>Configuration Memo</h3>
      
      <div style={{ marginBottom: '20px' }}>
        <p>Th√®me: {theme}</p>
        <p>Locale: {locale}</p>
        <p>API Base: {apiConfig.baseURL}</p>
        <p>Timeout: {apiConfig.timeout}ms</p>
      </div>

      <div style={{ display: 'flex', gap: '10px' }}>
        <button style={styleConfig.computed.buttonStyle}>
          Bouton styl√©
        </button>
      </div>

      <div style={{ marginTop: '20px' }}>
        <p>Format mon√©taire: {formConfig.formatting.currency.format(123.45)}</p>
        <p>Format date: {formConfig.formatting.date.format(new Date())}</p>
        <p>Placeholder email: {formConfig.placeholders.email}</p>
      </div>
    </div>
  )
}
```

---

## Bonnes Pratiques

### Quand Utiliser useMemo

```jsx
function BestPracticesUseMemo() {
  const [items, setItems] = useState([])
  const [filter, setFilter] = useState('')

  // ‚úÖ BON - Calcul vraiment co√ªteux
  const expensiveCalculation = useMemo(() => {
    // Simulation d'un calcul complexe
    let result = 0
    for (let i = 0; i < 100000; i++) {
      result += Math.sqrt(i) * Math.random()
    }
    return result
  }, []) // Une seule fois

  // ‚ùå MAUVAIS - Calculs simples (overhead inutile)
  const badMemo1 = useMemo(() => items.length, [items])
  const badMemo2 = useMemo(() => filter.toLowerCase(), [filter])
  
  // ‚úÖ BON - Calculs directs pour les op√©rations simples
  const goodDirect1 = items.length
  const goodDirect2 = filter.toLowerCase()

  // ‚úÖ BON - Objets/Arrays complexes pour composants memo
  const chartData = useMemo(() => ({
    labels: items.map(item => item.name),
    datasets: [{
      data: items.map(item => item.value),
      backgroundColor: items.map(() => `hsl(${Math.random() * 360}, 70%, 50%)`)
    }]
  }), [items])

  // ‚úÖ BON - Transformations co√ªteuses
  const processedItems = useMemo(() => {
    return items
      .filter(item => item.name.includes(filter))
      .map(item => ({
        ...item,
        processedValue: item.value * Math.random(), // Calcul par item
        category: item.value > 50 ? 'high' : 'low'
      }))
      .sort((a, b) => b.processedValue - a.processedValue)
  }, [items, filter])

  return (
    <div>
      <h3>Bonnes Pratiques useMemo</h3>
      
      <p>Items count: {goodDirect1} (direct)</p>
      <p>Filter: {goodDirect2} (direct)</p>
      <p>Expensive: {expensiveCalculation.toFixed(2)} (m√©moris√©)</p>
      <p>Processed items: {processedItems.length} (m√©moris√©)</p>
      
      <ComplexChart data={chartData} />
    </div>
  )
}

const ComplexChart = memo(function ComplexChart({ data }) {
  console.log('üìä ComplexChart re-rendu')
  
  return (
    <div style={{ border: '1px solid #ccc', padding: '20px' }}>
      <h4>Chart Complex</h4>
      <p>Datasets: {data.datasets.length}</p>
      <p>Labels: {data.labels.length}</p>
    </div>
  )
})
```

### √âviter les D√©pendances Instables

```jsx
function StableDependencies() {
  const [user, setUser] = useState({ name: 'Andy', age: 25, settings: { theme: 'light' } })
  const [posts, setPosts] = useState([])

  // ‚ùå MAUVAIS - Objet entier dans les d√©pendances
  const badMemo = useMemo(() => {
    return `${user.name} a ${posts.length} posts`
  }, [user, posts]) // ‚Üê user et posts changent √† chaque setState !

  // ‚úÖ BON - Propri√©t√©s sp√©cifiques dans les d√©pendances
  const goodMemo = useMemo(() => {
    return `${user.name} a ${posts.length} posts`
  }, [user.name, posts.length]) // ‚Üê Seulement les valeurs utilis√©es

  // ‚ùå MAUVAIS - Array/Object inline dans les d√©pendances
  const badMemoWithInline = useMemo(() => {
    const config = { theme: user.settings.theme, sort: 'date' } // ‚Üê Nouvel objet !
    return posts.filter(post => post.theme === config.theme)
  }, [posts, { theme: user.settings.theme, sort: 'date' }]) // ‚ùå Objet toujours diff√©rent !

  // ‚úÖ BON - Valeurs primitives ou objets m√©moris√©s
  const config = useMemo(() => ({
    theme: user.settings.theme,
    sort: 'date'
  }), [user.settings.theme])

  const goodMemoWithConfig = useMemo(() => {
    return posts.filter(post => post.theme === config.theme)
  }, [posts, config]) // ‚Üê config stable gr√¢ce √† son propre useMemo

  // ‚úÖ ENCORE MIEUX - Directement les valeurs primitives
  const bestMemo = useMemo(() => {
    return posts.filter(post => post.theme === user.settings.theme)
  }, [posts, user.settings.theme]) // ‚Üê Valeur primitive stable

  return (
    <div>
      <h3>D√©pendances Stables</h3>
      <p>Bad memo: {badMemo}</p>
      <p>Good memo: {goodMemo}</p>
      <p>Best memo: {bestMemo.length} posts filtr√©s</p>
    </div>
  )
}
```

---

## Erreurs Communes

### 1. M√©moriser des Calculs Simples

```jsx
// ‚ùå MAUVAIS - Overhead inutile pour des calculs simples
const count = 42
const badMemo = useMemo(() => count * 2, [count])
const anotherBadMemo = useMemo(() => `Hello ${name}`, [name])

// ‚úÖ BON - Calculs directs pour les op√©rations simples
const goodCalc = count * 2
const goodString = `Hello ${name}`
```

### 2. D√©pendances Manquantes

```jsx
// ‚ùå MAUVAIS - filter utilis√© mais pas dans les d√©pendances
const filteredItems = useMemo(() => {
  return items.filter(item => item.name.includes(filter))
}, [items]) // ‚ùå filter manquant !

// ‚úÖ BON - Toutes les d√©pendances
const filteredItems = useMemo(() => {
  return items.filter(item => item.name.includes(filter))
}, [items, filter])
```

### 3. D√©pendances Toujours Diff√©rentes

```jsx
// ‚ùå MAUVAIS - options recr√©√© √† chaque rendu
const MyComponent = ({ items }) => {
  const options = { sort: 'name', filter: true } // ‚Üê Nouvel objet !
  
  const processedItems = useMemo(() => {
    return processItems(items, options)
  }, [items, options]) // ‚Üê options change toujours !
}

// ‚úÖ BON - options stable
const MyComponent = ({ items }) => {
  const options = useMemo(() => ({
    sort: 'name', 
    filter: true
  }), [])
  
  const processedItems = useMemo(() => {
    return processItems(items, options)
  }, [items, options]) // ‚Üê options stable maintenant !
}
```

---

## Points Cl√©s √† Retenir

1. **useMemo** = √©vite les recalculs inutiles
2. **Calculs co√ªteux** = boucles, transformations lourdes, maths complexes
3. **Objets/Arrays** = m√©moriser si pass√©s √† des composants memo()
4. **D√©pendances** = inclure toutes les valeurs utilis√©es
5. **Primitives** = pr√©f√©rer aux objets dans les d√©pendances
6. **Mesurer** = profiler avant d'optimiser
7. **Pas d'abus** = ne pas m√©moriser les calculs simples

---

## Ressources Pour Aller Plus Loin

- üìö [useMemo Documentation](https://react.dev/reference/react/useMemo)
- üí° [When to useMemo](https://kentcdodds.com/blog/usememo-and-usecallback)
- ‚ö° [React Performance](https://react.dev/learn/render-and-commit)
- üîß [React DevTools Profiler](https://react.dev/blog/2018/09/10/introducing-the-react-profiler)

---

**Prochaine √©tape :** La m√©morisation de fonctions avec `useCallback` dans `15.0.4.4-useCallback.md` ! üéØ

---

```jsx
import { useMemo } from 'react';

function TodoList({ todos, tab }) {
  const visibleTodos = useMemo(
    () => filterTodos(todos, tab),
    [todos, tab]
  );
  // ...
}
```
