# React - Rendu et Virtual DOM

Maintenant qu'on maÃ®trise les composants fonctionnels, on va comprendre **comment React fonctionne sous le capot** !

React suit une approche **dÃ©clarative** pour le rendu des composants, ce qui signifie que tu spÃ©cifies **ce Ã  quoi** un composant doit ressembler, et React s'occupe de l'afficher Ã  l'Ã©cran. C'est l'opposÃ© d'une approche **impÃ©rative**, oÃ¹ tu Ã©crirais du code pour manipuler manuellement le DOM.

---

## Le Processus de Rendu React

### Les 3 Ã©tapes fondamentales

React fonctionne comme un **serveur dans un restaurant** :

1. **ğŸ¯ Trigger (DÃ©clenchement)** - Le client passe commande
2. **ğŸ”„ Render (Rendu)** - Le chef prÃ©pare le plat
3. **ğŸ“¦ Commit (Validation)** - Le serveur apporte le plat

```jsx
function ExempleRendu() {
  const [count, setCount] = useState(0)

  console.log('ğŸ”„ RENDER: Composant en cours de rendu')

  const handleClick = () => {
    console.log('ğŸ¯ TRIGGER: Changement d\'Ã©tat dÃ©clenchÃ©')
    setCount(count + 1) // â† DÃ©clenche un nouveau rendu
  }

  return (
    <div>
      <p>Compteur: {count}</p>
      <button onClick={handleClick}>+1</button>
    </div>
  )
}
```

### 1. Trigger - Quand React dÃ©cide de faire un rendu

React fait un rendu dans **2 cas seulement** :

```jsx
function QuandReactRend() {
  const [state, setState] = useState(0)

  // âœ… CAS 1: Rendu initial (premiÃ¨re fois)
  useEffect(() => {
    console.log('ğŸ¬ Premier rendu du composant')
  }, [])

  // âœ… CAS 2: Changement d'Ã©tat
  const triggerReRender = () => {
    setState(state + 1) // â† DÃ©clenche un re-rendu
  }

  return (
    <div>
      <p>State: {state}</p>
      <button onClick={triggerReRender}>Changer Ã©tat</button>
    </div>
  )
}
```

### 2. Render - React appelle tes composants

```jsx
function ExempleRenderPur() {
  const [count, setCount] = useState(0)

  // âš ï¸ Cette fonction DOIT Ãªtre pure !
  // MÃªmes inputs = mÃªmes outputs
  console.log('ğŸ”„ Render appelÃ© avec count =', count)

  return <div>Count: {count}</div>
}

// âŒ MAUVAIS - Effet de bord pendant le render
function BadExample() {
  const [count, setCount] = useState(0)

  // âŒ Ne jamais faire Ã§a dans le render !
  document.title = `Count: ${count}` // Effet de bord
  Math.random() // Non-dÃ©terministe

  return <div>{count}</div>
}

// âœ… BON - Render pur
function GoodExample() {
  const [count, setCount] = useState(0)

  // âœ… Effets de bord dans useEffect
  useEffect(() => {
    document.title = `Count: ${count}`
  }, [count])

  return <div>{count}</div>
}
```

### 3. Commit - React met Ã  jour le DOM

```jsx
function ExempleCommit() {
  const [color, setColor] = useState('red')

  return (
    <div>
      {/* React ne mettra Ã  jour QUE la couleur dans le DOM */}
      <div style={{ backgroundColor: color, padding: '20px' }}>
        <h2>Titre inchangÃ©</h2>
        <p>Paragraphe inchangÃ©</p>
        <button onClick={() => setColor(color === 'red' ? 'blue' : 'red')}>
          Changer couleur
        </button>
      </div>
    </div>
  )
}
```

---

## Virtual DOM - La Magie de React

### Qu'est-ce que le Virtual DOM ?

Le **Virtual DOM (VDOM)** est une reprÃ©sentation **en mÃ©moire** du DOM rÃ©el. C'est comme un **brouillon** que React utilise pour optimiser les mises Ã  jour.

```jsx
// Ce que tu Ã©cris en JSX
function MonComposant() {
  return (
    <div className="container">
      <h1>Titre</h1>
      <p>Paragraphe</p>
    </div>
  )
}

// Ce que React crÃ©e en Virtual DOM (simplifiÃ©)
const virtualDOM = {
  type: 'div',
  props: { className: 'container' },
  children: [
    { type: 'h1', props: {}, children: ['Titre'] },
    { type: 'p', props: {}, children: ['Paragraphe'] }
  ]
}
```

### Le Processus de RÃ©conciliation

```jsx
function ExempleReconciliation() {
  const [items, setItems] = useState(['A', 'B', 'C'])

  const ajouterItem = () => {
    setItems([...items, `Item ${Date.now()}`])
  }

  return (
    <div>
      <h2>Liste d'items</h2>
      {/*
        React compare :
        - AVANT: ['A', 'B', 'C']
        - APRÃˆS: ['A', 'B', 'C', 'Item 12345']

        RÃ©sultat: React ajoute SEULEMENT le nouvel Ã©lÃ©ment au DOM
      */}
      <ul>
        {items.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
      <button onClick={ajouterItem}>Ajouter item</button>
    </div>
  )
}
```

### Pourquoi c'est important ?

```jsx
// Sans Virtual DOM (manipulation directe)
function updateWithoutVDOM() {
  // âŒ Lent et inefficace
  document.getElementById('title').textContent = 'Nouveau titre'
  document.getElementById('count').textContent = '42'
  document.getElementById('status').className = 'active'
  // ... 50 autres mises Ã  jour
}

// Avec Virtual DOM (React)
function updateWithVDOM() {
  // âœ… React calcule automatiquement les changements minimaux
  setTitle('Nouveau titre')
  setCount(42)
  setStatus('active')
  // React met Ã  jour SEULEMENT ce qui a changÃ©
}
```

### DÃ©monstration pratique

```jsx
function DemoVirtualDOM() {
  const [highlightIndex, setHighlightIndex] = useState(0)

  useEffect(() => {
    const interval = setInterval(() => {
      setHighlightIndex(prev => (prev + 1) % 5)
    }, 1000)

    return () => clearInterval(interval)
  }, [])

  return (
    <div>
      <h3>React met Ã  jour SEULEMENT l'Ã©lÃ©ment surlignÃ©</h3>
      <ul>
        {['Item 1', 'Item 2', 'Item 3', 'Item 4', 'Item 5'].map((item, index) => (
          <li
            key={index}
            style={{
              backgroundColor: index === highlightIndex ? 'yellow' : 'transparent',
              padding: '10px',
              transition: 'background-color 0.3s'
            }}
          >
            {item}
          </li>
        ))}
      </ul>
      <p>ğŸ‘† Ouvre les DevTools et regarde: seule la couleur change dans le DOM !</p>
    </div>
  )
}
```

---

## Quand React Fait des Re-Rendus

### Les rÃ¨gles d'or

React re-rend un composant **SEULEMENT** dans ces cas :

1. **Changement d'Ã©tat** dans le composant
2. **Changement de props** reÃ§ues du parent
3. **Re-rendu du parent** (cascade)

```jsx
function ParentComponent() {
  const [parentState, setParentState] = useState(0)

  console.log('ğŸ”„ Parent re-rend')

  return (
    <div>
      <h2>Parent State: {parentState}</h2>
      <button onClick={() => setParentState(parentState + 1)}>
        Changer Parent
      </button>

      {/* Ces enfants vont AUSSI re-rendre quand le parent re-rend */}
      <EnfantSansProps />
      <EnfantAvecProps value={parentState} />
    </div>
  )
}

function EnfantSansProps() {
  console.log('ğŸ”„ Enfant SANS props re-rend quand mÃªme')
  return <p>Je n'ai pas de props mais je re-rend !</p>
}

function EnfantAvecProps({ value }) {
  console.log('ğŸ”„ Enfant AVEC props re-rend')
  return <p>Ma valeur: {value}</p>
}
```

### Optimiser les re-rendus

```jsx
import { memo, useMemo, useCallback } from 'react'

// âœ… OptimisÃ© avec React.memo
const EnfantOptimise = memo(function EnfantOptimise({ value }) {
  console.log('ğŸš€ Je ne re-rend QUE si mes props changent')
  return <p>Valeur optimisÃ©e: {value}</p>
})

function ParentOptimise() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('Andy')

  // âœ… Calcul coÃ»teux optimisÃ©
  const expensiveValue = useMemo(() => {
    console.log('ğŸ’° Calcul coÃ»teux exÃ©cutÃ©')
    return count * 1000
  }, [count])

  // âœ… Fonction optimisÃ©e
  const handleNameChange = useCallback((newName) => {
    setName(newName)
  }, [])

  return (
    <div>
      <h2>Count: {count}</h2>
      <h3>Name: {name}</h3>

      <button onClick={() => setCount(count + 1)}>Count +1</button>
      <button onClick={() => setName(name + '!')}>Name +!</button>

      {/* Ne re-rend que si expensiveValue change */}
      <EnfantOptimise value={expensiveValue} />

      {/* Ne re-rend que si handleNameChange change (jamais ici) */}
      <EnfantAvecCallback onNameChange={handleNameChange} />
    </div>
  )
}
```

---

## Cycle de Vie des Composants avec Hooks

### Migration Class â†’ Hooks

```jsx
// âŒ AVANT - Class Component (deprecated)
class OldLifecycle extends React.Component {
  componentDidMount() {
    console.log('Composant montÃ©')
  }

  componentDidUpdate(prevProps, prevState) {
    console.log('Composant mis Ã  jour')
  }

  componentWillUnmount() {
    console.log('Composant va Ãªtre dÃ©montÃ©')
  }

  render() {
    return <div>Old way</div>
  }
}

// âœ… MAINTENANT - Functional Component avec useEffect
function NewLifecycle() {
  const [count, setCount] = useState(0)

  // Ã©quivalent componentDidMount + componentDidUpdate
  useEffect(() => {
    console.log('Composant montÃ© OU mis Ã  jour')
  })

  // Ã©quivalent componentDidMount uniquement
  useEffect(() => {
    console.log('Composant montÃ© (une seule fois)')
  }, []) // â† Tableau vide = une seule fois

  // Ã©quivalent componentDidUpdate pour count
  useEffect(() => {
    console.log('Count a changÃ©:', count)
  }, [count]) // â† Se dÃ©clenche quand count change

  // Ã©quivalent componentWillUnmount
  useEffect(() => {
    return () => {
      console.log('Nettoyage avant dÃ©montage')
    }
  }, [])

  return <div>Count: {count}</div>
}
```

### Exemples pratiques de cycles de vie

```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null)
  const [loading, setLoading] = useState(true)

  // Charger les donnÃ©es utilisateur quand le composant monte
  // ou quand userId change
  useEffect(() => {
    setLoading(true)

    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => {
        setUser(data)
        setLoading(false)
      })
  }, [userId]) // â† Re-fetch si userId change

  // Nettoyage des timers/subscriptions
  useEffect(() => {
    const timer = setInterval(() => {
      console.log('Timer actif')
    }, 1000)

    // Cleanup function
    return () => {
      clearInterval(timer)
      console.log('Timer nettoyÃ©')
    }
  }, [])

  if (loading) return <div>Chargement...</div>
  if (!user) return <div>Utilisateur non trouvÃ©</div>

  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  )
}
```

### Pattern avancÃ© : Custom Hook pour le cycle de vie

```jsx
function useLifecycle(name) {
  useEffect(() => {
    console.log(`ğŸ¬ ${name} montÃ©`)

    return () => {
      console.log(`ğŸ’€ ${name} dÃ©montÃ©`)
    }
  }, [name])

  useEffect(() => {
    console.log(`ğŸ”„ ${name} mis Ã  jour`)
  })
}

function MyComponent() {
  useLifecycle('MyComponent')

  return <div>Composant avec logs automatiques</div>
}
```

---

## Refs - Ã‰chapper au Flux de DonnÃ©es React

### Quand utiliser les Refs ?

Les **refs** sont une "porte de sortie" pour les cas oÃ¹ tu dois **sortir du flux normal de React** :

```jsx
function ExemplesRefs() {
  const inputRef = useRef(null)
  const timerRef = useRef(null)
  const countRef = useRef(0)

  // âœ… CAS 1: Focus sur un Ã©lÃ©ment DOM
  const focusInput = () => {
    inputRef.current.focus()
  }

  // âœ… CAS 2: Stocker un timer ID
  const startTimer = () => {
    timerRef.current = setInterval(() => {
      countRef.current++
      console.log('Timer:', countRef.current)
    }, 1000)
  }

  const stopTimer = () => {
    clearInterval(timerRef.current)
  }

  // âœ… CAS 3: Valeur qui ne doit PAS dÃ©clencher de re-rendu
  const incrementSilent = () => {
    countRef.current++ // â† Pas de re-rendu !
    console.log('Count silencieux:', countRef.current)
  }

  return (
    <div>
      <input ref={inputRef} placeholder="Clique Focus pour me sÃ©lectionner" />
      <button onClick={focusInput}>Focus Input</button>

      <div>
        <button onClick={startTimer}>Start Timer</button>
        <button onClick={stopTimer}>Stop Timer</button>
        <button onClick={incrementSilent}>Count Silencieux</button>
      </div>
    </div>
  )
}
```

### Refs vs State - La diffÃ©rence cruciale

```jsx
function RefsVsState() {
  const [stateCount, setStateCount] = useState(0)
  const refCount = useRef(0)

  const incrementState = () => {
    setStateCount(stateCount + 1) // â† DÃ©clenche un re-rendu
  }

  const incrementRef = () => {
    refCount.current++ // â† PAS de re-rendu
    console.log('Ref count:', refCount.current)
  }

  console.log('ğŸ”„ Composant re-rendu')

  return (
    <div>
      <p>State Count: {stateCount}</p>
      <p>Ref Count: {refCount.current}</p>

      <button onClick={incrementState}>State +1 (re-rend)</button>
      <button onClick={incrementRef}>Ref +1 (pas de re-rend)</button>
    </div>
  )
}
```

### Manipulation du DOM avec Refs

```jsx
function DOMManipulation() {
  const videoRef = useRef(null)
  const scrollRef = useRef(null)
  const canvasRef = useRef(null)

  const playPause = () => {
    const video = videoRef.current
    if (video.paused) {
      video.play()
    } else {
      video.pause()
    }
  }

  const scrollToTop = () => {
    scrollRef.current.scrollTo({
      top: 0,
      behavior: 'smooth'
    })
  }

  const drawOnCanvas = () => {
    const canvas = canvasRef.current
    const ctx = canvas.getContext('2d')

    ctx.fillStyle = 'red'
    ctx.fillRect(50, 50, 100, 100)
  }

  return (
    <div>
      <h3>ContrÃ´le vidÃ©o</h3>
      <video ref={videoRef} width="300" controls>
        <source src="https://www.w3schools.com/html/mov_bbb.mp4" type="video/mp4" />
      </video>
      <button onClick={playPause}>Play/Pause</button>

      <h3>Scroll automatique</h3>
      <div
        ref={scrollRef}
        style={{ height: '200px', overflow: 'auto', border: '1px solid black' }}
      >
        {Array.from({ length: 50 }, (_, i) => (
          <p key={i}>Ligne {i + 1}</p>
        ))}
      </div>
      <button onClick={scrollToTop}>Scroll to Top</button>

      <h3>Dessin sur Canvas</h3>
      <canvas ref={canvasRef} width="200" height="200" style={{ border: '1px solid black' }} />
      <button onClick={drawOnCanvas}>Dessiner Rectangle</button>
    </div>
  )
}
```

### Pattern avancÃ© : forwardRef

```jsx
import { forwardRef, useImperativeHandle } from 'react'

// Composant enfant qui expose des mÃ©thodes au parent
const FancyInput = forwardRef((props, ref) => {
  const inputRef = useRef()

  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus()
    },
    getValue: () => {
      return inputRef.current.value
    },
    clear: () => {
      inputRef.current.value = ''
    }
  }))

  return <input ref={inputRef} {...props} />
})

// Composant parent qui utilise les mÃ©thodes exposÃ©es
function ParentWithForwardRef() {
  const fancyInputRef = useRef()

  const handleFocus = () => fancyInputRef.current.focus()
  const handleGetValue = () => {
    alert(fancyInputRef.current.getValue())
  }
  const handleClear = () => fancyInputRef.current.clear()

  return (
    <div>
      <FancyInput ref={fancyInputRef} placeholder="Input avec mÃ©thodes exposÃ©es" />
      <button onClick={handleFocus}>Focus</button>
      <button onClick={handleGetValue}>Get Value</button>
      <button onClick={handleClear}>Clear</button>
    </div>
  )
}
```

### Gestion de listes avec Refs

```jsx
function ListWithRefs() {
  const [items, setItems] = useState(['Item 1', 'Item 2', 'Item 3'])
  const itemsRef = useRef({})

  const scrollToItem = (index) => {
    itemsRef.current[index]?.scrollIntoView({
      behavior: 'smooth',
      block: 'center'
    })
  }

  const addItem = () => {
    setItems([...items, `Item ${items.length + 1}`])
  }

  return (
    <div>
      <div style={{ height: '200px', overflow: 'auto', border: '1px solid black' }}>
        {items.map((item, index) => (
          <div
            key={index}
            ref={(el) => itemsRef.current[index] = el}
            style={{ height: '50px', padding: '10px', borderBottom: '1px solid #ccc' }}
          >
            {item}
          </div>
        ))}
      </div>

      <div>
        {items.map((_, index) => (
          <button key={index} onClick={() => scrollToItem(index)}>
            Scroll to {index + 1}
          </button>
        ))}
        <button onClick={addItem}>Ajouter Item</button>
      </div>
    </div>
  )
}
```

---

## Exemple Pratique Complet

```jsx
function TodoAppAvecRendu() {
  const [todos, setTodos] = useState([])
  const [filter, setFilter] = useState('all') // all, active, completed
  const inputRef = useRef(null)
  const renderCountRef = useRef(0)

  // Compter les re-rendus
  renderCountRef.current++

  // Filtrer les todos
  const filteredTodos = useMemo(() => {
    console.log('ğŸ”„ Filtrage des todos')
    switch (filter) {
      case 'active':
        return todos.filter(todo => !todo.completed)
      case 'completed':
        return todos.filter(todo => todo.completed)
      default:
        return todos
    }
  }, [todos, filter])

  // Ajouter une todo
  const addTodo = useCallback(() => {
    const text = inputRef.current.value.trim()
    if (text) {
      setTodos(prev => [...prev, {
        id: Date.now(),
        text,
        completed: false
      }])
      inputRef.current.value = ''
      inputRef.current.focus()
    }
  }, [])

  // Toggle todo
  const toggleTodo = useCallback((id) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ))
  }, [])

  // Supprimer todo
  const deleteTodo = useCallback((id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id))
  }, [])

  // Stats
  const stats = useMemo(() => ({
    total: todos.length,
    active: todos.filter(t => !t.completed).length,
    completed: todos.filter(t => t.completed).length
  }), [todos])

  console.log(`ğŸ”„ TodoApp re-rendu ${renderCountRef.current} fois`)

  return (
    <div style={{ maxWidth: '500px', margin: '0 auto', padding: '20px' }}>
      <h1>Todo App avec Optimisations</h1>

      {/* Statistiques de rendu */}
      <div style={{ background: '#f0f0f0', padding: '10px', marginBottom: '20px' }}>
        <p>ğŸ”„ Re-rendus: {renderCountRef.current}</p>
        <p>ğŸ“Š Total: {stats.total} | Actives: {stats.active} | TerminÃ©es: {stats.completed}</p>
      </div>

      {/* Ajout de todo */}
      <div style={{ marginBottom: '20px' }}>
        <input
          ref={inputRef}
          placeholder="Nouvelle tÃ¢che..."
          onKeyDown={(e) => e.key === 'Enter' && addTodo()}
          style={{ padding: '10px', marginRight: '10px', width: '70%' }}
        />
        <button onClick={addTodo}>Ajouter</button>
      </div>

      {/* Filtres */}
      <div style={{ marginBottom: '20px' }}>
        {['all', 'active', 'completed'].map(filterType => (
          <button
            key={filterType}
            onClick={() => setFilter(filterType)}
            style={{
              padding: '5px 10px',
              marginRight: '5px',
              backgroundColor: filter === filterType ? '#007bff' : '#f8f9fa',
              color: filter === filterType ? 'white' : 'black',
              border: '1px solid #ddd'
            }}
          >
            {filterType.charAt(0).toUpperCase() + filterType.slice(1)}
          </button>
        ))}
      </div>

      {/* Liste des todos */}
      <ul style={{ listStyle: 'none', padding: 0 }}>
        {filteredTodos.map(todo => (
          <TodoItem
            key={todo.id}
            todo={todo}
            onToggle={toggleTodo}
            onDelete={deleteTodo}
          />
        ))}
      </ul>

      {filteredTodos.length === 0 && (
        <p style={{ textAlign: 'center', color: '#666' }}>
          {filter === 'all' ? 'Aucune tÃ¢che' : `Aucune tÃ¢che ${filter}`}
        </p>
      )}
    </div>
  )
}

// Composant optimisÃ© avec memo
const TodoItem = memo(function TodoItem({ todo, onToggle, onDelete }) {
  console.log(`ğŸ”„ TodoItem ${todo.id} re-rendu`)

  return (
    <li style={{
      display: 'flex',
      alignItems: 'center',
      padding: '10px',
      borderBottom: '1px solid #eee'
    }}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
        style={{ marginRight: '10px' }}
      />
      <span style={{
        flex: 1,
        textDecoration: todo.completed ? 'line-through' : 'none',
        color: todo.completed ? '#666' : 'black'
      }}>
        {todo.text}
      </span>
      <button
        onClick={() => onDelete(todo.id)}
        style={{
          background: '#dc3545',
          color: 'white',
          border: 'none',
          padding: '5px 10px',
          borderRadius: '3px'
        }}
      >
        ğŸ—‘ï¸
      </button>
    </li>
  )
})
```

---

## Ressources pour aller plus loin

- ğŸ“– [Rendu et Commit](https://react.dev/learn/render-and-commit)
- ğŸ” [Pourquoi React re-rend](https://ui.dev/why-react-renders)
- ğŸ¯ [RÃ©fÃ©rences avec useRef](https://react.dev/learn/referencing-values-with-refs)
- ğŸ› ï¸ [Manipuler le DOM avec refs](https://react.dev/learn/manipulating-the-dom-with-refs)
- âš¡ [RÃ©pondre aux Ã©vÃ©nements](https://react.dev/learn/responding-to-events)
- ğŸ”— [Higher-Order Components](https://www.robinwieruch.de/react-higher-order-components/)
